<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1"><META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css"><LINK REL="STYLESHEET" HREF="cmdref.css" CHARSET="ISO-8859-1" TYPE="text/css"><TITLE>StreamEdit </TITLE></HEAD><BODY BGCOLOR="#ffffff"><!--#include file="breadcrumb" --><!--#include virtual="/adcnavbar" --><TABLE WIDTH="600" BORDER="0" CELLSPACING="0" CELLPADDING="0"><TR><TD><TABLE WIDTH="600" BGCOLOR="0" BORDER="0" CELLSPACING="0" CELLPADDING="0">	<TR>		<TD><P CLASS="BookTitle">MPW Command Reference</P></TD>	</TR></TABLE><TABLE WIDTH="600" BORDER="0" CELLSPACING="0" CELLPADDING="0">	<TR>		<TD WIDTH="200"><P CLASS="HeaderLink"><A HREF="stackwindows.html">Previous</A></P></TD>		<TD WIDTH="200"><P CLASS="HeaderLink"><A HREF="index.html">Table of Contents</A></P></TD>		<TD WIDTH="200"><P CLASS="HeaderLink"><A HREF="target.html">Next</A></P></TD>	</TR></TABLE><HR WIDTH="600" ALIGN="LEFT"><TABLE WIDTH="600" BORDER="0" CELLSPACING="0" CELLPADDING="0">	<TR>		<TD WIDTH="475"><P CLASS="PageHdL">StreamEdit</P></TD>		<TD WIDTH="125"><P CLASS="PageHdR">Tool</P></TD>	</TR></TABLE><P CLASS="SectionHd">SYNTAX</P><P CLASS="Syntax">StreamEdit <I>file1</I> [<I>file2</I>]&#133; [-d] [-e <I>scriptString</I>] [-o <I>outputFile</I>]<BR> [-p] [-s <I>scriptFile</I>] [-set <I>variable</I>[=<I>value</I>]]</P><P CLASS="SectionHd">DESCRIPTION</P><P CLASS="Text1">The StreamEdit tool allows you to modify the text that appears in the specified files by executing one or more scripts (<FONT FACE="courier">-e</FONT> or <FONT FACE="courier">-s</FONT>) containing text-editing statements. Each statement is applied to each line of text and, after all the statements have been processed, the modified input files are written to either the specified output file or to standard output.</P><P CLASS="Text1">StreamEdit provides a set of commands that can be used in conjunction with address expressions in statements to perform text matching and editing. This makes StreamEdit useful for handling repetitive changes to source files, such as extracting comments or replacing one identifier with another. </P><P CLASS="Note"><B>Note</B><BR>StreamEdit is a noninteractive text editor similar in function to the UNIX&#174; tool <FONT FACE="courier">sed</FONT>.However, StreamEdit is not compatible with <FONT FACE="courier">sed</FONT> or <FONT FACE="courier">awk</FONT>.  &#149;</P><P CLASS="Text1">The StreamEdit tool operates by maintaining three text buffers:</P><P CLASS="Text1"><FONT FACE="courier">&#149; </FONT>The edit buffer holds the current line of input. Most StreamEdit expressions and commands operate on this buffer.</P><P CLASS="Text1"><FONT FACE="courier">&#149; </FONT>The insert buffer holds text to be printed before the current input line. This buffer is set by the <FONT FACE="courier">Insert</FONT> command.</P><P CLASS="Text1"><FONT FACE="courier">&#149; </FONT>The append buffer holds text to be printed after the current input line. This buffer is set by the <FONT FACE="courier">Append</FONT> command.</P><P CLASS="Text1">For each line of text in the input, StreamEdit does the following:</P><P CLASS="Text1">1. Reads the next input line into the edit buffer.</P><P CLASS="Text1">2. Evaluates each address expression in the script with respect to the contents of the edit buffer and, if the expression matches, executes the commands that follow the expression.</P><P CLASS="Text1">3. Concatenates the insert, edit, and append buffers and writes them to the output file after all address expressions have been evaluated.</P><P CLASS="Text1">StreamEdit has its own language for text manipulation. Each part of the language is explained in the special <A HREF="#Statements">Statements</A> section, which follows the <A HREF="#Options">Options</A> section.</P><P CLASS="SectionHd">INPUT</P><P CLASS="Text1">Standard input, unless you specify one or more text files (<I>file</I>) on the command line.</P><P CLASS="SectionHd">OUTPUT</P><P CLASS="Text1">Standard output, unless you specify an output file using <FONT FACE="courier">-o</FONT> or <FONT FACE="courier">-to <I>file</I></FONT> or <FONT FACE="courier">-appendto <I>file</I></FONT> after a command.</P><P CLASS="SectionHd">STATUS</P><P CLASS="Text1">StreamEdit can return the following status codes:<BR><BR></P><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0"><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextL">0</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextR">no errors</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextL">1</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextR">syntax error</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextL">2 </P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextR">execution error</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextL">3 </P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextR">system error</P></TD></TR></TABLE><P CLASS="Note"><B>Note</B><BR>You can also specify a status code with the <FONT FACE="courier">Exit</FONT> command (see <A HREF="#Commands">Commands</A> in the <A HREF="#Statements">Statements</A> section). &#149;</P><P CLASS="SectionHd">PARAMETERS</P><P CLASS="Option1"><I>file1</I> [<I>file2</I>]&#133;</P><P CLASS="OptionText1">Specifies one or more input text files to be modified. If you do not specify any input files, StreamEdit reads standard input.</P><P CLASS="OptionText1">In the following example the text from the <FONT FACE="courier">Words</FONT> text file is modified by the StreamEdit statements in the <FONT FACE="courier">Alter</FONT> script:</P><P CLASS="OptionCode1">StreamEdit Words -s Alter</P><A NAME="Options"></A><P CLASS="SectionHd">OPTIONS</P><P CLASS="Text1">Note that you can specify more than one script; scripts specified by <FONT FACE="courier">-e</FONT> or <FONT FACE="courier">-s</FONT> are concatenated in the order in which they appear on the command line. If you do not specify any scripts and do not specify <FONT FACE="courier">-d</FONT>, StreamEdit merely copies all of the input lines to output.</P><P CLASS="Option1">-d</P><P CLASS="OptionText1">Deletes all input lines, leaving only output from <FONT FACE="courier">Print</FONT> or <FONT FACE="courier">Next</FONT> commands. This filters the initial input lines so that they are not written to the output unless a <FONT FACE="courier">Print</FONT> or <FONT FACE="courier">Next</FONT> command explicitly prints. </P><P CLASS="Option1">-e <I>scriptString</I> </P><P CLASS="OptionText1">Reads text-editing statements from the script contained in the string <I>scriptString.</I>In addition to placing more than one statement in a single string, you can use <FONT FACE="courier">-e</FONT> more than once on a command line and can specify it in conjunction with <FONT FACE="courier">-s</FONT>. </P><P CLASS="OptionText1">Remember to use semicolons to separate multiple statements within the string and, as always, place quotation marks around the entire string argument to this option. Thus a command such as</P><P CLASS="OptionCode1">StreamEdit -s script1 -d </P><P CLASS="OptionText1">where the <FONT FACE="courier">script1</FONT> file contains</P><P CLASS="OptionCode1">1 print 'ONE'<BR>2 print 'TWO'</P><P CLASS="OptionText1">can be written using the <FONT FACE="courier">-e</FONT> option as</P><P CLASS="OptionCode1">StreamEdit -e &quot;1 Print 'ONE'; 2 Print 'TWO'&quot; -d</P><P CLASS="Option1">-o <I>outputFile</I> </P><P CLASS="OptionText1">Directs output to the specified output file instead of standard output. StreamEdit does not produce any output until all the input is read. This allows you to specify one of the input files as the output file. </P><P CLASS="OptionText1">In the following example, StreamEdit reads the entire input file, <FONT FACE="courier">Words</FONT>, before writing text modifications to the same file: </P><P CLASS="OptionCode1">StreamEdit Words -s Alter -o Words</P><P CLASS="Option1">-p</P><P CLASS="OptionText1">Writes progress information to diagnostic output.</P><P CLASS="Option1">-s <I>scriptFile</I></P><P CLASS="OptionText1">Reads text-editing statements from a script contained in the file <I>scriptFile.</I> Statements within the script can be terminated by either a newline or a semicolon. This option can be used more than once and in conjunction with <FONT FACE="courier">-e</FONT>. </P><P CLASS="OptionText1">In the following example, StreamEdit executes the statements found in the <FONT FACE="courier">MyScript</FONT> script file.</P><P CLASS="OptionCode1">StreamEdit -s MyScript</P><P CLASS="Option1">-set <I>variable</I>[=<I>value</I>]</P><P CLASS="OptionText1">Sets a variable's initial value before StreamEdit processes any statements. If you omit <I>value</I>, <I>variable</I> is set to the empty string. </P><A NAME="Statements"></A><P CLASS="SectionHd">STATEMENTS</P><P CLASS="Text1">Statements contain an address expression, which tells StreamEdit exactly what line or range of lines to modify, and one or more commands, which tell it what changes to perform on those lines. An optional "count" can also be specified which tells StreamEdit to only change the first"count" matches.</P><P CLASS="Text1">These statements have the syntax</P><P CLASS="Code"><I>addressExpression</I> [-c <I>count</I>] <I>command</I> [;<I>command</I>]&#133;</P><P CLASS="Text1">where <I>addressExpression</I> is an expression that uses line numbers and regular expressions to match one or more lines, and <I>command</I> is one of several StreamEdit commands, most of which accept a text argument. In a script file  (<FONT FACE="courier">-s</FONT>), you can use newlines or semicolons to separate statements and  commands. In a script string (<FONT FACE="courier">-e</FONT>) only the semicolon can be used.  These syntax elements are covered in detail in <A HREF="#AddressExpressions">Address Expressions</A>, <A HREF="#TextArguments">Text Arguments</A>, and <A HREF="#Commands">Commands</A> below.</P><P CLASS="Note"><B>Note</B><BR>Although semicolons usually indicate breaks (as in the MPW Shell) and are used to terminate commands, a semicolon located in the first column of a script line receives special treatment. When a semicolon is found in this position, StreamEdit considers the entire line to be a comment. This allows you to write StreamEdit scripts that also contain MPW Shell commands (see the second example in <A HREF="#Examples">Examples</A>). In all other cases, comments must begin with a # sign. &#149;</P><P CLASS="Text1">&nbsp;</P><A NAME="AddressExpressions"></A><P CLASS="Text1"><B>Address Expressions</B></P><P CLASS="Text1">Every command must have a line address; however, a single address may be followed by a number of commands, terminating only when a new address is specified.</P><P CLASS="Text1">You can specify addresses numerically (by line number), by context matching using regular expressions, or by simple Boolean functions of the two. Boolean functions can be created by using numerical and regular expression addresses in conjunction with address operators. </P><P CLASS="Text1">The following list describes address operators in decreasing order of precedence:</P><P CLASS="Option1">(<I>address</I>)</P><P CLASS="OptionText1">Parentheses control precedence.</P><P CLASS="Option1">!<I>address</I></P><P CLASS="OptionText1">The address expression must not match; this uses the <FONT FACE="courier">NOT</FONT> operator.</P><P CLASS="Option1"><I>address</I>&amp;&amp;<I>address</I></P><P CLASS="OptionText1">Both address expressions must match; if the first address expression fails, the second address expression is not evaluated.</P><P CLASS="Option1"><I>address</I>||<I>address</I></P><P CLASS="OptionText1">Either address expression may match; if the first address expression succeeds, the second address expression is not examined.</P><P CLASS="Option1"><I>address</I>,<I>address</I></P><P CLASS="OptionText1">The comma operator matches the inclusive range of lines between the first address expression and the second address expression.</P><P CLASS="Option1">/<I>regular expression</I>/</P><P CLASS="OptionText1">The slash operator matches the text pattern defined by the regular expression. </P><P CLASS="OptionText1">For more information about regular expressions, refer to the chapter &quot;Editing With Commands&quot; in <I>Introduction to MPW</I>.</P><P CLASS="OptionNote1"><B>Note</B><BR>Regular expressions supported by the MPW Shell have been extended for StreamEdit to include the following three:</P><P CLASS="Option2">&ccedil; (Option-C) </P><P CLASS="OptionText2">Causes a case-sensitive match of the text pattern indicated by the regular expression when <FONT FACE="courier">&ccedil;</FONT> is the first character in a regular expression. Normally, matches are not case sensitive. </P><P CLASS="OptionText2">When using a bullet character to indicate a match at the beginning of the line, the bullet must follow <FONT FACE="courier">&ccedil;</FONT>. In other words, you use </P><P CLASS="OptionCode2">/&ccedil;&#149;moo/ </P><P CLASS="OptionText2">instead of </P><P CLASS="OptionCode2">/&#149;&ccedil;moo/				# Not This!</P><P CLASS="Option2">//</P><P CLASS="OptionText2">Indicates the last regular expression matched. Note that the last regular expression matched may be different from the most recent regular expression in a script due to the conditional evaluation that occurs with the <FONT FACE="courier">&amp;&amp;</FONT> and <FONT FACE="courier">||</FONT> operators.</P><P CLASS="OptionText2">For instance, this expression replaces all occurrences of 1 or 2 with 3:</P><P CLASS="OptionCode2">/1/ || /2/ Replace // &quot;3&quot; -c &#8734;</P><P CLASS="Option2">&#8804;<I>variable</I>&#8805;</P><P CLASS="OptionText2">Matches the value of the specified variable. This allows you to reference the value of a variable by enclosing the variable between &#8804; and &#8805; symbols. Notice the similarity to the way braces work in the MPW Shell. </P><P CLASS="OptionText2">The variable's value is not treated as a regular expression but as a string argument to be matched. An empty variable (that is, a null string) matches nothing. This is important to remember since variables are empty until they are set!</P><P CLASS="OptionText2">The following script sets the variable <FONT FACE="courier">VAR</FONT> to <FONT FACE="courier">&quot;moo&quot;</FONT>at the beginning of the text file and then prints all occurrences of <FONT FACE="courier">&quot;moo&quot;</FONT> to standard output:</P><P CLASS="OptionCode2">&#149; Set VAR &quot;moo&quot;<BR>/&#8804;VAR&#8805;/ print </P><P CLASS="OptionText2">For a case-sensitive variable match you replace <FONT FACE="courier">/&#8804;VAR&#8805;/</FONT> with <FONT FACE="courier">/&ccedil;&#8804;VAR&#8805;/</FONT>.</P><P CLASS="Option1"><I>n</I> </P><P CLASS="OptionText1">Matches input line number <I>n</I>.</P><P CLASS="Option1">&#149;  (Option-8)</P><P CLASS="OptionText1">Matches the point prior to the first input line, when specified alone. </P><P CLASS="Option1">&#8734;  (Option-5)</P><P CLASS="OptionText1">Matches the point after the last input line, when specified alone. </P><P CLASS="Option1">$</P><P CLASS="OptionText1">Matches the last input line.</P><P CLASS="Text1">You can use these operators to create complex addresses. For example, this address will match any line containing either the text &quot;trillian&quot;, or both &quot;zaphod&quot; and &quot;beeblebrox&quot; (in any order), as long as it is not found on line 42 of input:</P><P CLASS="Code">(/trillian/ || /zaphod/ &amp;&amp; /beeblebrox/) &amp;&amp; !42</P><P CLASS="Text1">Although extremely useful, the range operator (the comma) can be tricky because it represents a two-state system rather than a continuous test for a condition. When the condition for the start of the range is met, source lines are considered to match up to and including the line at which the condition for the end of the range is met. If the first condition is not met, StreamEdit does not consider any lines in the range; if the last condition is not met, StreamEdit considers the succeeding lines to be a match forever.</P><P CLASS="Text1">For example, this address will match any line containing the word &quot;Copyright&quot; if it is found in one of the first ten lines of the input file:</P><P CLASS="Code">(1,10) &amp;&amp; /Copyright/</P><P CLASS="Text1">However, if the order is reversed, as in the following line, StreamEdit matches the range <FONT FACE="courier">/Copyright/ &amp;&amp; 1</FONT> to <FONT FACE="courier">/Copyright/ &amp;&amp; 10</FONT>: </P><P CLASS="Code">/Copyright/ &amp;&amp; (1,10)</P><P CLASS="Text1">If &quot;Copyright&quot; does not appear on the tenth input line, the range stays active until the end of input. If it does not appear on the first input line, the range is not activated at all. </P><P CLASS="Text1">&nbsp;</P><A NAME="TextArguments"></A><P CLASS="Text1"><B>Text Arguments</B></P><P CLASS="Text1">Most commands accept text arguments that allow you to modify the input lines with specific text. These text arguments can take any of the following forms:</P><P CLASS="Option1">&quot;<I>string</I>&quot; or '<I>string</I>' </P><P CLASS="OptionText1">Indicates a string. Special characters within the string are interpreted.</P><P CLASS="Text1"><FONT FACE="courier">. </FONT> (period)</P><P CLASS="OptionText1">Represents the current input line, minus its newline.</P><P CLASS="Option1"><I>variable</I></P><P CLASS="OptionText1">Represents the contents of a variable. The StreamEdit tool considers variables to be names for strings and allows variable names that follow the same rules as case-ignored C identifiers (that is, <FONT FACE="courier">[a-z_] [a-z0-9_]*</FONT>). Remember that variables are empty until set.</P><P CLASS="Option1">&#174;<I>n</I></P><P CLASS="OptionText1">Specifies expression <I>n</I>, from the most recent regular expression match.</P><P CLASS="Option1">-from <I>filename</I></P><P CLASS="OptionText1">Reads the next line of input from the specified file, minus any trailing newline. As with the options <FONT FACE="courier">-to</FONT> and <FONT FACE="courier">-appendto</FONT>, the <I>filename</I> argument can take any text argument form, including strings, variables, and &#174;-variables. </P><P CLASS="OptionText1">The StreamEdit tool can read any number of files, because it is not limited by the system's file control block (FCB) count, and can also read a file that is being written to without changing the read position.</P><P CLASS="Text1">When quoting special characters within strings and regular expressions, you use the backslash (<FONT FACE="courier">\</FONT>) or MPW Shell quote (&#8706;) characters. You will often need to quote special characters for text-matching purposes, as in the <FONT FACE="courier">Delete</FONT> example in which StreamEdit searches for any number of spaces or tabs <FONT FACE="courier">( &#8706;t)*</FONT> before a comment mark. </P><P CLASS="Text1">The quoted forms of other special characters and their meanings follow:<BR><BR></P><!-- Table Start --><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0"><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextL"><FONT FACE="courier">&#8706;n </FONT>or<FONT FACE="courier"> \n</FONT></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextR">Newline </P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextL"><FONT FACE="courier">&#8706;t </FONT>or<FONT FACE="courier"> \t</FONT></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextR">Tab</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextL"><FONT FACE="courier">&#8706;\ </FONT>or<FONT FACE="courier"> \\</FONT></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextR">Backslash</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextL"><FONT FACE="courier">&#8706;&#8706; </FONT>or<FONT FACE="courier"> \&#8706;</FONT></P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TableTextR">MPW Shell quote</P></TD></TR></TABLE><!-- Table End --><P CLASS="Text1">&nbsp;</P><A NAME="Commands"></A><P CLASS="Text1"><B>Commands</B> </P><P CLASS="Text1">Commands can modify the current input line, set variables, print text, and affect the flow of control within scripts (that is, using the <FONT FACE="courier">Next</FONT> and <FONT FACE="courier">Exit</FONT> commands allows you to control the way in which StreamEdit processes scripts). Note that if the current input line is modified, subsequent address matches search for the modified line instead of the original input line.</P><P CLASS="Text1">As noted earlier, statements and individual commands can be separated by either semicolons or newlines. However, for scripts contained in a string (<FONT FACE="courier">-e <I>scriptString</I></FONT>), statements and commands can be separated only by semicolons. In addition, although empty commands are allowed and do not produce any output, the first command following an address expression cannot be empty. </P><P CLASS="Option1">App[end] <I>text</I>  [-n] </P><P CLASS="OptionText1">Appends the specified text to the append buffer, to be written at the end of the current cycle.</P><P CLASS="Option2"><I>text</I></P><P CLASS="OptionText2">Specifies the text that is appended to the addressed line. </P><P CLASS="Option2">-n </P><P CLASS="OptionText2">Inhibits adding a newline. Normally StreamEdit always adds a newline after a change is made.</P><P CLASS="OptionText1">In the following example, the first statement causes the text argument to be appended to the last input line, while the second causes the text argument to be appended to line 42 without adding a newline:</P><P CLASS="OptionCode1">$ Append &quot;This follows the last line of input&quot;<BR><BR>42 App &quot;This is line 43==&gt;&quot; -n</P><P CLASS="Option1">Ch[ange] <I>text</I>  [-n]</P><P CLASS="OptionText1">Replaces the contents of the edit buffer with the specified text.</P><P CLASS="Option2"><I>text</I></P><P CLASS="OptionText2">Specifies the text that replaces the text at the addressed line. Omitting this parameter performs the same function as the <FONT FACE="courier">Del[ete]</FONT> command.</P><P CLASS="Option2">-n </P><P CLASS="OptionText2">Inhibits adding a newline. Normally StreamEdit always adds a newline after a change is made.</P><P CLASS="OptionText1">The first example changes line 42 of input to read <FONT FACE="courier">&quot;This is line 42&quot;</FONT>, while the second changes the line containing the string <FONT FACE="courier">&quot;droid&quot;</FONT> to <FONT FACE="courier">&quot;These are not your droids!&quot;</FONT>:</P><P CLASS="OptionCode1">42 Change &quot;This is line 42&quot;</P><P CLASS="OptionCode1">/droid/ Ch &quot;These are not your droids!&quot;</P><P CLASS="Option1">Del[ete]</P><P CLASS="OptionText1">Deletes the contents of the edit buffer. Executing <FONT FACE="courier">Change</FONT> without a text argument performs the same function.</P><P CLASS="OptionText1">The first example deletes every line of the input file, while the second deletes every MPW Shell comment it finds by searching for any number of spaces or tabs followed by a # character at the beginning of a line:</P><P CLASS="OptionCode1">1,$ Delete</P><P CLASS="OptionCode1">/&#149;[ &#8706;t]*#/ Delete</P><P CLASS="Option1">Exit [<I>status</I>]</P><P CLASS="OptionText1">Stops processing and exits with the specified status code, where <I>status</I> is any number. If you do not specify <I>status</I>, StreamEdit exits with a default status of 0.</P><P CLASS="OptionText1">In the first example StreamEdit exits with a status of 42, while in the second example, it exits with a default status of 0 at line 3:</P><P CLASS="OptionCode1">Exit 42</P><P CLASS="OptionCode1">3 Exit</P><P CLASS="Option1">Ins[ert] <I>text</I>  [-n]</P><P CLASS="OptionText1">Appends the specified text to the insert buffer, to be written at the end of the current cycle.</P><P CLASS="Option2"><I>text</I></P><P CLASS="OptionText2">Specifies the text to be inserted at the line address. </P><P CLASS="Option2">-n </P><P CLASS="OptionText2">Inhibits adding a newline. Normally StreamEdit always adds a newline after a change is made.</P><P CLASS="OptionText1">In the following two examples, text is inserted at the beginning of the line addressed, but the trailing newline is discarded in the second:</P><P CLASS="OptionCode1">1 Insert &quot;This precedes the first line&quot; </P><P CLASS="OptionCode1">42 Ins &quot;This is line 42==&gt;&quot; -n</P><P CLASS="Option1">Next</P><P CLASS="OptionText1">Stops the StreamEdit process and fetches the next input line immediately. (Normally, StreamEdit matches the current input  line against each address expression in the script.) Note that the text prior to the line address  is printed only once, regardless of the presence or absence of <FONT FACE="courier">-d</FONT> on the command line.</P><P CLASS="OptionText1">The following example would be useful if you want to ignore input until <FONT FACE="courier">&quot;moo&quot;</FONT> is found. When the script reaches this statement, the next line is retrieved and the lines ranging from line 1 to the line that contains the string <FONT FACE="courier">&quot;moo&quot;</FONT> can no longer be altered.</P><P CLASS="OptionCode1">1,/moo/ Next</P><P CLASS="Option1">Opt[ion] Auto[Delete]</P><P CLASS="OptionText1">Deletes all input lines, leaving only the output from <FONT FACE="courier">Print</FONT> commands. This is useful for writing scripts to filter the input. </P><P CLASS="OptionText1">Appending the following command to the end of the script or specifying <FONT FACE="courier">-d</FONT> on the command line are equivalent in effect to using <FONT FACE="courier">Opt[ion] AutoDelete</FONT>.</P><P CLASS="OptionCode1">/&#8776;/ Delete</P><P CLASS="Option1">Pr[int] <I>text</I> [-appendto <I>file</I>] [-to <I>file</I>]</P><P CLASS="OptionText1">Prints the specified text to standard output or to a file specified by <FONT FACE="courier">-to</FONT> or <FONT FACE="courier">-appendto</FONT>. The text prints immediately, without modification from other commands at that address. </P><P CLASS="Option2"><I>text</I></P><P CLASS="OptionText2">Specifies the text to be printed. If you do not specify any text, the contents of the current line prints without modification.</P><P CLASS="Option2">-appendto <I>file</I> </P><P CLASS="OptionText2">Appends the output of the <FONT FACE="courier">Print</FONT> command to the specified file. You can specify the output file <I>file</I> with a string, a variable, or an &#174; variable. </P><P CLASS="OptionText2">If the file does not already exist, StreamEdit creates it; however, if the filename is an empty string (that is, an uninitialized variable), nothing is printed.</P><P CLASS="Option2">-to <I>file</I></P><P CLASS="OptionText2">Writes the output of the <FONT FACE="courier">Print</FONT> command to the specified file, truncating the file the first time it is written to. You can specify  the output file <I>file</I> with a string, a variable, or an &#174; variable.</P><P CLASS="OptionText2">If the file does not already exist, StreamEdit creates it; however, if the filename is an empty string (that is, an uninitialized variable), nothing is printed.</P><P CLASS="OptionText1">The first example below prints lines 1-10 of the input file to standard output. The second example prints each string to a file of the same name as the string.</P><P CLASS="OptionCode1">1,10 Print</P><P CLASS="OptionCode1">/([a-z0-9]+)&#174;1/ Print -to &#174;1 </P><A NAME="Replace"></A><P CLASS="Option1">Rep[lace] [-c <I>count</I>]  /<I>pattern</I>/  <I>replacementText</I></P><P CLASS="OptionText1">Replaces the text described by the regular expression <I>pattern</I> in the edit buffer with <I>replacementText</I>.</P><P CLASS="Option2">/<I>pattern</I>/</P><P CLASS="OptionText2">Specifies the text to be replaced, using the pattern-matching capabilities of regular expressions.</P><P CLASS="Option2"><I>replacementText</I> </P><P CLASS="OptionText2">Specifies the string that replaces the text described by <FONT FACE="courier">/<I>pattern</I>/</FONT>. </P><P CLASS="OptionNote1"><B>Note</B><BR>Unlike its behavior in other commands, an &#174; variable in the replacement text refers to the value set when StreamEdit processes the regular expression, <FONT FACE="courier">/<I>pattern</I>/</FONT>. It does not refer to an &#174; variable in the line address. &#149;</P><P CLASS="Option2">-c <I>count</I> </P><P CLASS="OptionText2">Indicates the number of times <FONT FACE="courier">/<I>pattern</I>/</FONT> is replaced in each matched input line by the new text, <I>replacementText</I>. You can specify the count with either a number or &#8734; (infinite count).	</P><P CLASS="OptionText1">The first example replaces the number 42 with the text <FONT FACE="courier">&quot;Meaning of Life&quot;</FONT> when it is found on line 42. The second example appears almost identical to the first, yet the number 42 is replaced by the contents of the variable <FONT FACE="courier">MeaningOfLife</FONT>.In the third example, the number 42 is replaced by <FONT FACE="courier">&quot;line 42&quot;</FONT>.</P><P CLASS="OptionCode1">42 Replace /42/ &quot;Meaning of Life&quot;</P><P CLASS="OptionCode1">42 Replace /42/ MeaningOfLife</P><P CLASS="OptionText1"><FONT FACE="courier">42 Replace /(42)&#174;1/ &quot;line &quot;&#174;1</FONT></P><P CLASS="OptionNote1"><B>Note</B><BR>Be careful not to confuse variables (unquoted) with strings (quoted). Since variables are empty until they are set, accidentally specifying a variable instead of a string (for example, <FONT FACE="courier">MeaningOfLife</FONT> instead of &quot;<FONT FACE="courier">Meaning of Life</FONT>&quot;) deletes the original text. &#149;</P><P CLASS="Option1">Set  <I>variable</I>  <I>text</I>  [-a]  [-i] </P><P CLASS="OptionText1">Sets a variable's value to the specified string, without adding an automatic newline.</P><P CLASS="Option2"><I>variable</I></P><P CLASS="OptionText2">Specifies the variable whose value is set to <I>text</I>.</P><P CLASS="Option2"><I>text</I></P><P CLASS="OptionText2">Specifies the text string to which <I>variable</I> is set.</P><P CLASS="Option2">-a</P><P CLASS="OptionText2">Appends the text string, <I>text</I>, to the variable's current contents.</P><P CLASS="Option2">-i</P><P CLASS="OptionText2">Inserts the text string, <I>text</I>, before the variable's current contents.</P><P CLASS="OptionText1">The first example sets the <FONT FACE="courier">Line</FONT> variable to the contents of the current line and explicitly adds a newline. Note that the period (<FONT FACE="courier">.</FONT>) represents the current input line (see <A HREF="#TextArguments">Text Arguments</A>, earlier). </P><P CLASS="OptionCode1">Set Line . &quot;\n&quot;</P><P CLASS="OptionText1">In the following example the text <FONT FACE="courier">&quot;Dirk Gently&quot;</FONT> is inserted before the other contents of the <FONT FACE="courier">DouglasAdams</FONT> variable.</P><P CLASS="OptionCode1">Set -i DouglasAdams &quot;Dirk Gently&quot;</P><A NAME="Examples"></A><P CLASS="SectionHd">EXAMPLES</P><P CLASS="Text1">The following two examples demonstrate how you can use StreamEdit to solve text-editing problems. </P><P CLASS="Text1">&nbsp;</P><P CLASS="Text1"><B>Extracting the Leaf</B></P><P CLASS="Text1">It is sometimes necessary to extract the leaf part of a complete pathname in an MPW Shell script. You can do this by putting the following statement into a file named <FONT FACE="courier">FilterLeaf</FONT>:</P><P CLASS="Code">StreamEdit -d -e '/(&#8776;:)*([&#172;:]*)&#174;1/ print &#174;1'</P><P CLASS="Text1">The regular expression <FONT FACE="courier">/(&#8776;:)*([&#172;:]*)&#174;1/</FONT> sets <FONT FACE="courier">&#174;1</FONT> to the part of the filename following the last colon, or to the whole filename if yours does not contain a colon.</P><P CLASS="Text1">To test the script you can type</P><P CLASS="Code">Echo &quot;The:I:Is:Silent:MyFile&quot; | Filterleaf</P><P CLASS="Text1">This produces the output</P><P CLASS="Code">MyFile</P><P CLASS="Text1">&nbsp;</P><P CLASS="Text1"><B>Generating Inline Function Declarations</B></P><P CLASS="Text1">This script generates MPW C or C++ inline function declarations from assembly-language source code. It automates the process of extracting object codes by taking advantage of the format of a listing file and makes the job quicker and less error prone than cutting and pasting. See Listing 1 below.</P><P CLASS="Note"><B>Note</B><BR>The character &#165; in the assembly-language code comment marks the declaration. In principle, any unique character or string can be used.  &#149;</P><P CLASS="Text1">The StreamEdit script needs to generate inline declarations that look like this:</P><P CLASS="Code">void pascal_string_copy(char* src, char* dest) =<BR>{0x4CD7, 0x0300, 0x7000, 0x1011, 0x6002, 0x10D9, 0x51C8, 0xFFFC};</P><P CLASS="Text1">You can begin automating the process that generates this inline declaration by typing the script shown in Listing 2 into a new file named <FONT FACE="courier">MakeCInline</FONT>.</P><P CLASS="ListingTitle">Listing 1: A typical assembly-language listing</P><PRE CLASS="Code">MC680xx Assembler - Ver 3.2 18-Feb-91           Page 1Copyright Apple Computer, Inc. 1984-1990Loc   F Object Code  Addr  M  Source Statement   ;+   ; Inline Pascal string copy   ;   ;&#165; void pascal_string_copy(char* src, char* dest);   ;   ;-00000                         strcopy proc00000   4CD7 0300                     movem.l  (SP), A0-A100004   7000                          moveq    #0, D000006   1011                          move.b   (A1), D000008   6002         0000C            bra.s    @20000A   10D9                  @loop:  move.b   (A1)+, (A0)+0000C G 51C8 FFFC    0000A    @2:     dbra     D0, @loop00010                                 endproc                                      endElapsed time: 0.11 seconds.Assembly complete - no errors found.  16 lines.</PRE><P CLASS="ListingTitle">Listing 2: MakeCInline inline declaration</P><P CLASS="Code"># MakeCInline--make C assembly language inline declarations<BR># Shell commands:--Assemble listing file,<BR># pass listing file to StreamEdit and delete listing file<BR>; Asm &quot;{1}&quot; -l			<BR>; StreamEdit -d -s &quot;`which &quot;{0}&quot;`&quot; &quot;{1}&quot;.lst			<BR>; Delete &quot;{1}&quot;.lst &quot;{1}&quot;.o<BR>; Exit<BR><BR># StreamEdit commands<BR># Print declaration line and inline format<BR>&nbsp;&nbsp;/;&#165;[ &#8706;t]*([&#172;;]*)&#174;1/<BR>&nbsp;&nbsp;Print -n &#174;1 &quot; =&#8706;n{&quot;<BR>&nbsp;&nbsp;Set PrecedingComma &quot;&quot;<BR>&nbsp;&nbsp;Delete<BR>&nbsp;&nbsp;/[ &#8706;t]ENDP/<BR>&nbsp;&nbsp;Print &quot;};&#8706;n&quot;<BR>&nbsp;&nbsp;Delete<BR><BR># Delete unnecessary lines, text before hex constant<BR> !/&#149;[0-9a-f]+ [g] [0-9a-f]&#171;4&#187;/ Delete<BR> 1,$ Replace /[0-9a-f]+ [g] / &quot;&quot;<BR><BR># Print hex constant, preceded by standard 0x<BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1 /<BR> Print -n PrecedingComma &quot;0x&quot;&#174;1<BR> Set PrecedingComma &quot;, &quot;<BR> Replace // &quot;&quot;<BR><BR># Convert remaining words on line<BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1/<BR> Print -n &quot;, 0x&quot;&#174;1<BR> Replace // &quot; &quot;<BR><BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1/<BR> Print -n &quot;, 0x&quot;&#174;1<BR> Replace // &quot; &quot;<BR><BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1/<BR> Print -n &quot;, 0x&quot;&#174;1<BR> Replace // &quot; &quot; <BR><BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1/<BR> Print -n &quot;, 0x&quot;&#174;1<BR> Replace // &quot; &quot;</P><P CLASS="Text1">When you want to execute the script for any assembly-language source file use the following command line:</P><P CLASS="Code">MakeCInline <I>assembly</I>.a &gt;<I> outputFile</I></P><P CLASS="Text1">MakeCInline writes the inline declarations from the assembly-language listing file to the specified output file.</P><P CLASS="Text1">How does this work? The MakeCInline script has two parts. </P><P CLASS="Text1">The first part of the script, <FONT FACE="courier">&quot;# Shell commands&#133;&quot;</FONT>, is purposely commented out from StreamEdit to force the MPW Shell to perform certain tasks. These commands are executed by the MPW Shell but are ignored by StreamEdit because the semicolons preceding each line signal comments to StreamEdit.</P><P CLASS="Text1">The MPW Shell first runs the assembler on the input source file and produces a listing file (see the <A HREF="asm.html">Asm</A> command): </P><P CLASS="Code">;Asm &quot;{1}&quot; -l</P><P CLASS="Text1">StreamEdit then uses the listing file (<FONT FACE="courier">&quot;{1}&quot;.lst</FONT>) as input for the currently executing script, <FONT FACE="courier">{0}</FONT>:</P><P CLASS="Code">;StreamEdit -d -s &quot;{0}&quot; &quot;{1}&quot;.lst</P><P CLASS="Text1">The following lines delete the listing and object files before exiting the MPW Shell portion of the script.</P><P CLASS="Code">;Delete&quot;{1}&quot;.lst&quot; {1}&quot;.o<BR>;Exit</P><P CLASS="Text1">The second part of the MakeCInline script consists of several sections of StreamEdit commands that extract the object codes from the assembly-language listing and put them in the appropriate format for an inline declaration. </P><P CLASS="Text1">The first of these sections, <FONT FACE="courier">&quot;# Print declaration line&#133;&quot;</FONT>, sets the format for the object codes. Its first task is to extract the declaration and copy it to output for the inline declaration. </P><P CLASS="Text1">The regular expression in the first line finds the inline declaration by virtue of the marker &quot;&#165;&quot;, which carries over to the assembly-language listing. The following StreamEdit command line extracts the line containing a &#165;, followed by any number of spaces or tabs, then by text possibly ending in a semicolon. The text, excluding a possible trailing semicolon, is stored in variable <FONT FACE="courier">&#174;1</FONT>.</P><P CLASS="Code">/;&#165;[ &#8706;t]*([&#172;;]*)&#174;1/</P><P CLASS="Text1">The StreamEdit code </P><P CLASS="Code">Print -n &#174;1 &quot; =&#8706;n{&quot;</P><P CLASS="Text1">prints the contents of <FONT FACE="courier">&#174;1</FONT>, and follows it with an equal sign, a newline, and an opening brace for the second line of the inline declaration.</P><P CLASS="Text1">Since the output will contain hex constants--which must be separated by commas--the final lines of the script use the <FONT FACE="courier">PrecedingComma</FONT> variable. The <FONT FACE="courier">PrecedingComma</FONT> variable is set initially to empty, so there will be no comma before the first object code. After <FONT FACE="courier">ENDP</FONT> is found the script prints a closing brace and a newline.</P><P CLASS="Code">Set PrecedingComma &quot;&quot; 	<BR>Delete<BR>/[ &#8706;t]ENDP/<BR>Print &quot;};&#8706;n&quot;<BR>Delete</P><P CLASS="Text1">So far, the script produces the following part of the inline declaration:</P><P CLASS="Code">void pascal_string_copy(char* src, char* dest) = <BR>{ };</P><P CLASS="Text1">The next section, <FONT FACE="courier">&quot;Delete unnecessary lines&#133;&quot;</FONT>, deletes unnecessary information from the listing file. Anything not containing object codes is deleted first; acceptable lines contain a hexadecimal constant starting in the first column, several spaces optionally followed by &quot;G&quot;, and then at least one 2-byte constant.</P><P CLASS="Code"># Delete unnecessary lines, text before hex constant<BR> !/&#149;[0-9a-f]+ [g] [0-9a-f]&#171;4&#187;/ Delete<BR> 1,$ Replace /[0-9a-f]+ [g] / &quot;&quot;</P><P CLASS="Text1">The section, <FONT FACE="courier">&quot;Print hex constant&#133;&quot;</FONT> prints the first hexadecimal constant found at the beginning of a line, preceded by <FONT FACE="courier">0x</FONT> and followed by a comma. At this point the <FONT FACE="courier">PrecedingComma</FONT> variable gets set to comma-space and printed along with the hexadecimal constant. The hexadecimal constant is then replaced with a null string, which effectively deletes it. </P><P CLASS="Code"># Print hex constant, preceded by standard 0x<BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1 /<BR> Print -n PrecedingComma &quot;0x&quot;&#174;1<BR> Set PrecedingComma &quot;, &quot;<BR> Replace // &quot;&quot;</P><P CLASS="Text1">Since the last hexadecimal constant was deleted, another can become a match and be extracted from the assembly-language listing.</P><P CLASS="Text1">The last sections, <FONT FACE="courier">&quot;Convert remaining&#133;&quot;</FONT>, are exact duplicates of the preceding section. They continue to delete unnecessary lines and text before the opcodes and then print them. StreamEdit has no control structures for looping so the code is repeated for up to four additional words on a line--the maximum number produced by the current assembler. </P><P CLASS="Code"># Convert remaining words on line<BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1/<BR> Print -n &quot;, 0x&quot;&#174;1<BR> Replace // &quot; &quot;<BR> <BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1/<BR> Print -n &quot;, 0x&quot;&#174;1<BR> Replace // &quot; &quot;<BR> <BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1/<BR> Print -n &quot;, 0x&quot;&#174;1<BR> Replace // &quot; &quot;<BR> <BR> /&#149;([0-9a-f]&#171;4&#187;)&#174;1/<BR> Print -n &quot;, 0x&quot;&#174;1<BR> Replace // &quot; &quot;</P><P CLASS="SectionHd">LIMITATIONS</P><P CLASS="Text1">Lines of more than 1000 characters are split without warning.</P><P CLASS="Text1">There is no easy way to do a <FONT FACE="courier">Replace</FONT> operation on a variable, since variables are used for pattern matches rather than addresses. (See the <FONT FACE="courier"><A HREF="#Replace">Replace</A></FONT> command.)</P><P CLASS="Text1">The StreamEdit tool does not allow true expressions, so arithmetic expressions are impossible. </P><P CLASS="Text1">Conditionals and other control structures are not supported.</P><P CLASS="Text1">&nbsp;<BR>&nbsp;</P><HR WIDTH="600" ALIGN="LEFT"><TABLE WIDTH="600" BORDER="0" CELLSPACING="0" CELLPADDING="0">	<TR>		<TD WIDTH="200"><P CLASS="FooterLink"><A HREF="stackwindows.html">Previous</A></P></TD>		<TD WIDTH="200"><P CLASS="FooterLink"><A HREF="index.html">Table of Contents</A></P></TD>		<TD WIDTH="200"><P CLASS="FooterLink"><A HREF="target.html">Next</A></P></TD>	</TR></TABLE><TABLE WIDTH="600" BORDER="0" CELLSPACING="0" CELLPADDING="0">	<TR>		<TD WIDTH="600">		<P CLASS="Copyright">Copyright Apple Computer, Inc. 1993-2000</P>		<P CLASS="Date">Last Updated July 2000</P>		</TD>	</TR></TABLE></TD></TR></TABLE><!--#include virtual="/footer" --></BODY></HTML>