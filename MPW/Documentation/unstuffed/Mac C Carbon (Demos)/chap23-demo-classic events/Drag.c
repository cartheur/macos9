// *******************************************************************************************// Drag.c// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include "Drag.h"// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesControlActionUPP				gScrollActionFunctionUPP;TEClickLoopUPP					gCustomClickLoopUPP;DragTrackingHandlerUPP	gDragTrackingHandlerUPP;DragReceiveHandlerUPP		gDragReceiveHandlerUPP;Boolean									gRunningOnX = false;Boolean									gDone;RgnHandle								gCursorRegion;SInt16									gNumberOfWindows				= 0;SInt16 									gOldControlValue;Boolean									gEnableDragUndoRedoItem	= false;Boolean									gUndoFlag;// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииии create universal procedure pointers	gScrollActionFunctionUPP = NewControlActionUPP((ControlActionProcPtr) scrollActionFunction);	gCustomClickLoopUPP      = NewTEClickLoopUPP((TEClickLoopProcPtr) customClickLoop);	gDragTrackingHandlerUPP  = NewDragTrackingHandlerUPP((DragTrackingHandlerProcPtr)																											 dragTrackingHandler);	gDragReceiveHandlerUPP   = NewDragReceiveHandlerUPP((DragReceiveHandlerProcPtr)																											dragReceiveHandler);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		doErrorAlert(eMenuBar);	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);		}		gRunningOnX = true;	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open an untitled window	doNewDocWindow();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop	eventLoop();}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(192);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************* eventLoopvoid  eventLoop(void){	EventRecord	eventStructure;	Boolean			gotEvent;	SInt32			sleepTime;	gDone = false;	gCursorRegion = NewRgn();	doAdjustCursor(FrontWindow());	sleepTime = GetCaretTime();	while(!gDone)	{		gotEvent = WaitNextEvent(everyEvent,&eventStructure,sleepTime,gCursorRegion);		if(gotEvent)			doEvents(&eventStructure);		else		{			if(eventStructure.what == nullEvent)				if(gNumberOfWindows > 0)					doIdle();		}	}}// ************************************************************************************ doIdlevoid  doIdle(void){	docStructurePointer	docStrucPtr;	WindowRef						windowRef;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	if(docStrucPtr != NULL)		TEIdle(docStrucPtr->textEditStrucHdl);}	// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	WindowRef				windowRef;	WindowPartCode	partCode;	SInt8						charCode;	switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case mouseDown:			partCode = FindWindow(eventStrucPtr->where,&windowRef);			switch(partCode)			{				case inMenuBar:					doAdjustMenus();					doMenuChoice(MenuSelect(eventStrucPtr->where));					break;				case inContent:					if(windowRef != FrontWindow())						SelectWindow(windowRef);					else						doInContent(eventStrucPtr);					break;				case inDrag:					DragWindow(windowRef,eventStrucPtr->where,NULL);					doAdjustCursor(windowRef);					break;				case inGoAway:					if(TrackGoAway(windowRef,eventStrucPtr->where))						doCloseWindow(FrontWindow());					break;			}			break;		case keyDown:			charCode = eventStrucPtr->message & charCodeMask;			if((eventStrucPtr->modifiers & cmdKey) != 0)			{				doAdjustMenus();				doMenuChoice(MenuEvent(eventStrucPtr));			}			else				doKeyEvent(charCode);			break;		case autoKey:			charCode = eventStrucPtr->message & charCodeMask;			if((eventStrucPtr->modifiers & cmdKey) == 0)				doKeyEvent(charCode);			break;		case updateEvt:			doUpdate(eventStrucPtr);			break;		case activateEvt:			doActivate(eventStrucPtr);			break;		case osEvt:			doOSEvent(eventStrucPtr);			break;	}}// ******************************************************************************** doKeyEventvoid  doKeyEvent(SInt8 charCode){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt16							selectionLength;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	gEnableDragUndoRedoItem = false;	if(charCode == kTab)	{		// Do tab key handling here if required.	}	else if(charCode == kDel)	{		selectionLength = doGetSelectLength(textEditStrucHdl);		if(selectionLength == 0)			(*textEditStrucHdl)->selEnd += 1;		TEDelete(textEditStrucHdl);		doAdjustScrollbar(windowRef);	}	else	{		selectionLength = doGetSelectLength(textEditStrucHdl);		if(((*textEditStrucHdl)->teLength - selectionLength + 1) < kMaxTELength)		{			TEKey(charCode,textEditStrucHdl);			doAdjustScrollbar(windowRef);		}		else			doErrorAlert(eExceedChara);	}}// ********************************************************************** scrollActionFunctionvoid  scrollActionFunction(ControlRef controlRef,SInt16 partCode){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt16							linesToScroll;	SInt16							controlValue, controlMax;	windowRef = GetControlOwner(controlRef);	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));;	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	controlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	if(partCode)	{		if(partCode != kControlIndicatorPart)		{			switch(partCode)			{				case kControlUpButtonPart:				case kControlDownButtonPart:					linesToScroll = 1;					break;								case kControlPageUpPart:				case kControlPageDownPart:					linesToScroll = (((*textEditStrucHdl)->viewRect.bottom - 													(*textEditStrucHdl)->viewRect.top) /													(*textEditStrucHdl)->lineHeight) - 1;					break;			}			if((partCode == kControlDownButtonPart) || (partCode == kControlPageDownPart))				linesToScroll = -linesToScroll;			linesToScroll = controlValue - linesToScroll;			if(linesToScroll < 0)				linesToScroll = 0;			else if(linesToScroll > controlMax)				linesToScroll = controlMax;			SetControlValue(controlRef,linesToScroll);			linesToScroll = controlValue - linesToScroll;		}		else		{			linesToScroll = gOldControlValue - controlValue;			gOldControlValue = controlValue;		}		if(linesToScroll != 0)			TEScroll(0,linesToScroll * (*textEditStrucHdl)->lineHeight,textEditStrucHdl);	}}// ******************************************************************************* doInContentvoid  doInContent(EventRecord *eventStrucPtr){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	Point								mouseXY;	ControlRef					controlRef;	SInt16							partCode;	RgnHandle						hiliteRgn;	OSErr								osError;	Boolean							shiftKeyPosition = false;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) GetWRefCon(windowRef);	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	mouseXY = eventStrucPtr->where;	SetPortWindowPort(windowRef);	GlobalToLocal(&mouseXY);	if((partCode = FindControl(mouseXY,windowRef,&controlRef)) != 0)	{		gOldControlValue = GetControlValue(controlRef);		TrackControl(controlRef,mouseXY,gScrollActionFunctionUPP);	}	else if(PtInRect(mouseXY,&(*textEditStrucHdl)->viewRect))	{		hiliteRgn = NewRgn();		TEGetHiliteRgn(hiliteRgn,textEditStrucHdl);		if(!EmptyRgn(hiliteRgn) && PtInRgn(mouseXY,hiliteRgn))		{			if(WaitMouseMoved(eventStrucPtr->where))			{				osError = doStartDrag(eventStrucPtr,hiliteRgn,textEditStrucHdl);				if(osError != noErr)					doErrorAlert(eDrag);			}			}		else		{			if((eventStrucPtr->modifiers & shiftKey) != 0)				shiftKeyPosition = true;			TEClick(mouseXY,shiftKeyPosition,textEditStrucHdl);			gEnableDragUndoRedoItem = false;					doAdjustCursor(windowRef);		}		DisposeRgn(hiliteRgn);	}}// ********************************************************************************** doUpdatevoid	doUpdate(EventRecord *eventStrucPtr){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	GrafPtr							oldPort;	RgnHandle						visibleRegionHdl = NewRgn();	Rect								portRect;	windowRef = (WindowRef) eventStrucPtr->message;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;		GetPort(&oldPort);	SetPortWindowPort(windowRef);	BeginUpdate((WindowRef) eventStrucPtr->message);	GetPortVisibleRegion(GetWindowPort(windowRef),visibleRegionHdl);  EraseRgn(visibleRegionHdl);	UpdateControls(windowRef,visibleRegionHdl);	GetWindowPortBounds(windowRef,&portRect);	TEUpdate(&(*textEditStrucHdl)->viewRect,textEditStrucHdl);	EndUpdate((WindowRef) eventStrucPtr->message);	DisposeRgn(visibleRegionHdl);	SetPort(oldPort);}// ******************************************************************************** doActivatevoid  doActivate(EventRecord *eventStrucPtr){	WindowRef	windowRef;	Boolean		becomingActive;	windowRef = (WindowRef) eventStrucPtr->message;	becomingActive = ((eventStrucPtr->modifiers & activeFlag) == activeFlag);	doActivateDocWindow(windowRef,becomingActive);}// *********************************************************************** doActivateDocWindowvoid  doActivateDocWindow(WindowRef windowRef,Boolean becomingActive){	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	if(becomingActive)	{		SetPortWindowPort(windowRef);		(*textEditStrucHdl)->viewRect.bottom = ((((*textEditStrucHdl)->viewRect.bottom -																						(*textEditStrucHdl)->viewRect.top) / 																						(*textEditStrucHdl)->lineHeight) * 																						(*textEditStrucHdl)->lineHeight) + 																						(*textEditStrucHdl)->viewRect.top;		(*textEditStrucHdl)->destRect.bottom = (*textEditStrucHdl)->viewRect.bottom;		TEActivate(textEditStrucHdl);		ActivateControl(docStrucPtr->vScrollbarRef);		doAdjustScrollbar(windowRef);		doAdjustCursor(windowRef);	}	else	{		TEDeactivate(textEditStrucHdl);		DeactivateControl(docStrucPtr->vScrollbarRef);	}}// ********************************************************************************* doOSEventvoid	doOSEvent(EventRecord *eventStrucPtr){	switch((eventStrucPtr->message >> 24) & 0x000000FF)	{		case suspendResumeMessage:			if((eventStrucPtr->message & resumeFlag) == 1)				SetThemeCursor(kThemeArrowCursor);			break;		case mouseMovedMessage:			doAdjustCursor(FrontWindow());			break;	}}// **************************************************************************** doNewDocWindowWindowRef  doNewDocWindow(void){	WindowRef 					windowRef;	docStructurePointer	docStrucPtr;	Rect								portRect, destAndViewRect;	OSErr								osError;	if(!(windowRef = GetNewCWindow(rWindow,NULL,(WindowRef) -1)))	{		doErrorAlert(eWindow);		return NULL;	}	SetPortWindowPort(windowRef);	TextSize(10);	if(!(docStrucPtr = (docStructurePointer) NewPtr(sizeof(docStructure))))	{		doErrorAlert(eDocStructure);		return NULL;	}	SetWRefCon(windowRef,(SInt32) docStrucPtr);	SetWindowProxyCreatorAndType(windowRef,0,'TEXT',kUserDomain);	gNumberOfWindows ++;	docStrucPtr->windowRef     = windowRef;	docStrucPtr->windowTouched = false;	docStrucPtr->preDragText   = NULL;	docStrucPtr->vScrollbarRef = GetNewControl(rVScrollbar,windowRef);	GetWindowPortBounds(windowRef,&portRect);	destAndViewRect = portRect;	destAndViewRect.right -= 15;	InsetRect(&destAndViewRect,2,2);	if(!(docStrucPtr->textEditStrucHdl = TENew(&destAndViewRect,&destAndViewRect)))	{		DisposeWindow(windowRef);		gNumberOfWindows --;		DisposePtr((Ptr) docStrucPtr);		doErrorAlert(eTextEdit);		return NULL;	}	TESetClickLoop(gCustomClickLoopUPP,docStrucPtr->textEditStrucHdl);	TEAutoView(true,docStrucPtr->textEditStrucHdl);	TEFeatureFlag(teFOutlineHilite,teBitSet,docStrucPtr->textEditStrucHdl);	if(osError = InstallTrackingHandler(gDragTrackingHandlerUPP,windowRef,docStrucPtr))	{		DisposeWindow(windowRef);		gNumberOfWindows --;		DisposePtr((Ptr) docStrucPtr);		doErrorAlert(eDragHandler);		return NULL;	}	if(osError = InstallReceiveHandler(gDragReceiveHandlerUPP,windowRef,docStrucPtr))	{		RemoveTrackingHandler(gDragTrackingHandlerUPP,windowRef);		DisposeWindow(windowRef);		gNumberOfWindows --;		DisposePtr((Ptr) docStrucPtr);		doErrorAlert(eDragHandler);		return NULL;	}	return windowRef;}// *************************************************************************** customClickLoopBoolean  customClickLoop(void){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	GrafPtr							oldPort;	RgnHandle						oldClip;	Rect								tempRect, portRect;	Point								mouseXY;	SInt16							linesToScroll = 0;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	oldClip = NewRgn();	GetClip(oldClip);	SetRect(&tempRect,-32767,-32767,32767,32767);	ClipRect(&tempRect);	GetMouse(&mouseXY);	GetWindowPortBounds(windowRef,&portRect);	if(mouseXY.v < portRect.top)	{		linesToScroll = 1;		doSetScrollBarValue(docStrucPtr->vScrollbarRef,&linesToScroll);		if(linesToScroll != 0)			TEScroll(0,linesToScroll * ((*textEditStrucHdl)->lineHeight),textEditStrucHdl);	}	else if(mouseXY.v > portRect.bottom)	{		linesToScroll = -1;		doSetScrollBarValue(docStrucPtr->vScrollbarRef,&linesToScroll);		if(linesToScroll != 0)			TEScroll(0,linesToScroll * ((*textEditStrucHdl)->lineHeight),textEditStrucHdl);	}	SetClip(oldClip);	DisposeRgn(oldClip);	SetPort(oldPort);	return true;}// *********************************************************************** doSetScrollBarValuevoid  doSetScrollBarValue(ControlRef controlRef,SInt16 *linesToScroll){	SInt16	controlValue, controlMax;	controlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	*linesToScroll = controlValue - *linesToScroll;	if(*linesToScroll < 0)		*linesToScroll = 0;	else if(*linesToScroll > controlMax)		*linesToScroll = controlMax;	SetControlValue(controlRef,*linesToScroll);	*linesToScroll = controlValue - *linesToScroll;}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef							fileMenuRef, editMenuRef;	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	ScrapRef						scrapRef;	OSStatus						osError;	ScrapFlavorFlags		scrapFlavorFlags;	fileMenuRef = GetMenuRef(mFile);	editMenuRef = GetMenuRef(mEdit);	if(gNumberOfWindows > 0)	{		windowRef = FrontWindow();		docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));;		textEditStrucHdl = docStrucPtr->textEditStrucHdl;		EnableMenuItem(fileMenuRef,iClose);		if(gEnableDragUndoRedoItem)		{			EnableMenuItem(editMenuRef,iUndo);			if(gUndoFlag)				SetMenuItemText(editMenuRef,iUndo,"\pUndo Drag & Drop");			else				SetMenuItemText(editMenuRef,iUndo,"\pRedo Drag & Drop");		}		else		{			DisableMenuItem(editMenuRef,iUndo);			SetMenuItemText(editMenuRef,iUndo,"\pRedo Drag & Drop");		}		if((*textEditStrucHdl)->selStart < (*textEditStrucHdl)->selEnd)		{			EnableMenuItem(editMenuRef,iCut);			EnableMenuItem(editMenuRef,iCopy);			EnableMenuItem(editMenuRef,iClear);		}		else		{			DisableMenuItem(editMenuRef,iCut);			DisableMenuItem(editMenuRef,iCopy);			DisableMenuItem(editMenuRef,iClear);		}		GetCurrentScrap(&scrapRef);		osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&scrapFlavorFlags);		if(osError == noErr)			EnableMenuItem(editMenuRef,iPaste);		else			DisableMenuItem(editMenuRef,iPaste);		if((*textEditStrucHdl)->teLength > 0)		{			EnableMenuItem(fileMenuRef,iSaveAs);			EnableMenuItem(editMenuRef,iSelectAll);		}		else		{			DisableMenuItem(fileMenuRef,iSaveAs);			DisableMenuItem(editMenuRef,iSelectAll);		}	}	else	{		DisableMenuItem(fileMenuRef,iClose);		DisableMenuItem(fileMenuRef,iSaveAs);		DisableMenuItem(editMenuRef,iClear);		DisableMenuItem(editMenuRef,iSelectAll);	}	DrawMenuBar();}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;	menuID	 = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;		case mFile:			doFileMenu(menuItem);			break;		case mEdit:			doEditMenu(menuItem);			break;	}	HiliteMenu(0);}// ******************************************************************************** doFileMenuvoid	doFileMenu(MenuItemIndex menuItem){	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	switch(menuItem)	{		case iNew:			doNewDocWindow();			break;		case iOpen:			doOpenCommand();			break;		case iClose:			doCloseWindow(FrontWindow());			break;		case iSaveAs:			docStrucPtr = (docStructurePointer) (GetWRefCon(FrontWindow()));			textEditStrucHdl = docStrucPtr->textEditStrucHdl;			doSaveAsFile(textEditStrucHdl);			break;		case iQuit:			gDone = true;			break;	}}// ******************************************************************************** doEditMenuvoid	doEditMenu(MenuItemIndex menuItem){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt32							totalSize, contigSize, newSize;	SInt16							selectionLength;	ScrapRef						scrapRef;	Size								sizeOfTextData;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	switch(menuItem)	{		case iUndo:			doUndoRedoDrag(windowRef);			break;		case iCut:			if(ClearCurrentScrap() == noErr)			{				PurgeSpace(&totalSize,&contigSize);				selectionLength = doGetSelectLength(textEditStrucHdl);				if(selectionLength > contigSize)					doErrorAlert(eNoSpaceCut);				else				{					TECut(textEditStrucHdl);					doAdjustScrollbar(windowRef);					if(TEToScrap() != noErr)						ClearCurrentScrap();				}			}			break;		case iCopy:			if(ClearCurrentScrap() == noErr)			{				TECopy(textEditStrucHdl);				if(TEToScrap() != noErr)					ClearCurrentScrap();			}			break;		case iPaste:			GetCurrentScrap(&scrapRef);;			GetScrapFlavorSize(scrapRef,kScrapFlavorTypeText,&sizeOfTextData);			newSize = (*textEditStrucHdl)->teLength + sizeOfTextData;			if(newSize > kMaxTELength)				doErrorAlert(eNoSpacePaste);			else			{				if(TEFromScrap() == noErr)				{					TEPaste(textEditStrucHdl);					doAdjustScrollbar(windowRef);				}			}			break;		case iClear:			TEDelete(textEditStrucHdl);			doAdjustScrollbar(windowRef);			break;		case iSelectAll:			TESetSelect(0,(*textEditStrucHdl)->teLength,textEditStrucHdl);			break;	}}// ************************************************************************* doGetSelectLengthSInt16  doGetSelectLength(TEHandle textEditStrucHdl){	SInt16	selectionLength;	selectionLength = (*textEditStrucHdl)->selEnd - (*textEditStrucHdl)->selStart;	return selectionLength;}// ************************************************************************* doAdjustScrollbarvoid  doAdjustScrollbar(WindowRef windowRef){	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt16							numberOfLines, controlMax, controlValue;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));;	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	numberOfLines = (*textEditStrucHdl)->nLines;	if(*(*(*textEditStrucHdl)->hText + (*textEditStrucHdl)->teLength - 1) == kReturn)		numberOfLines += 1;	controlMax = numberOfLines - (((*textEditStrucHdl)->viewRect.bottom - 							 (*textEditStrucHdl)->viewRect.top) /							 (*textEditStrucHdl)->lineHeight);	if(controlMax < 0)		controlMax = 0;	SetControlMaximum(docStrucPtr->vScrollbarRef,controlMax);	controlValue = ((*textEditStrucHdl)->viewRect.top - (*textEditStrucHdl)->destRect.top) / 									(*textEditStrucHdl)->lineHeight;	if(controlValue < 0)		controlValue = 0;	else if(controlValue > controlMax)		controlValue = controlMax;	SetControlValue(docStrucPtr->vScrollbarRef,controlValue);	SetControlViewSize(docStrucPtr->vScrollbarRef,(*textEditStrucHdl)->viewRect.bottom - 										 (*textEditStrucHdl)->viewRect.top);	TEScroll(0,((*textEditStrucHdl)->viewRect.top - (*textEditStrucHdl)->destRect.top) - 					 		(GetControlValue(docStrucPtr->vScrollbarRef) *							(*textEditStrucHdl)->lineHeight),textEditStrucHdl);}// **************************************************************************** doAdjustCursorvoid  doAdjustCursor(WindowRef windowRef){	GrafPtr							oldPort;	RgnHandle						arrowRegion, iBeamRegion, hiliteRgn;	Rect								portRect, cursorRect;	docStructurePointer	docStrucPtr;	Point								offset, mouseXY;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	arrowRegion = NewRgn();	iBeamRegion = NewRgn();	hiliteRgn		= NewRgn();		SetRectRgn(arrowRegion,-32768,-32768,32766,32766);	GetWindowPortBounds(windowRef,&portRect);	cursorRect = portRect;	cursorRect.right	-= 15;	LocalToGlobal(&topLeft(cursorRect));	LocalToGlobal(&botRight(cursorRect));		RectRgn(iBeamRegion,&cursorRect);	DiffRgn(arrowRegion,iBeamRegion,arrowRegion);	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	TEGetHiliteRgn(hiliteRgn,docStrucPtr->textEditStrucHdl);	LocalToGlobal(&topLeft(portRect));		offset = topLeft(portRect);	OffsetRgn(hiliteRgn,offset.h,offset.v);	DiffRgn(iBeamRegion,hiliteRgn,iBeamRegion);	GetGlobalMouse(&mouseXY);	if(PtInRgn(mouseXY,iBeamRegion))	{		SetThemeCursor(kThemeIBeamCursor);		CopyRgn(iBeamRegion,gCursorRegion);	}	else if(PtInRgn(mouseXY,hiliteRgn))	{		SetThemeCursor(kThemeArrowCursor);		CopyRgn(hiliteRgn,gCursorRegion);	}	else	{		SetThemeCursor(kThemeArrowCursor);		CopyRgn(arrowRegion,gCursorRegion);	}	DisposeRgn(arrowRegion);	DisposeRgn(iBeamRegion);	DisposeRgn(hiliteRgn);	SetPort(oldPort);}// ***************************************************************************** doCloseWindowvoid  doCloseWindow(WindowRef windowRef){	docStructurePointer	docStrucPtr;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));;	DisposeControl(docStrucPtr->vScrollbarRef);	TEDispose(docStrucPtr->textEditStrucHdl);	DisposePtr((Ptr) docStrucPtr);	if(docStrucPtr->preDragText == NULL)		DisposeHandle(docStrucPtr->preDragText);	RemoveTrackingHandler(gDragTrackingHandlerUPP,windowRef);	RemoveReceiveHandler(gDragReceiveHandlerUPP,windowRef);	DisposeWindow(windowRef);	gNumberOfWindows --;}// ****************************************************************************** doSaveAsFilevoid  doSaveAsFile(TEHandle textEditStrucHdl){	OSErr							osError = noErr;	NavDialogOptions	dialogOptions;	WindowRef					windowRef;	NavEventUPP				navEventFunctionUPP;	OSType						fileType;	NavReplyRecord		navReplyStruc;	AEKeyword					theKeyword;	DescType					actualType;	FSSpec						fileSpec;		SInt16						fileRefNum;	Size							actualSize;	SInt32						dataLength;	Handle						editTextHdl;			osError = NavGetDefaultDialogOptions(&dialogOptions);	if(osError == noErr)	{		windowRef = FrontWindow();		fileType = 'TEXT';		navEventFunctionUPP = NewNavEventUPP((NavEventProcPtr) navEventFunction);		osError = NavPutFile(NULL,&navReplyStruc,&dialogOptions,navEventFunctionUPP,fileType,												 'kkkB',NULL);		DisposeNavEventUPP(navEventFunctionUPP);		if(navReplyStruc.validRecord && osError == noErr)		{			if((osError = AEGetNthPtr(&(navReplyStruc.selection),1,typeFSS,&theKeyword,																&actualType,&fileSpec,sizeof(fileSpec),&actualSize)) == noErr)			{				if(!navReplyStruc.replacing)				{					osError = FSpCreate(&fileSpec,'kkkB',fileType,navReplyStruc.keyScript);					if(osError != noErr)					{						NavDisposeReply(&navReplyStruc);					}				}								if(osError == noErr)					osError = FSpOpenDF(&fileSpec,fsRdWrPerm,&fileRefNum);				if(osError == noErr)				{					SetWTitle(windowRef,fileSpec.name);					dataLength = (*textEditStrucHdl)->teLength;					editTextHdl = (*textEditStrucHdl)->hText;					FSWrite(fileRefNum,&dataLength,*editTextHdl);				}				NavCompleteSave(&navReplyStruc,kNavTranslateInPlace);			}			NavDisposeReply(&navReplyStruc);		}	}}// ***************************************************************************** doOpenCommandvoid  doOpenCommand(void){		OSErr							osError	= noErr;	NavDialogOptions	dialogOptions;	NavEventUPP				navEventFunctionUPP;	NavReplyRecord		navReplyStruc;	SInt32						index, count;	AEKeyword					theKeyword;	DescType					actualType;	FSSpec						fileSpec;		Size							actualSize;	FInfo							fileInfo;	osError = NavGetDefaultDialogOptions(&dialogOptions);	if(osError == noErr)	{		navEventFunctionUPP = NewNavEventUPP((NavEventProcPtr) navEventFunction);		osError = NavGetFile(NULL,&navReplyStruc,&dialogOptions,navEventFunctionUPP,NULL,NULL,												 NULL,0);		DisposeNavEventUPP(navEventFunctionUPP);		if(osError == noErr && navReplyStruc.validRecord)		{			if(osError == noErr)			{				osError = AECountItems(&(navReplyStruc.selection),&count);				for(index=1;index<=count;index++)				{					osError = AEGetNthPtr(&(navReplyStruc.selection),index,typeFSS,&theKeyword,																&actualType,&fileSpec,sizeof(fileSpec),&actualSize);					{						if((osError = FSpGetFInfo(&fileSpec,&fileInfo)) == noErr)							doOpenFile(fileSpec);					}				}			}			NavDisposeReply(&navReplyStruc);			}	}}// ************************************************************************** navEventFunctionvoid  navEventFunction(NavEventCallbackMessage callBackSelector,NavCBRecPtr callBackParms,											 NavCallBackUserData callBackUD){	WindowRef	windowRef;	if(callBackParms != NULL)	{		switch(callBackSelector)		{			case kNavCBEvent:				switch(callBackParms->eventData.eventDataParms.event->what)				{					case updateEvt:						windowRef = (WindowRef) callBackParms->eventData.eventDataParms.event->message;						if(GetWindowKind(windowRef) != kDialogWindowKind)							doUpdate((EventRecord *) callBackParms->eventData.eventDataParms.event);						break;				}				break;		}	}}// ******************************************************************************** doOpenFilevoid  doOpenFile(FSSpec fileSpec){	WindowRef 					windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt16							fileRefNum;	SInt32							textLength;	Handle							textBuffer;	if((windowRef = doNewDocWindow()) == NULL)		return;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	SetWTitle(windowRef,fileSpec.name);	FSpOpenDF(&fileSpec,fsCurPerm,&fileRefNum);	SetFPos(fileRefNum,fsFromStart,0);	GetEOF(fileRefNum,&textLength);	if(textLength > 32767)		textLength = 32767;	textBuffer = NewHandle((Size) textLength);	FSRead(fileRefNum,&textLength,*textBuffer);	MoveHHi(textBuffer);	HLock(textBuffer);	TESetText(*textBuffer,textLength,textEditStrucHdl);	HUnlock(textBuffer);	DisposeHandle(textBuffer);	FSClose(fileRefNum);	(*textEditStrucHdl)->selStart = 0;	(*textEditStrucHdl)->selEnd = 0;}// ****************************************************************************** doErrorAlertvoid  doErrorAlert(SInt16 errorCode){	Str255	errorString;	SInt16	itemHit;	GetIndString(errorString,rErrorStrings,errorCode);	if(errorCode < eWindow)	{		StandardAlert(kAlertStopAlert,errorString,NULL,NULL,&itemHit);		ExitToShell();	}	else	{		StandardAlert(kAlertCautionAlert,errorString,NULL,NULL,&itemHit);	}}// *******************************************************************************************