// *******************************************************************************************// ReceiveAndUndoDrag.c// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include "Drag.h"// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesextern Boolean	gEnableDragUndoRedoItem;extern Boolean	gUndoFlag;extern Boolean	gCanAcceptItems;extern SInt16		gInsertPosition, gCaretOffset;// ************************************************************************ dragReceiveHandlerOSErr  dragReceiveHandler(WindowRef windowRef,void *handlerRefCon,DragRef dragRef){	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt32							totalTextStart;	Size								totalTextSize;	Boolean							wasActive, moveText, gotUndoMemory = false;	DragAttributes			dragAttributes;	SInt16							mouseDownModifiers, mouseUpModifiers, selStart, selEnd;	UInt16							numberOfDragItems, index;	ItemReference				itemReference;	OSErr								osError;	Size								textSize;	Ptr									textDataPtr;	SInt32							additionalChars;	if((!gCanAcceptItems) || (gInsertPosition == -1))		return dragNotAcceptedErr;	docStrucPtr = (docStructurePointer) handlerRefCon;			textEditStrucHdl = docStrucPtr->textEditStrucHdl;	// и set graphics port to this window's port and, if necessary, activate text edit structure	SetPortWindowPort(windowRef);	wasActive = (*textEditStrucHdl)->active != 0;	if(!wasActive)		TEActivate(textEditStrucHdl);	// ииииииииииииииииииииииииииииииииииииииииииииии get drag attributes and keyboard modifiers	GetDragAttributes(dragRef,&dragAttributes);	GetDragModifiers(dragRef,0L,&mouseDownModifiers,&mouseUpModifiers);	// и и иййin case their are multiple items, save first insertion point for later TESetSelect	totalTextStart = gInsertPosition;	totalTextSize = 0;	// и и for all items in drag, get 'TEXT' data, insert into this window's text edit structure	CountDragItems(dragRef,&numberOfDragItems);	for(index=1;index <= numberOfDragItems;index++)	{		GetDragItemReferenceNumber(dragRef,index,&itemReference);		osError = GetFlavorDataSize(dragRef,itemReference,'TEXT',&textSize);		if(osError == noErr)		{			// и  if addition of drag to the text edit structure would exceed TextEdit limit, return			if(((*textEditStrucHdl)->teLength + textSize) > kMaxTELength)				return dragNotAcceptedErr;			// ийийи ийийийийийийийийийийcreate nonrelocatable block and get the 'TEXT' data into it			textDataPtr = NewPtr(textSize);			if(textDataPtr == NULL)				return dragNotAcceptedErr;			GetFlavorData(dragRef,itemReference,'TEXT',textDataPtr,&textSize,0);			// ийийийийийийийийийийийийийийийийийий if caret or highlighting is on screen, remove it			if(gCaretOffset != -1)			{				doDrawCaret(gCaretOffset,textEditStrucHdl);				gCaretOffset = -1;			}			if(dragAttributes & kDragHasLeftSenderWindow)				HideDragHilite(dragRef);      // save current text and selection start/end for Undo, and set Redo/Undo menu item flags			if(dragAttributes & kDragInsideSenderWindow)			{				gotUndoMemory = doSavePreInsertionText(docStrucPtr);				if(gotUndoMemory)				{					gEnableDragUndoRedoItem = true;					gUndoFlag = true;				}			}			else				gEnableDragUndoRedoItem = false;			// ийийийийи if in sender window, ensure selected text is deleted if option key not down			moveText = (dragAttributes & kDragInsideSenderWindow) &&								 (!((mouseDownModifiers & optionKey) | (mouseUpModifiers & optionKey)));			if(moveText)			{				selStart = (*textEditStrucHdl)->selStart;				selEnd   = (*textEditStrucHdl)->selEnd;				// ийийийийи йextend selection by one chara if space charas just before and just after				if(doIsWhiteSpaceAtOffset(selStart - 1,textEditStrucHdl) &&					!doIsWhiteSpaceAtOffset(selStart,textEditStrucHdl) &&					!doIsWhiteSpaceAtOffset(selEnd - 1,textEditStrucHdl) &&					 doIsWhiteSpaceAtOffset(selEnd,textEditStrucHdl))				{					if(doGetCharAtOffset(selEnd,textEditStrucHdl) == ' ')						(*textEditStrucHdl)->selEnd++;				}				//йif insertion is after selected text, move insertion point back by size of selection								if(gInsertPosition > selStart)				{					selEnd = (*textEditStrucHdl)->selEnd;					gInsertPosition -= (selEnd - selStart);					totalTextStart -= (selEnd - selStart);				}				// ийийийи  ийийийийийийийийийийийийийийийийийийийийийи ийи ийийийdelete the selection								TEDelete(textEditStrucHdl);				}			// ийийийийийийийийийийийийийийийийийийи ийinsert the 'TEXT' data at the insertion point			additionalChars = doInsertTextAtOffset(gInsertPosition,textDataPtr,textSize,																						 textEditStrucHdl);			// ийийийийи if inserting multiple blocks of text, update insertion point for next block			gInsertPosition += textSize + additionalChars;			totalTextSize += textSize + additionalChars;			// ийийийийийийийийийийийийийийийийийийийийийи ийийийийийdispose of nonrelocatable block			DisposePtr(textDataPtr);		}	}	// иииииииииииииииииииииииииииииииииииииииии select total inserted text and adjust scrollbar	TESetSelect(totalTextStart,totalTextStart + totalTextSize,textEditStrucHdl);	doAdjustScrollbar(windowRef);	// ииииии set window's "touched" flag, and save post-insert selection start and end for Redo	docStrucPtr->windowTouched = true;	if(dragAttributes & kDragInsideSenderWindow)	{		docStrucPtr->postDropSelStart = totalTextStart;		docStrucPtr->postDropSelEnd = totalTextStart + totalTextSize;	}	// иииииииииииииииииииииии if text edit structure had to be activated earlier, deactivate it	if(!wasActive)		TEDeactivate(textEditStrucHdl);	return noErr;}// ******************************************************************** doIsWhiteSpaceAtOffsetBoolean  doIsWhiteSpaceAtOffset(SInt16 offset,TEHandle textEditStrucHdl){	char theChar;	if((offset < 0) || (offset > (*textEditStrucHdl)->teLength - 1))		return true;	theChar = ((char *) *((*textEditStrucHdl)->hText))[offset];	return (doIsWhiteSpace(theChar));}// **************************************************************************** doIsWhiteSpaceBoolean  doIsWhiteSpace(char theChar){	return ((theChar == ' ') || (theChar == 0x0D));}// ************************************************************************* doGetCharAtOffsetchar  doGetCharAtOffset(SInt16 offset,TEHandle textEditStrucHdl){	if(offset < 0)		return 0x0D;	return (((char *) *((*textEditStrucHdl)->hText))[offset]);}// ********************************************************************** doInsertTextAtOffsetSInt16  doInsertTextAtOffset(SInt16 textOffset,Ptr textDataPtr,SInt32 textSize,														 TEHandle textEditStrucHdl){	SInt16	charactersAdded = 0;	if(textSize == 0)		return charactersAdded;	// ии if inserting at end of word, and selection does not begin with a space, insert a space	if(!doIsWhiteSpaceAtOffset(textOffset - 1,textEditStrucHdl) &&		 	doIsWhiteSpaceAtOffset(textOffset,textEditStrucHdl) &&		 !doIsWhiteSpace(textDataPtr[0]))	{		TESetSelect(textOffset,textOffset,textEditStrucHdl);		TEKey(' ',textEditStrucHdl);		++textOffset;		++charactersAdded;	}	// и if inserting at beginning of word and selection does not end with a space, insert space	if(doIsWhiteSpaceAtOffset(textOffset - 1,textEditStrucHdl) &&		!doIsWhiteSpaceAtOffset(textOffset,textEditStrucHdl) &&		!doIsWhiteSpace(textDataPtr[textSize - 1]))	{		TESetSelect(textOffset,textOffset,textEditStrucHdl);		TEKey(' ',textEditStrucHdl);		++charactersAdded;	}	// иииииииииииииииииииииииииииииииииииииииии before inserting, set selection range to a zero	TESetSelect(textOffset,textOffset,textEditStrucHdl);	TEInsert(textDataPtr,textSize,textEditStrucHdl);	return charactersAdded;}// ******************************************************************** doSavePreInsertionTextBoolean  doSavePreInsertionText(docStructurePointer	docStrucPtr){	OSErr		osError;	Size		tempSize;	Handle	tempTextHdl;	if(docStrucPtr->preDragText == NULL)		docStrucPtr->preDragText = NewHandle(0);	tempTextHdl = (*(docStrucPtr->textEditStrucHdl))->hText;	tempSize = GetHandleSize(tempTextHdl);	SetHandleSize(docStrucPtr->preDragText,tempSize);	osError = MemError();	if(osError != noErr)	{		doErrorAlert(eDragUndo);		return false;	}	BlockMove(*tempTextHdl,*(docStrucPtr->preDragText),tempSize);	docStrucPtr->preDragSelStart = (*((docStrucPtr)->textEditStrucHdl))->selStart;	docStrucPtr->preDragSelEnd   = (*((docStrucPtr)->textEditStrucHdl))->selEnd;	return true;}// **************************************************************************** doUndoRedoDragvoid  doUndoRedoDrag(WindowRef windowRef){	docStructurePointer	docStrucPtr;	Handle							tempTextHdl;	Rect								portRect;		docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	tempTextHdl = (*(docStrucPtr->textEditStrucHdl))->hText;	(*(docStrucPtr->textEditStrucHdl))->hText = docStrucPtr->preDragText;	docStrucPtr->preDragText = tempTextHdl;	if(gUndoFlag)	{		(*((docStrucPtr)->textEditStrucHdl))->selStart = docStrucPtr->preDragSelStart;		(*((docStrucPtr)->textEditStrucHdl))->selEnd = docStrucPtr->preDragSelEnd;	}	else	{		(*((docStrucPtr)->textEditStrucHdl))->selStart = docStrucPtr->postDropSelStart;		(*((docStrucPtr)->textEditStrucHdl))->selEnd = docStrucPtr->postDropSelEnd;	}	gUndoFlag = !gUndoFlag;	TECalText(docStrucPtr->textEditStrucHdl);	GetWindowPortBounds(windowRef,&portRect);	InvalWindowRect(windowRef,&portRect);}// *******************************************************************************************