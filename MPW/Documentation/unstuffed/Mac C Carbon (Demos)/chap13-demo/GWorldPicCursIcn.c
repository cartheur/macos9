// *******************************************************************************************// GWorldPicCursIcon.c                                                     CLASSIC EVENT MODEL// *******************************************************************************************// // This program demonstrates offscreen graphics world, picture, cursor, cursor shape change,// animated cursor, and icon operations as a result of the user choosing items from a // Demonstration menu.  It also demonstrates a modal dialog-based Aboutи box containing a // picture.//// To keep the non-demonstration code to a minimum, the program contains no functions for// updating the window or for responding to activate and operating system events.//// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	An 'MBAR' resource and associated 'MENU' resources (preload, non-purgeable).//// ╔	A 'WIND' resource (purgeable) (initially visible). //// ╔	An 'acur' resource (purgeable).//// ╔	'CURS' resources associated with the 'acur' resource (preload, purgeable).//// ╔	Two 'cicn' resources (purgeable), one for the Icons menu item and one for drawing in the//		window.//// ╔	Two icon family resources (purgeable), both for drawing in the window.//// ╔	A 'DLOG' resource (purgeable) and an associated 'DITL' resource (purgeable) and 'PICT'//		resource for an About GWorldPicCursIconи dialog box.//// ╔	A 'STR#' resource (purgeable) containing transform constants.//// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar									128#define rWindow										128#define mAppleApplication					128#define  iAbout										1#define mFile											129#define  iQuit										12#define mDemonstration						131#define  iOffScreenGWorld1				1#define  iOffScreenGWorld2				2#define  iPicture									3#define  iCursor									4#define  iAnimatedCursor1					5#define  iAnimatedCursor2					6#define  iAnimatedCursorOSX				7#define  iIcon										8#define rBeachBallCursor					128#define rPicture									128#define rTransformStrings					128#define rIconFamily1							128#define rIconFamily2							129#define rColourIcon								128#define rAboutDialog							128#define kSleepTime								1#define kBeachBallTickInterval		5#define kCountingHandTickInterval	30#define MAX_UINT32								0xFFFFFFFF#define topLeft(r)								(((Point *) &(r))[0])#define botRight(r)								(((Point *) &(r))[1])// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии typedefstypedef struct{	SInt16			numberOfFrames;	SInt16			whichFrame;	CursHandle	frame[];} animCurs, *animCursPtr, **animCursHandle;// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean					gRunningOnX = false;WindowRef				gWindowRef;Boolean					gDone;SInt32					gSleepTime;RgnHandle				gCursorRegion;Boolean					gCursorRegionsActive			= false;Boolean					gAnimatedCursor1Active		= false;Boolean					gAnimatedCursor2Active		= false;Boolean					gAnimatedCursorOSXActive	= false;animCursHandle	gAnimCursHdl;SInt16					gAnimCursTickInterval;SInt32					gAnimCursLastTick;RGBColor				gBlackColour	= { 0x0000, 0x0000, 0x0000 };RGBColor				gWhiteColour	= { 0xFFFF, 0xFFFF, 0xFFFF };RGBColor				gBeigeColour	= { 0xF000, 0xE300, 0xC200 };RGBColor				gBlueColour		= { 0x4444, 0x4444, 0x9999 };// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid		main									(void);void		doPreliminaries				(void);OSErr		quitAppEventHandler		(AppleEvent *,AppleEvent *,SInt32);void		eventLoop							(void);void		doIdle								(void);void		doEvents							(EventRecord *);void		doMenuChoice					(SInt32);void		doOffScreenGWorld1		(void);void		doOffScreenGWorld2		(void);void		doPicture							(void);void		doCursor							(void);void		doChangeCursor				(WindowRef,RgnHandle);void		doAnimatedCursor1			(void);void		doAnimatedCursor2			(void);Boolean	doGetAnimCursor				(SInt16,SInt16);void		doIncrementAnimCursor	(void);void		doReleaseAnimCursor		(void);void		doAnimatedCursorOSX		(void);void		doIcon								(void);void		doAboutDialog					(void);void		doDrawStuff						(void);UInt16	doRandomNumber				(UInt16,UInt16);// ************************************************************************************** mainvoid  main(void){	UInt32				seconds;	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии initialise managers	doPreliminaries();	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии seed random number generator		GetDateTime(&seconds);	SetQDGlobalsRandomSeed(seconds);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus		menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		ExitToShell();	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}			menuRef = GetMenuRef(mDemonstration);		if(menuRef != NULL)			EnableMenuItem(menuRef,iAnimatedCursorOSX);		gRunningOnX = true;	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open window	if(!(gWindowRef = GetNewCWindow(rWindow,NULL,(WindowRef)-1)))		ExitToShell();	SetPortWindowPort(gWindowRef);	TextSize(10);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter event loop	eventLoop();}// ************************************************************************** do preliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(64);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************* eventLoopvoid  eventLoop(void){	EventRecord	eventStructure;	Boolean			gotEvent;	gDone = false;	gSleepTime = MAX_UINT32;	gCursorRegion = NULL;		while(!gDone)	{		gotEvent = WaitNextEvent(everyEvent,&eventStructure,gSleepTime,gCursorRegion);		if(gotEvent)			doEvents(&eventStructure);		else		{			if(eventStructure.what == nullEvent)				doIdle();		}	}}// ************************************************************************************ doIdlevoid  doIdle(void){	if(gAnimatedCursor1Active || gAnimatedCursor2Active)		doIncrementAnimCursor();}// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){			WindowRef				windowRef;	WindowPartCode	partCode;	switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case mouseDown:			partCode = FindWindow(eventStrucPtr->where,&windowRef);			switch(partCode)			{				case inMenuBar:					doMenuChoice(MenuSelect(eventStrucPtr->where));					break;				case inContent:					if(windowRef != FrontWindow())						SelectWindow(windowRef);					break;				case inDrag:					DragWindow(windowRef,eventStrucPtr->where,NULL);					if(gCursorRegionsActive)						doChangeCursor(windowRef,gCursorRegion);					break;			}			break;		case keyDown:			if((eventStrucPtr->modifiers & cmdKey) != 0)				doMenuChoice(MenuEvent(eventStrucPtr));			break;		case updateEvt:			BeginUpdate((WindowRef) eventStrucPtr->message);			EndUpdate((WindowRef) eventStrucPtr->message);			break;		case osEvt:			switch((eventStrucPtr->message >> 24) & 0x000000FF)			{				case suspendResumeMessage:					if((eventStrucPtr->message & resumeFlag) == 1)						SetThemeCursor(kThemeArrowCursor);					break;								case mouseMovedMessage:					if(gCursorRegionsActive)						doChangeCursor(FrontWindow(),gCursorRegion);					break;			}			break;	}}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;			menuID = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	if(gAnimatedCursor1Active || gAnimatedCursor2Active)	{		if(gAnimatedCursor2Active)			doReleaseAnimCursor();		SetThemeCursor(kThemeArrowCursor);		gSleepTime = MAX_UINT32;		gAnimatedCursor1Active = false;		gAnimatedCursor2Active = false;	}		if(gAnimatedCursorOSXActive)		doAnimatedCursorOSX();	if(gCursorRegionsActive == true)	{		gCursorRegionsActive = false;		DisposeRgn(gCursorRegion);		gCursorRegion = NULL;	}	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				doAboutDialog();			break;		case mFile:			if(menuItem == iQuit)				gDone = true;			break;		case mDemonstration:			switch(menuItem)			{				case iOffScreenGWorld1:					doOffScreenGWorld1();					break;							case iOffScreenGWorld2:					doOffScreenGWorld2();					break;				case iPicture:					doPicture();					break;				case iCursor:					doCursor();					break;				case iAnimatedCursor1:					doAnimatedCursor1();					break;				case iAnimatedCursor2:					doAnimatedCursor2();					break;				case iAnimatedCursorOSX:					doAnimatedCursorOSX();					break;				case iIcon:					doIcon();					break;			}			break;	}	HiliteMenu(0);}// ************************************************************************ doOffScreenGWorld1void  doOffScreenGWorld1(void){	Rect					portRect, sourceRect, destRect;		GrafPtr				windowPortPtr;	GDHandle			deviceHdl;	QDErr					qdErr;	GWorldPtr			gworldPortPtr;	PixMapHandle	gworldPixMapHdl, windowPixMapHdl;	Boolean				lockPixResult;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии draw in window	SetWTitle(gWindowRef,"\pTime-consuming drawing operation");	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	doDrawStuff();	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);		SetWTitle(gWindowRef,"\pClick mouse to repeat in offscreen graphics port");	QDFlushPortBuffer(GetWindowPort(gWindowRef),NULL);	while(!Button()) ;	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);		GetWindowPortBounds(gWindowRef,&portRect);	RGBBackColor(&gBlueColour);	EraseRect(&portRect);	RGBForeColor(&gWhiteColour);	MoveTo(190,180);	DrawString("\pPlease Wait.  Drawing in offscreen graphics port.");		// ииииииииииииииииииииииииииииииииииииии draw in offscreen graphics port and copy to window	// ......................... save current graphics world and create offscreen graphics world	GetGWorld(&windowPortPtr,&deviceHdl);	qdErr = NewGWorld(&gworldPortPtr,0,&portRect,NULL,NULL,0);	if(gworldPortPtr == NULL || qdErr != noErr)	{		SysBeep(10);		return;	}	SetGWorld(gworldPortPtr,NULL);	// ................... lock pixel image for duration of drawing and erase offscreen to white	gworldPixMapHdl = GetGWorldPixMap(gworldPortPtr);	if(!(lockPixResult = LockPixels(gworldPixMapHdl)))	{		SysBeep(10);		return;	}	EraseRect(&portRect);		// ................................................... draw into the offscreen graphics port	doDrawStuff();	// ............................................................ restore saved graphics world	SetGWorld(windowPortPtr,deviceHdl);	// ................................................... set source and destination rectangles	GetPortBounds(gworldPortPtr,&sourceRect);	GetPortBounds(windowPortPtr,&destRect);	// ............................................................. get window port's pixel map	windowPixMapHdl = GetGWorldPixMap(windowPortPtr);	// ............. ensure background colour is white and foreground colour in black, then copy	RGBBackColor(&gWhiteColour);	RGBForeColor(&gBlackColour);	CopyBits((BitMap *) *gworldPixMapHdl,					 (BitMap *) *windowPixMapHdl,					 &sourceRect,&destRect,srcCopy,NULL);	if(QDError() != noErr)		SysBeep(10);	// ................................................................................ clean up 	UnlockPixels(gworldPixMapHdl);	DisposeGWorld(gworldPortPtr);		if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);	SetWTitle(gWindowRef,"\pOffscreen Graphics Worlds, Pictures,	Cursors and Icons");	QDFlushPortBuffer(GetWindowPort(gWindowRef),NULL);}// ************************************************************************ doOffScreenGWorld2void  doOffScreenGWorld2(void){	PicHandle			picture1Hdl,picture2Hdl;	Rect					portRect;	Rect					sourceRect, maskRect, maskDisplayRect, dest1Rect, dest2Rect, destRect;	GrafPtr				windowPortPtr;		GDHandle			deviceHdl;	QDErr					qdErr;	GWorldPtr			gworldPortPtr;	PixMapHandle	gworldPixMapHdl, windowPixMapHdl;	RgnHandle			region1Hdl, region2Hdl, regionHdl;	SInt16				a, sourceMode;	RGBBackColor(&gBeigeColour);	GetWindowPortBounds(gWindowRef,&portRect);		EraseRect(&portRect);	// ииииииииииииииииииииииииииииииииииииииии get the source picture and draw it in the window	if(!(picture1Hdl = GetPicture(rPicture)))		ExitToShell();	HNoPurge((Handle) picture1Hdl);	SetRect(&sourceRect,116,35,273,147);	DrawPicture(picture1Hdl,&sourceRect);	HPurge((Handle) picture1Hdl);	MoveTo(116,32);	DrawString("\pSource image");	// иииииииииииииииииииииииии save current graphics world and create offscreen graphics world	GetGWorld(&windowPortPtr,&deviceHdl);		SetRect(&maskRect,0,0,157,112);	qdErr = NewGWorld(&gworldPortPtr,0,&maskRect,NULL,NULL,0);		if(gworldPortPtr == NULL || qdErr != noErr)	{		SysBeep(10);		return;	}	SetGWorld(gworldPortPtr,NULL);	// иииииииииииииииииии lock pixel image for duration of drawing and erase offscreen to white	gworldPixMapHdl = GetGWorldPixMap(gworldPortPtr);	if(!(LockPixels(gworldPixMapHdl)))	{		SysBeep(10);		return;	}	GetPortBounds(gworldPortPtr,&portRect);		EraseRect(&portRect);	// иииииииииииииииииииииииииииииииии get mask picture and draw it in offscreen graphics port	if(!(picture2Hdl = GetPicture(rPicture + 1)))		ExitToShell();	HNoPurge((Handle) picture2Hdl);	DrawPicture(picture2Hdl,&maskRect);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии also draw it in the window	SetGWorld(windowPortPtr,deviceHdl);	SetRect(&maskDisplayRect,329,35,485,146);	DrawPicture(picture2Hdl,&maskDisplayRect);	HPurge((Handle) picture2Hdl);	MoveTo(329,32);	DrawString("\pCopy of offscreen mask");	// ииииииииииииииииииииииии define an oval-shaped region and a round rectangle-shaped region		SetRect(&dest1Rect,22,171,296,366);	region1Hdl = NewRgn();	OpenRgn();	FrameOval(&dest1Rect);	CloseRgn(region1Hdl);	SetRect(&dest2Rect,308,171,582,366);	region2Hdl = NewRgn();	OpenRgn();	FrameRoundRect(&dest2Rect,100,100);	CloseRgn(region2Hdl);	SetWTitle(GetWindowFromPort(windowPortPtr),"\pClick mouse to copy");	QDFlushPortBuffer(GetWindowPort(gWindowRef),NULL);	while(!Button()) ;	// ............................................................. get window port's pixel map	windowPixMapHdl = GetGWorldPixMap(windowPortPtr);	// ииииииии set background and foreground colour, then copy source to destination using mask 	RGBForeColor(&gBlackColour);	RGBBackColor(&gWhiteColour);	for(a=0;a<2;a++)	{		if(a == 0)		{			regionHdl = region1Hdl;			destRect = dest1Rect;			sourceMode = srcCopy;			MoveTo(22,168);			DrawString("\pBoolean source mode srcCopy");		}		else		{			regionHdl = region2Hdl;			destRect = dest2Rect;			sourceMode = srcXor;			MoveTo(308,168);			DrawString("\pBoolean source mode srcXor");		}		CopyDeepMask((BitMap *) *windowPixMapHdl,								 (BitMap *) *gworldPixMapHdl,								 (BitMap *) *windowPixMapHdl,								 &sourceRect,&maskRect,&destRect,sourceMode + ditherCopy,regionHdl);		if(QDError() != noErr)			SysBeep(10);	}	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии clean up 	UnlockPixels(gworldPixMapHdl);	DisposeGWorld(gworldPortPtr);		ReleaseResource((Handle) picture1Hdl);	ReleaseResource((Handle) picture2Hdl);	DisposeRgn(region1Hdl);	DisposeRgn(region2Hdl);	SetWTitle(gWindowRef,"\pOffscreen Graphics Worlds, Pictures,	Cursors and Icons");	QDFlushPortBuffer(GetWindowPort(gWindowRef),NULL);}// ********************************************************************************* doPicturevoid  doPicture(void){	Rect						portRect, pictureRect, theRect;		OpenCPicParams	picParams;	RgnHandle				oldClipRgn;	PicHandle				pictureHdl;	SInt16					a, left, top, right, bottom, random;	RGBColor				theColour;	PictInfo				pictInfo;	Str255					theString;	RGBBackColor(&gWhiteColour);	GetWindowPortBounds(gWindowRef,&portRect);	EraseRect(&portRect);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии define picture rectangle	pictureRect = portRect;	pictureRect.right = (portRect.right - portRect.left) / 2;	InsetRect(&pictureRect,10,10);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set clipping region	oldClipRgn = NewRgn();	GetClip(oldClipRgn);	ClipRect(&pictureRect);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up OpenCPicParams structure 	picParams.srcRect	= pictureRect;	picParams.hRes		= 0x00480000;	picParams.vRes		= 0x00480000;	picParams.version = -2;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии record picture	pictureHdl = OpenCPicture(&picParams);	RGBBackColor(&gBlueColour);	EraseRect(&pictureRect);	for(a=0;a<300;a++)	{		theRect = pictureRect;		theColour.red   = doRandomNumber(0,65535);		theColour.green = doRandomNumber(0,65535);		theColour.blue  = doRandomNumber(0,65535);		RGBForeColor(&theColour);		left = doRandomNumber(10,theRect.right);			top = doRandomNumber(10,theRect.bottom);		right = doRandomNumber(left,theRect.right);			bottom = doRandomNumber(top,theRect.bottom);				SetRect(&theRect,left,top,right,bottom);		PenMode(doRandomNumber(addOver,adMin));				random = doRandomNumber(0,5);		if(random == 0)		{			MoveTo(left,top);			LineTo(right - 1,bottom - 1);		}		else if(random == 1)			PaintRect(&theRect);		else if(random == 2)			PaintRoundRect(&theRect,30,30);		else if(random == 3)			PaintOval(&theRect);		else if(random == 4)			PaintArc(&theRect,0,300);		else if(random == 5)		{			TextSize(doRandomNumber(10,70));			MoveTo(left,right);			DrawString("\pPICTURE");		}	}	// иииииииииииииииииииииииииииии stop recording, draw picture, restore saved clipping region	ClosePicture();	DrawPicture(pictureHdl,&pictureRect);	SetClip(oldClipRgn);	DisposeRgn(oldClipRgn);	// ииииииииииииииииииииииииииииииииииии display some information from the PictInfo structure	RGBForeColor(&gBlueColour);	RGBBackColor(&gBeigeColour);	PenMode(patCopy);	OffsetRect(&pictureRect,300,0);	EraseRect(&pictureRect);	FrameRect(&pictureRect);	TextSize(10);	if(GetPictInfo(pictureHdl,&pictInfo,recordFontInfo + returnColorTable,1,systemMethod,0))		SysBeep(10);	MoveTo(380,70);	DrawString("\pSome Picture Information:");	MoveTo(380,100);	DrawString("\pLines: ");	NumToString(pictInfo.lineCount,theString);	DrawString(theString);	MoveTo(380,115);	DrawString("\pRectangles: ");	NumToString((long) pictInfo.rectCount,theString);	DrawString(theString);	MoveTo(380,130);	DrawString("\pRound rectangles: ");	NumToString(pictInfo.rRectCount,theString);	DrawString(theString);	MoveTo(380,145);	DrawString("\pOvals: ");	NumToString(pictInfo.ovalCount,theString);	DrawString(theString);	MoveTo(380,160);	DrawString("\pArcs: ");	NumToString(pictInfo.arcCount,theString);	DrawString(theString);	MoveTo(380,175);	DrawString("\pPolygons: ");	NumToString(pictInfo.polyCount,theString);	DrawString(theString);	MoveTo(380,190);	DrawString("\pRegions: ");	NumToString(pictInfo.regionCount,theString);	DrawString(theString);	MoveTo(380,205);	DrawString("\pText strings: ");	NumToString(pictInfo.textCount,theString);	DrawString(theString);	MoveTo(380,220);	DrawString("\pUnique fonts: ");	NumToString(pictInfo.uniqueFonts,theString);	DrawString(theString);	MoveTo(380,235);	DrawString("\pUnique colours: ");	NumToString(pictInfo.uniqueColors,theString);	DrawString(theString);	MoveTo(380,250);	DrawString("\pFrame rectangle left: ");	NumToString(pictInfo.sourceRect.left,theString);	DrawString(theString);	MoveTo(380,265);	DrawString("\pFrame rectangle top: ");	NumToString(pictInfo.sourceRect.top,theString);	DrawString(theString);	MoveTo(380,280);	DrawString("\pFrame rectangle right: ");	NumToString(pictInfo.sourceRect.right,theString);	DrawString(theString);	MoveTo(380,295);	DrawString("\pFrame rectangle bottom: ");	NumToString(pictInfo.sourceRect.bottom,theString);	DrawString(theString);	QDFlushPortBuffer(GetWindowPort(gWindowRef),NULL);	// ииииииииииииииииииииииииииииииииииииииииииии release memory occupied by Picture structure	KillPicture(pictureHdl);}// ********************************************************************************** doCursorvoid  doCursor(void){	Rect		portRect, cursorRect;	SInt16	a;	RGBBackColor(&gBlueColour);	GetWindowPortBounds(gWindowRef,&portRect);	EraseRect(&portRect);	cursorRect = portRect;	for(a=0;a<3;a++)	{		InsetRect(&cursorRect,40,40);		if(a == 0 || a == 2)			RGBBackColor(&gBeigeColour);		else			RGBBackColor(&gBlueColour);		EraseRect(&cursorRect);	}	RGBForeColor(&gBeigeColour);	MoveTo(10,20);	DrawString("\pArrow cursor region");	RGBForeColor(&gBlueColour);	MoveTo(50,60);	DrawString("\pIBeam cursor region");	RGBForeColor(&gBeigeColour);	MoveTo(90,100);	DrawString("\pCross cursor region");	RGBForeColor(&gBlueColour);	MoveTo(130,140);	DrawString("\pPlus cursor region");	gCursorRegion = NewRgn();	doChangeCursor(gWindowRef,gCursorRegion);	gCursorRegionsActive = true;}// **************************************************************************** doChangeCursorvoid  doChangeCursor(WindowRef windowRef,RgnHandle cursorRegion){	RgnHandle	arrowCursorRgn;	RgnHandle	ibeamCursorRgn;	RgnHandle	crossCursorRgn;	RgnHandle	plusCursorRgn;	Rect			cursorRect;	GrafPtr		oldPort;		Point			mousePosition;		arrowCursorRgn = NewRgn();	ibeamCursorRgn = NewRgn();		crossCursorRgn = NewRgn();	plusCursorRgn	 = NewRgn();	SetRectRgn(arrowCursorRgn,-32768,-32768,32766,32766);	GetPort(&oldPort);	SetPortWindowPort(windowRef);	GetWindowPortBounds(windowRef,&cursorRect);	LocalToGlobal(&topLeft(cursorRect));	LocalToGlobal(&botRight(cursorRect));		InsetRect(&cursorRect,40,40);	RectRgn(ibeamCursorRgn,&cursorRect);	DiffRgn(arrowCursorRgn,ibeamCursorRgn,arrowCursorRgn);	InsetRect(&cursorRect,40,40);	RectRgn(crossCursorRgn,&cursorRect);	DiffRgn(ibeamCursorRgn,crossCursorRgn,ibeamCursorRgn);		InsetRect(&cursorRect,40,40);	RectRgn(plusCursorRgn,&cursorRect);	DiffRgn(crossCursorRgn,plusCursorRgn,crossCursorRgn);	GetGlobalMouse(&mousePosition);	if(PtInRgn(mousePosition,ibeamCursorRgn))	{		SetThemeCursor(kThemeIBeamCursor);		CopyRgn(ibeamCursorRgn,cursorRegion);	}	else if(PtInRgn(mousePosition,crossCursorRgn))	{		SetThemeCursor(kThemeCrossCursor);		CopyRgn(crossCursorRgn,cursorRegion);	}	else if(PtInRgn(mousePosition,plusCursorRgn))	{		SetThemeCursor(kThemePlusCursor);		CopyRgn(plusCursorRgn,cursorRegion);	}	else	{		SetThemeCursor(kThemeArrowCursor);		CopyRgn(arrowCursorRgn,cursorRegion);	}	DisposeRgn(arrowCursorRgn);	DisposeRgn(ibeamCursorRgn);	DisposeRgn(crossCursorRgn);	DisposeRgn(plusCursorRgn);	SetPort(oldPort);}// ************************************************************************* doAnimatedCursor1void  doAnimatedCursor1(void){	Rect		portRect;	Pattern	whitePattern;	BackColor(whiteColor);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	gAnimCursTickInterval = kCountingHandTickInterval;	gSleepTime = gAnimCursTickInterval;	gAnimatedCursor1Active = true;}// ************************************************************************* doAnimatedCursor2void  doAnimatedCursor2(void){	Rect		portRect;	Pattern	whitePattern;	SInt16	animCursResourceID, animCursTickInterval;	BackColor(whiteColor);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	animCursResourceID	 = rBeachBallCursor;	animCursTickInterval = kBeachBallTickInterval;	if(doGetAnimCursor(animCursResourceID,animCursTickInterval))	{		gSleepTime = animCursTickInterval;		gAnimatedCursor2Active = true;	}		else		SysBeep(10);}// *************************************************************************** doGetAnimCursorBoolean  doGetAnimCursor(SInt16 resourceID,SInt16 tickInterval){	SInt16	cursorID, a = 0;	Boolean	noError = false;	if((gAnimCursHdl = (animCursHandle) GetResource('acur',resourceID)))	{		noError = true;		while((a < (*gAnimCursHdl)->numberOfFrames)  && noError)		{			cursorID = (SInt16) HiWord((SInt32) (*gAnimCursHdl)->frame[a]);			(*gAnimCursHdl)->frame[a] = GetCursor(cursorID);			if((*gAnimCursHdl)->frame[a])				a++;			else				noError = false;		}	}	if(noError)	{		gAnimCursTickInterval = tickInterval;		gAnimCursLastTick = TickCount();		(*gAnimCursHdl)->whichFrame = 0;	}	return noError;}// ********************************************************************* doIncrementAnimCursorvoid  doIncrementAnimCursor(void){	SInt32				newTick;	static UInt32	animationStep;	newTick = TickCount();	if(newTick < (gAnimCursLastTick + gAnimCursTickInterval))		return;	if(gAnimatedCursor1Active)	{		SetAnimatedThemeCursor(kThemeCountingUpAndDownHandCursor,animationStep);			animationStep++;	}	else if(gAnimatedCursor2Active)	{		SetCursor(*((*gAnimCursHdl)->frame[(*gAnimCursHdl)->whichFrame++]));		if((*gAnimCursHdl)->whichFrame == (*gAnimCursHdl)->numberOfFrames)			(*gAnimCursHdl)->whichFrame = 0;	}	gAnimCursLastTick = newTick;}// *********************************************************************** doReleaseAnimCursorvoid  doReleaseAnimCursor(void){	SInt16	a;	for(a=0;a<(*gAnimCursHdl)->numberOfFrames;a++)		ReleaseResource((Handle) (*gAnimCursHdl)->frame[a]);	ReleaseResource((Handle) gAnimCursHdl);}// *********************************************************************** doAnimatedCursorOSXvoid  doAnimatedCursorOSX(void){	if(!gAnimatedCursorOSXActive)	{		QDDisplayWaitCursor(true);		gAnimatedCursorOSXActive = true;	}	else	{		QDDisplayWaitCursor(false);		gAnimatedCursorOSXActive = false;	}}// ************************************************************************************ doIconvoid  doIcon(void){	Rect							portRect, theRect;	SInt16						a, b, stringIndex = 1;	IconTransformType	transform = 0;	Str255						theString;	Handle						iconSuiteHdl;	CIconHandle				ciconHdl;	RGBForeColor(&gBlueColour);	RGBBackColor(&gBeigeColour);	GetWindowPortBounds(gWindowRef,&portRect);	EraseRect(&portRect);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии PlotIconID with transforms	MoveTo(50,28);	DrawString("\pPlotIconID with transforms");	for(a=50;a<471;a+=140)	{ 			if(a == 190)			transform = 16384;		if(a == 330)			transform = 256;						for(b=0;b<4;b++)		{			if(a == 470 && b == 3)				continue;			GetIndString(theString,rTransformStrings,stringIndex++);			MoveTo(a,b * 60 + 47);			DrawString(theString);						SetRect(&theRect,a,b * 60 + 50,a + 32,b * 60 + 82);			PlotIconID(&theRect,0,transform,rIconFamily1);			SetRect(&theRect,a + 40,b * 60 + 50,a + 56,b * 60 + 66);			PlotIconID(&theRect,0,transform,rIconFamily1);			SetRect(&theRect,a + 64,b * 60 + 50,a + 80,b * 60 + 62);			PlotIconID(&theRect,0,transform,rIconFamily1);			if(a >= 330)				transform += 256;			else				transform ++;		}	}	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииии GetIconSuite and PlotIconSuite	MoveTo(50,275);	LineTo(550,275);	MoveTo(50,299);	DrawString("\pGetIconSuite and PlotIconSuite");	GetIconSuite(&iconSuiteHdl,rIconFamily2,kSelectorAllLargeData);	SetRect(&theRect,50,324,82,356);	PlotIconSuite(&theRect,kAlignNone,kTransformNone,iconSuiteHdl);	SetRect(&theRect,118,316,166,364);	PlotIconSuite(&theRect,kAlignNone,kTransformNone,iconSuiteHdl);	SetRect(&theRect,202,308,266,372);	PlotIconSuite(&theRect,kAlignNone,kTransformNone,iconSuiteHdl);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии GetCIcon and PlotCIcon	MoveTo(330,299);	DrawString("\pGetCIcon and PlotCIcon");	ciconHdl = GetCIcon(rColourIcon);	SetRect(&theRect,330,324,362,356);	PlotCIcon(&theRect,ciconHdl);	SetRect(&theRect,398,316,446,364);	PlotCIcon(&theRect,ciconHdl);	SetRect(&theRect,482,308,546,372);	PlotCIcon(&theRect,ciconHdl);}// ***************************************************************************** doAboutDialogvoid  doAboutDialog(void){	DialogPtr	dialogPtr;	SInt16		itemHit;	dialogPtr = GetNewDialog(rAboutDialog,NULL,(WindowRef)-1);	ModalDialog(NULL,&itemHit);	DisposeDialog(dialogPtr);}// ******************************************************************************* doDrawStuffvoid  doDrawStuff(void){	Rect			portRect, theRect;	RGBColor	theColour;	SInt16		a, left, top, right, bottom, random;	RGBBackColor(&gBlueColour);	GetWindowPortBounds(gWindowRef,&portRect);	EraseRect(&portRect);	for(a=0;a<900;a++)	{		theRect = portRect;		theColour.red   = doRandomNumber(0,65535);		theColour.green = doRandomNumber(0,65535);		theColour.blue  = doRandomNumber(0,65535);		RGBForeColor(&theColour);		left = doRandomNumber(0,theRect.right);			top = doRandomNumber(0,theRect.bottom);		right = doRandomNumber(left,theRect.right);			bottom = doRandomNumber(top,theRect.bottom);				SetRect(&theRect,left,top,right,bottom);		PenMode(doRandomNumber(addOver,adMin));				random = doRandomNumber(0,3);		if(random == 0)			PaintRect(&theRect);		else if(random == 1)			PaintRoundRect(&theRect,doRandomNumber(10,100),doRandomNumber(10,100));		else if(random == 2)			PaintOval(&theRect);		else if(random == 3)			PaintArc(&theRect,0,doRandomNumber(5,330));		QDFlushPortBuffer(GetWindowPort(gWindowRef),NULL);	}}// **************************************************************************** doRandomNumberUInt16  doRandomNumber(UInt16 minimum, UInt16 maximum){	UInt16	randomNumber;	SInt32	range, t;	randomNumber = Random();	range = maximum - minimum + 1;	t = (randomNumber * range) / 65536;	return (t + minimum);}// *******************************************************************************************