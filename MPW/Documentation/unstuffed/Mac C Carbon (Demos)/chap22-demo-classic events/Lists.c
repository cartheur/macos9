// *******************************************************************************************// Lists.c// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include "Lists.h"// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesListDefUPP				gListDefFunctionUPP;Boolean						gRunningOnX = false;Boolean						gDone;backColourPattern	gBackColourPattern;// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	EventRecord		eventStructure;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// ииииииииииииииииииииииииииииииииииииииииииииииииииииии create universal procedure pointer	gListDefFunctionUPP	= NewListDefUPP((ListDefProcPtr) listDefFunction);		// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		ExitToShell();	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}		gRunningOnX = true;	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop	gDone = false;	while(!gDone)	{		if(WaitNextEvent(everyEvent,&eventStructure,MAX_UINT32,NULL))			doEvents(&eventStructure);	}}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(256);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	WindowRef						windowRef;	WindowPartCode			partCode;	docStructureHandle	docStrucHdl;	SInt8								charCode;	switch(eventStrucPtr->what)	{		case mouseDown:			partCode = FindWindow(eventStrucPtr->where,&windowRef);			switch(partCode)			{				case kHighLevelEvent:					AEProcessAppleEvent(eventStrucPtr);					break;				case inMenuBar:					doAdjustMenus();					doMenuChoice(MenuSelect(eventStrucPtr->where));					break;				case inContent:					if(windowRef != FrontWindow())						SelectWindow(windowRef);					else						doInContent(eventStrucPtr);					break;				case inDrag:					DragWindow(windowRef,eventStrucPtr->where,NULL);					break;				case inGoAway:					docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);					LDispose((*docStrucHdl)->textListHdl);					LDispose((*docStrucHdl)->iconListHdl);					DisposeHandle((Handle) docStrucHdl);					DisposeWindow(windowRef);					break;			}			break;		case keyDown:			charCode = eventStrucPtr->message & charCodeMask;			if((eventStrucPtr->modifiers & cmdKey) != 0)			{				doAdjustMenus();				doMenuChoice(MenuEvent(eventStrucPtr));			}			if(FrontWindow())				doKeyDown(charCode,eventStrucPtr);			break;		case updateEvt:			doUpdate(eventStrucPtr);			break;		case activateEvt:			doActivate(eventStrucPtr);			break;		case osEvt:			switch((eventStrucPtr->message >> 24) & 0x000000FF)			{				case suspendResumeMessage:					if((eventStrucPtr->message & resumeFlag) == 1)						SetThemeCursor(kThemeArrowCursor);					break;			}			break;	}}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef	menuRef;	menuRef = GetMenuRef(mDemonstration);	if(FrontWindow())		DisableMenuItem(menuRef,1);	else		EnableMenuItem(menuRef,1);}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;	menuID = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;		case mFile:			if(menuItem == iQuit)				gDone = true;			break;		case mDemonstration:			if(menuItem == iHandMadeLists)				doOpenListsWindow();			else if(menuItem == iListControlLists)				doListsDialog();			break;	}	HiliteMenu(0);}// ************************************************************************** doSaveBackgroundvoid  doSaveBackground(backColourPattern *gBackColourPattern){	GrafPtr				currentPort;	PixPatHandle	backPixPatHdl;	GetPort(&currentPort);	GetBackColor(&gBackColourPattern->backColour);	gBackColourPattern->backPixelPattern	= NULL;	backPixPatHdl = NewPixPat();	GetPortBackPixPat(currentPort,backPixPatHdl);	if((*backPixPatHdl)->patType != 0)		gBackColourPattern->backPixelPattern = backPixPatHdl;	else		gBackColourPattern->backBitPattern = *(PatPtr) (*(*backPixPatHdl)->patData);	DisposePixPat(backPixPatHdl);}// *********************************************************************** doRestoreBackgroundvoid  doRestoreBackground(backColourPattern *gBackColourPattern){	RGBBackColor(&gBackColourPattern->backColour);	if(gBackColourPattern->backPixelPattern)		BackPixPat(gBackColourPattern->backPixelPattern);	else		BackPat(&gBackColourPattern->backBitPattern);}// ********************************************************************** doSetBackgroundWhitevoid  doSetBackgroundWhite(void){	RGBColor	whiteColour = { 0xFFFF, 0xFFFF, 0xFFFF };	Pattern		whitePattern;	RGBBackColor(&whiteColour);	GetQDGlobalsWhite(&whitePattern);	BackPat(&whitePattern);}// *******************************************************************************************