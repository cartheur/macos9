// *******************************************************************************************// PreQuickDraw.c                                                          CLASSIC EVENT MODEL// *******************************************************************************************// // This program opens a window in which is displayed some information retrieved from the// GDevice structure for the main video device, from the graphics port's pixel map, and from// the graphics port object using QuickDraw functions.  //// A Demonstration menu allows the user to set the monitor to various pixel depths and to // restore the original pixel depth.  Setting the monitor to a pixel depth of 8 (256 colours)// or less causes the colours in the colour table to be displayed.//// The program utilises 'plst', 'MBAR', 'MENU', 'WIND', and 'STR#' resources, and a 'SIZE'// resource with the acceptSuspendResumeEvents, canBackground, doesActivateOnFGSwitch, and // isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar							128#define rWindow								128#define mAppleApplication			128#define  iAbout								1#define mFile									129#define  iQuit								12#define mDemonstration				131#define  iSetDepth8						1#define  iSetDepth16					2#define  iSetDepth32					3#define  iRestoreStartDepth		5#define rIndexedStrings				128#define  sMonitorInadequate		1#define  sMonitorAtThatDepth	2  #define  sMonitorAtStartDepth	3 #define  sRestoringMonitor		4#define MAX_UINT32						0xFFFFFFFF// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean	gDone;SInt16	gStartupPixelDepth;// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid		main												(void);void		doPreliminaries							(void);OSErr		quitAppEventHandler					(AppleEvent *,AppleEvent *,SInt32);void		doEvents										(EventRecord *);void		doDisplayInformation				(WindowRef);Boolean	doCheckMonitor							(void);void		doSetMonitorPixelDepth			(SInt16);void		doRestoreMonitorPixelDepth	(void);void		doMonitorAlert							(Str255);// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	WindowRef			windowRef;	SInt16				entries = 0;	Str255				theString;	EventRecord		EventStructure;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();		// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus		menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		ExitToShell();	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}	}	// иииииииииииииииииииииииииииииииииииии check if monitor can display at least 16-bit colour	if(!doCheckMonitor())	{		GetIndString(theString,rIndexedStrings,sMonitorInadequate);		doMonitorAlert(theString);	}	// ииииииииииииииииииииииииииииииииииииии open windows, set font, show windows, move windows	if(!(windowRef = GetNewCWindow(rWindow,NULL,(WindowRef)-1)))		ExitToShell();	SetPortWindowPort(windowRef);	TextSize(10);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop	gDone = false;	while(!gDone)	{		if(WaitNextEvent(everyEvent,&EventStructure,MAX_UINT32,NULL))			doEvents(&EventStructure);	}}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(32);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	SInt32					menuChoice;	MenuID					menuID;	MenuItemIndex		menuItem;	WindowPartCode	partCode;	WindowRef				windowRef;	Rect						portRect;			switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case keyDown:			if((eventStrucPtr->modifiers & cmdKey) != 0)			{				menuChoice = MenuEvent(eventStrucPtr);				menuID = HiWord(menuChoice);				menuItem = LoWord(menuChoice);				if(menuID == mFile && menuItem  == iQuit)					gDone = true;			}			break;		case mouseDown:			if(partCode = FindWindow(eventStrucPtr->where,&windowRef))			{				switch(partCode)				{					case inMenuBar:						menuChoice = MenuSelect(eventStrucPtr->where);						menuID = HiWord(menuChoice);						menuItem = LoWord(menuChoice);						if(menuID == 0)							return;						switch(menuID)						{							case mAppleApplication:								if(menuItem == iAbout)									SysBeep(10);								break;							case mFile:								if(menuItem == iQuit)									gDone = true;								break;								case mDemonstration:								if(menuItem == iSetDepth8)									doSetMonitorPixelDepth(8);								else if(menuItem == iSetDepth16)									doSetMonitorPixelDepth(16);								else if(menuItem == iSetDepth32)									doSetMonitorPixelDepth(32);								else if(menuItem == iRestoreStartDepth)									doRestoreMonitorPixelDepth();								break;						}						HiliteMenu(0);						break;										case inDrag:						DragWindow(windowRef,eventStrucPtr->where,NULL);						GetWindowPortBounds(windowRef,&portRect);						InvalWindowRect(windowRef,&portRect);						break;				}			}			break;		case updateEvt:			windowRef = (WindowRef) eventStrucPtr->message;			BeginUpdate(windowRef);			SetPortWindowPort(windowRef);			doDisplayInformation(windowRef);			EndUpdate(windowRef);			break;	}}// ********************************************************************** doDisplayInformationvoid  doDisplayInformation(WindowRef windowRef){	RGBColor			whiteColour = { 0xFFFF, 0xFFFF, 0xFFFF };	RGBColor			blueColour  = { 0x3333, 0x3333, 0x9999 };	Rect					portRect;	GDHandle			deviceHdl;	SInt16				videoDeviceCount = 0;		Str255				theString;	SInt16				deviceType, pixelDepth, bytesPerRow;	Rect					theRect;	GrafPtr				grafPort;	PixMapHandle	pixMapHdl;	CTabHandle		colorTableHdl;	SInt16				entries = 0, vert = 28, horiz = 250, index = 0;	RGBColor			getPixelColour,colourTableColour;	RGBForeColor(&whiteColour);	RGBBackColor(&blueColour);	GetWindowPortBounds(windowRef,&portRect);	EraseRect(&portRect);	QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии Get Device List	deviceHdl = GetDeviceList();	// ...................................................... count video devices in device list	while(deviceHdl != NULL)	{		if(TestDeviceAttribute(deviceHdl,screenDevice))			videoDeviceCount ++;		deviceHdl = GetNextDevice(deviceHdl);	}	NumToString(videoDeviceCount,theString);	MoveTo(10,20);	DrawString(theString);	if(videoDeviceCount < 2)		DrawString("\p video device in the device list.");	else		DrawString("\p video devices in the device list.");	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии Get Main Device	deviceHdl = GetMainDevice();	// ................................................................... determine device type	MoveTo(10,35);	if(((1 << gdDevType) & (*deviceHdl)->gdFlags) != 0)		DrawString("\pThe main video device is a colour device.");	else		DrawString("\pThe main video device is a monochrome device.");	MoveTo(10,50);	deviceType = (*deviceHdl)->gdType;	switch(deviceType)	{		case clutType:			DrawString("\pIt is an indexed device with variable CLUT.");			break;		case fixedType:			DrawString("\pIt is is an indexed device with fixed CLUT.");			break;		case directType:			DrawString("\pIt is a direct device.");			break;	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии Get Handle to Pixel Map	grafPort = GetWindowPort(windowRef);	pixMapHdl = GetPortPixMap(grafPort);	// pixMapHdl = (*deviceHdl)->gdPMap; // alternative method	// ............................................................. get and display pixel depth	MoveTo(10,70);	DrawString("\pPixel depth = ");	pixelDepth = GetPixDepth(pixMapHdl);	// pixelDepth = (*(*deviceHdl)->gdPMap)->pixelSize;  // alternative method	NumToString(pixelDepth,theString);	DrawString(theString);	// ........................................................... get and display bytes per row 	MoveTo(10,90);	bytesPerRow = (*pixMapHdl)->rowBytes & 0x7FFF;	DrawString("\pBytes per row = ");	NumToString(bytesPerRow,theString);	DrawString(theString);	// ииииииииииииииииииииииииииииииииииииииииииииииииии Get Device's Global Boundary Rectangle	theRect = (*deviceHdl)->gdRect;	// ........................................... calculate and display total pixel image bytes	MoveTo(10,105);	DrawString("\pTotal pixel image bytes = ");	NumToString(bytesPerRow * theRect.bottom,theString);	DrawString(theString);	// ..................................................... display device's boundary rectangle	MoveTo(10,130);	TextFace(bold);	DrawString("\pGraphics Device's Boundary Rectangle");	TextFace(normal);	MoveTo(10,145);	DrawString("\p(gdRect field of GDevice structure)");	MoveTo(10,160);	DrawString("\pBoundary rectangle top = ");	NumToString(theRect.top,theString);	DrawString(theString);	MoveTo(10,175);	DrawString("\pBoundary rectangle left = ");	NumToString(theRect.left,theString);	DrawString(theString);	MoveTo(10,190);	DrawString("\pBoundary rectangle bottom = ");	NumToString(theRect.bottom,theString);	DrawString(theString);	MoveTo(10,205);	DrawString("\pBoundary rectangle right = ");	NumToString(theRect.right,theString);	DrawString(theString);	// ииииииииииииииииииииииииииииииииииииииииии Get and Display Pixel Map's Boundary Rectangle	GetPixBounds(pixMapHdl,&theRect);	MoveTo(10,225);	TextFace(bold);	DrawString("\pPixel Map's Boundary Rectangle");	TextFace(normal);	MoveTo(10,240);	DrawString("\p(bounds field of PixMap structure)");	MoveTo(10,255);	DrawString("\pBoundary rectangle top = ");	NumToString(theRect.top,theString);	DrawString(theString);	MoveTo(10,270);	DrawString("\pBoundary rectangle left = ");	NumToString(theRect.left,theString);	DrawString(theString);	MoveTo(10,285);	DrawString("\pBoundary rectangle bottom = ");	NumToString(theRect.bottom,theString);	DrawString(theString);	MoveTo(10,300);	DrawString("\pBoundary rectangle right = ");	NumToString(theRect.right,theString);	DrawString(theString);	MoveTo(10,320);	DrawString("\pOn Mac OS X, drag window after pixel depth and screen resolution changes to");	DrawString("\p ensure that");	MoveTo(10,333);	DrawString("\pbytes per row, pixel image bytes, and colour values are updated.");	// иииииииииииииииииииииииииии Get and Display RGB Components of Requested Background Colour	MoveTo(250,255);	GetBackColor(&blueColour);	DrawString("\pRequested background colour (rgb) = ");	MoveTo(250,270);	NumToString(blueColour.red,theString);	DrawString(theString);	DrawString("\p  ");	NumToString(blueColour.green,theString);	DrawString(theString);	DrawString("\p  ");	NumToString(blueColour.blue,theString);	DrawString(theString);	// ииииииии If Direct Device, Get and Display RGB Components of Colour Returned by GetCPixel	if(deviceType == directType)	{		MoveTo(250,285);		GetCPixel(10,10,&getPixelColour);		DrawString("\pColour returned by CetCPixel (rgb) = ");		MoveTo(250,300);		NumToString(getPixelColour.red,theString);		DrawString(theString);		DrawString("\p  ");		NumToString(getPixelColour.green,theString);		DrawString(theString);		DrawString("\p  ");		NumToString(getPixelColour.blue,theString);		DrawString(theString);	}	// .............................................. else prepare to display colour table index	else	{		MoveTo(250,285);		DrawString("\pBackground colour (colour table index):");	}	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии Get Handle to Colour Table	colorTableHdl = (*pixMapHdl)->pmTable;	// ........................................ if any entries in colour table, draw the colours	MoveTo(250,20);	DrawString("\pColour table:");	entries = (*colorTableHdl)->ctSize;	if(entries < 2)	{		MoveTo(260,100);		DrawString("\pOnly one (dummy) entry in the colour");		MoveTo(260,115);		DrawString("\ptable.  To cause the colour table to be");		MoveTo(260,130);		DrawString("\pbuilt, set the monitor to bit depth 8");		MoveTo(260,145);		DrawString("\p(256 colours), causing it to act like ");		MoveTo(260,160);		DrawString("\pan indexed device.");		SetRect(&theRect,250,28,458,236);		FrameRect(&theRect);	}	for(index = 0;index <= entries;index++)	{		SetRect(&theRect,horiz,vert,horiz+12,vert+12);		colourTableColour = (*colorTableHdl)->ctTable[index].rgb;		RGBForeColor(&colourTableColour);		PaintRect(&theRect);		// .... also, if device is not a  direct device, and current colour matches background ...		if(deviceType == clutType || deviceType == fixedType)		{			if(colourTableColour.red == blueColour.red && 				 colourTableColour.green == blueColour.green && 				 colourTableColour.blue == blueColour.blue)			{				// ....................... outline the drawn colour and display the colour table index				RGBForeColor(&whiteColour);				InsetRect(&theRect,-1,-1);				FrameRect(&theRect);				MoveTo(250,300);				NumToString(index,theString);				DrawString(theString);			}		}		horiz += 13;		if(horiz > 445)		{			horiz = 250;			vert += 13;		}	}	QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);}// **************************************************************************** doCheckMonitorBoolean  doCheckMonitor(void){	GDHandle	mainDeviceHdl;	mainDeviceHdl = GetMainDevice();	if(!(HasDepth(mainDeviceHdl,16,gdDevType,1)))	{		DisableMenuItem(GetMenuRef(mDemonstration),0);		return false;	}	else	{		gStartupPixelDepth = (**((**mainDeviceHdl).gdPMap)).pixelSize;		return true;	}}// ******************************************************************** doSetMonitorPixelDepthvoid  doSetMonitorPixelDepth(SInt16 requiredDepth){	GDHandle	mainDeviceHdl;	Str255		alertString;		SInt16		currentPixelDepth;	mainDeviceHdl = GetMainDevice();	currentPixelDepth = (**((**mainDeviceHdl).gdPMap)).pixelSize;	if(currentPixelDepth != requiredDepth)	{		SetDepth(mainDeviceHdl,requiredDepth,gdDevType,1);	}	else	{		GetIndString(alertString,rIndexedStrings,sMonitorAtThatDepth);		doMonitorAlert(alertString);	}}// **************************************************************** doRestoreMonitorPixelDepthvoid  doRestoreMonitorPixelDepth(void){	GDHandle	mainDeviceHdl;	Str255		alertString;		SInt16		pixelDepth;	mainDeviceHdl = GetMainDevice();	pixelDepth = (**((**mainDeviceHdl).gdPMap)).pixelSize;	if(pixelDepth != gStartupPixelDepth)	{		GetIndString(alertString,rIndexedStrings,sRestoringMonitor);		doMonitorAlert(alertString);		SetDepth(mainDeviceHdl,gStartupPixelDepth,gdDevType,1);	}	else	{		GetIndString(alertString,rIndexedStrings,sMonitorAtStartDepth);		doMonitorAlert(alertString);	}}// **************************************************************************** doMonitorAlertvoid  doMonitorAlert(Str255 labelText){	SInt16	itemHit;	StandardAlert(kAlertNoteAlert,labelText,NULL,NULL,&itemHit);}// *******************************************************************************************