// *******************************************************************************************// Windows1.c                                                              CLASSIC EVENT MODEL// *******************************************************************************************// // This program://// ╔	Allows the user to open any number of kWindowFullZoomGrowDocumentProc windows, up to the//		maximum specified by the constant assigned to the symbolic name kMaxWindows, using the //		File menu Open Command or its keyboard equivalent.//// ╔	Allows the user to close opened windows using the close box/button, the File menu Close//		command or the Close command's keyboard equivalent.//// ╔	Adds menu items representing each window to a Windows menu as each window is opened.//		(A keyboard equivalent is included in each menu item for windows 1 to 9.)//// ╔	Deletes menu items from the Windows menu as each window is closed.//// ╔	Fills each window with a plain colour pattern as a means of proving, for demonstration//		purposes, the window update process.//// ╔	Facilitates activation of a window by mouse selection.//// ╔	Facilitates activation of a window by Windows menu selection.//// ╔	Correctly performs all dragging, zooming and sizing operations.//// ╔	On Mac OS 8/9, demonstrates the provision of balloon help for static windows.//// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	An 'MBAR' resource, and 'MENU' resources for Apple/Application, File, Edit and Windows //		menus, (preload non-purgeable).  //// ╔	A 'WIND' resource (purgeable) (initially not visible).  //// ╔	A 'STR#' resource containing error strings and the window title (purgeable).//// ╔	An 'hrct' resource and an 'hwin' resource for balloon help (both purgeable).//// ╔	Ten 'ppat' (pixel pattern) resources (purgeable), which are used to draw a plain colour//		pattern in the windows.//// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar					128#define mAppleApplication	128#define  iAbout						1#define mFile							129#define  iNew							1#define  iClose						4#define  iQuit						12#define mWindows					131#define rNewWindow				128#define rStringList				128#define  sUntitled				1#define  eMaxWindows			2#define  eFailWindow			4#define  eFailMenus				5#define  eFailMemory			6#define rPixelPattern			128#define kMaxWindows				10#define kScrollBarWidth   15#define MAX_UINT32				0xFFFFFFFF#define MIN(a,b) 					((a) < (b) ? (a) : (b))#define topLeft(r)				(((Point *) &(r))[0])// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean		gRunningOnX = false;Boolean		gDone;SInt32		gUntitledWindowNumber		= 0;SInt32		gCurrentNumberOfWindows	= 0;WindowRef	gWindowRefArray[kMaxWindows + 2];// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid		main											(void);void		doPreliminaries						(void);OSErr		quitAppEventHandler				(AppleEvent *,AppleEvent *,SInt32);void		eventLoop									(void);void		doEvents									(EventRecord *);void		doMouseDown								(EventRecord *);void		doUpdate									(EventRecord *);void		doUpdateWindow						(EventRecord *);void		doActivate								(EventRecord *);void		doActivateWindow					(WindowRef,Boolean);void		doOSEvent									(EventRecord *);void		doMenuChoice							(SInt32);void		doFileMenu								(MenuItemIndex);void		doWindowsMenu							(MenuItemIndex);void		doNewWindow								(void);void		doCloseWindow							(void);void		doInvalidateScrollBarArea	(WindowRef);void		doConcatPStrings					(Str255,Str255);void		doErrorAlert							(SInt16);Boolean	eventFilter								(DialogPtr,EventRecord *,SInt16 *);// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	SInt16				a;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus		menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		doErrorAlert(eFailMenus);	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);		}		gRunningOnX = true;	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииии initialize window reference array	for(a=0;a<kMaxWindows+2;a++)		gWindowRefArray[a] = NULL;	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop	eventLoop();}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(224);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************* eventLoopvoid  eventLoop(void){	EventRecord	eventStructure;	gDone = false;	while(!gDone)	{		if(WaitNextEvent(everyEvent,&eventStructure,MAX_UINT32,NULL))			doEvents(&eventStructure);	}}// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case mouseDown:			doMouseDown(eventStrucPtr);			break;		case keyDown:			if((eventStrucPtr->modifiers & cmdKey) != 0)				doMenuChoice(MenuEvent(eventStrucPtr));			break;		case updateEvt:			doUpdate(eventStrucPtr);			break;		case activateEvt:			doActivate(eventStrucPtr);			break;		case osEvt:			doOSEvent(eventStrucPtr);			break;	}}// ******************************************************************************* doMouseDownvoid	doMouseDown(EventRecord *eventStrucPtr){	WindowRef				windowRef;	WindowPartCode	partCode, zoomPart;	BitMap					screenBits;	Rect						constraintRect, mainScreenRect;	Point						standardStateHeightAndWidth;	partCode = FindWindow(eventStrucPtr->where,&windowRef);	switch(partCode)	{		case inMenuBar:			doMenuChoice(MenuSelect(eventStrucPtr->where));			break;		case inContent:			if(windowRef != FrontWindow())				SelectWindow(windowRef);			break;		case inDrag:			DragWindow(windowRef,eventStrucPtr->where,NULL);			break;		case inGoAway:			if(TrackGoAway(windowRef,eventStrucPtr->where) == true)				doCloseWindow();			break;		case inGrow:			constraintRect.top 	= 75; 			constraintRect.left = 205;			constraintRect.bottom = constraintRect.right = 32767;			doInvalidateScrollBarArea(windowRef);			ResizeWindow(windowRef,eventStrucPtr->where,&constraintRect,NULL);			doInvalidateScrollBarArea(windowRef);			break;		case inZoomIn:		case inZoomOut:			mainScreenRect = GetQDGlobalsScreenBits(&screenBits)->bounds;			standardStateHeightAndWidth.v = mainScreenRect.bottom;			standardStateHeightAndWidth.h = 460;			if(IsWindowInStandardState(windowRef,&standardStateHeightAndWidth,NULL))				zoomPart = inZoomIn;			else				zoomPart = inZoomOut;			if(TrackBox(windowRef,eventStrucPtr->where,partCode))				ZoomWindowIdeal(windowRef,zoomPart,&standardStateHeightAndWidth);			break;	}}// ********************************************************************************** doUpdatevoid  doUpdate(EventRecord *eventStrucPtr){	WindowRef	windowRef;	windowRef = (WindowRef) eventStrucPtr->message;	BeginUpdate(windowRef);	SetPortWindowPort(windowRef);	doUpdateWindow(eventStrucPtr);	EndUpdate(windowRef);}// **************************************************************************** doUpdateWindowvoid  doUpdateWindow(EventRecord *eventStrucPtr){	WindowRef			windowRef;	RgnHandle			visibleRegionHdl;	Rect 					theRect;	SInt32				windowRefCon;	PixPatHandle	pixpatHdl;	RGBColor			whiteColour = { 0xFFFF,0xFFFF,0xFFFF };	SInt16				a;		windowRef = (WindowRef) eventStrucPtr->message;	visibleRegionHdl = NewRgn();	GetPortVisibleRegion(GetWindowPort(windowRef),visibleRegionHdl);	EraseRgn(visibleRegionHdl);	DisposeRgn(visibleRegionHdl);	GetWindowPortBounds(windowRef,&theRect);	theRect.right  -= kScrollBarWidth;	theRect.bottom -= kScrollBarWidth;	windowRefCon = GetWRefCon(windowRef);	pixpatHdl = GetPixPat(rPixelPattern + windowRefCon);	FillCRect(&theRect,pixpatHdl);	DisposePixPat(pixpatHdl);	DrawGrowIcon(windowRef);			RGBForeColor(&whiteColour);	TextSize(10);	if(!gRunningOnX)	{		for(a=0;a<2;a++)		{			SetRect(&theRect,a*90+10,10,a*90+90,33);			FrameRect(&theRect);			MoveTo(a*90+18,25);			DrawString("\pHot Rectangle");		}	}}// ******************************************************************************** doActivatevoid  doActivate(EventRecord *eventStrucPtr){	WindowRef	windowRef;	Boolean		becomingActive;	windowRef = (WindowRef) eventStrucPtr->message;	becomingActive = ((eventStrucPtr->modifiers & activeFlag) == activeFlag);	doActivateWindow(windowRef,becomingActive);}// ************************************************************************** doActivateWindowvoid  doActivateWindow(WindowRef windowRef,Boolean becomingActive){	MenuRef	windowsMenu;	SInt16	menuItem, a = 1;	windowsMenu = GetMenuRef(mWindows);	while(gWindowRefArray[a] != windowRef)		a++;	menuItem = a;		if(becomingActive)		CheckMenuItem(windowsMenu,menuItem,true);	else		CheckMenuItem(windowsMenu,menuItem,false);			DrawGrowIcon(windowRef);}// ********************************************************************************* doOSEventvoid	doOSEvent(EventRecord *eventStrucPtr){	switch((eventStrucPtr->message >> 24) & 0x000000FF)	{		case suspendResumeMessage:			if((eventStrucPtr->message & resumeFlag) == 1)				SetThemeCursor(kThemeArrowCursor);			break;	}}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;	 			menuID = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;					case mFile:			doFileMenu(menuItem);			break;					case mWindows:			doWindowsMenu(menuItem);			break;			}	HiliteMenu(0);}// ******************************************************************************** doFileMenuvoid	doFileMenu(MenuItemIndex menuItem){	switch(menuItem)	{		case iNew:			doNewWindow();			break;		case iClose:			doCloseWindow();			break;					case iQuit:			gDone = true;			break;	}}// ***************************************************************************** doWindowsMenuvoid	doWindowsMenu(MenuItemIndex menuItem){	WindowRef	windowRef;	windowRef = gWindowRefArray[menuItem];	SelectWindow(windowRef);	}// ******************************************************************************* doNewWindowvoid  doNewWindow(void){	WindowRef	windowRef;	Str255		untitledString;	Str255		numberAsString = "\p1";	Rect			availableBoundsRect, portRect;	SInt16		windowHeight;	MenuRef		windowsMenu;	if(gCurrentNumberOfWindows == kMaxWindows)	{		doErrorAlert(eMaxWindows);		return;	}	if(!(windowRef = GetNewCWindow(rNewWindow,NULL,(WindowRef) -1)))		doErrorAlert(eFailWindow);	GetIndString(untitledString,rStringList,sUntitled);	gUntitledWindowNumber += 1;	if(gUntitledWindowNumber > 1)	{		NumToString(gUntitledWindowNumber,numberAsString);		doConcatPStrings(untitledString,numberAsString);	}	SetWTitle(windowRef,untitledString);	GetAvailableWindowPositioningBounds(GetMainDevice(),&availableBoundsRect);	GetWindowPortBounds(windowRef,&portRect);	SetPortWindowPort(windowRef);	LocalToGlobal(&topLeft(portRect));	windowHeight = (availableBoundsRect.bottom - portRect.top) - 3;	if(!gRunningOnX)		windowHeight -= 27;	SizeWindow(windowRef,460,windowHeight,false);	ShowWindow(windowRef);	if(gUntitledWindowNumber < 10)	{		doConcatPStrings(untitledString,"\p/");		doConcatPStrings(untitledString,numberAsString);	}	windowsMenu = GetMenuRef(mWindows);	InsertMenuItem(windowsMenu,untitledString,CountMenuItems(windowsMenu));			SetWRefCon(windowRef,gCurrentNumberOfWindows);	gCurrentNumberOfWindows ++;	gWindowRefArray[gCurrentNumberOfWindows] = windowRef;		if(gCurrentNumberOfWindows == 1)	{		EnableMenuItem(GetMenuRef(mFile),iClose);		EnableMenuItem(GetMenuRef(mWindows),0);		DrawMenuBar();	}}// ***************************************************************************** doCloseWindowvoid  doCloseWindow(void){	WindowRef	windowRef;	MenuRef		windowsMenu;	SInt16		a = 1;	windowRef = FrontWindow();	DisposeWindow(windowRef);	gCurrentNumberOfWindows --;	windowsMenu = GetMenuRef(mWindows);	while(gWindowRefArray[a] != windowRef)		a++;	gWindowRefArray[a] = NULL;	DeleteMenuItem(windowsMenu,a);	for(a=1;a<kMaxWindows+1;a++)	{		if(gWindowRefArray[a] == NULL)		{			gWindowRefArray[a] = gWindowRefArray[a+1];			gWindowRefArray[a+1] = NULL;		}	}		if(gCurrentNumberOfWindows == 0)	{		DisableMenuItem(GetMenuRef(mFile),iClose);		DisableMenuItem(GetMenuRef(mWindows),0);		DrawMenuBar();	}}// ***************************************************************** doInvalidateScrollBarAreavoid  doInvalidateScrollBarArea(WindowRef windowRef){	Rect	tempRect;	SetPortWindowPort(windowRef);	GetWindowPortBounds(windowRef,&tempRect);	tempRect.left = tempRect.right - kScrollBarWidth;	InvalWindowRect(windowRef,&tempRect);	GetWindowPortBounds(windowRef,&tempRect);	tempRect.top = tempRect.bottom - kScrollBarWidth;	InvalWindowRect(windowRef,&tempRect);}// ************************************************************************** doConcatPStringsvoid  doConcatPStrings(Str255 targetString,Str255 appendString){	SInt16	appendLength;	appendLength = MIN(appendString[0],255 - targetString[0]);	if(appendLength > 0)	{		BlockMoveData(appendString+1,targetString+targetString[0]+1,(SInt32) appendLength);		targetString[0] += appendLength;	}}// ****************************************************************************** doErrorAlertvoid  doErrorAlert(SInt16 errorType){	AlertStdAlertParamRec	paramRec;	ModalFilterUPP				eventFilterUPP;	Str255								labelText;	Str255								narrativeText;	SInt16								itemHit;	eventFilterUPP = NewModalFilterUPP((ModalFilterProcPtr) eventFilter);	paramRec.movable				= true;	paramRec.helpButton			= false;	paramRec.filterProc			= eventFilterUPP;	paramRec.defaultText		= (StringPtr) kAlertDefaultOKText;	paramRec.cancelText			= NULL;	paramRec.otherText			= NULL;	paramRec.defaultButton	= kAlertStdAlertOKButton;	paramRec.cancelButton		= 0;	paramRec.position				= kWindowAlertPositionMainScreen;	GetIndString(labelText,rStringList,errorType);	if(errorType == eMaxWindows)	{		GetIndString(narrativeText,rStringList,errorType + 1);		StandardAlert(kAlertCautionAlert,labelText,narrativeText,&paramRec,&itemHit);		DisposeModalFilterUPP(eventFilterUPP);	}	else	{		StandardAlert(kAlertStopAlert,labelText,0,&paramRec,&itemHit);		ExitToShell();	}	}// ******************************************************************************* eventFilterBoolean  eventFilter(DialogPtr dialogPtr,EventRecord *eventStrucPtr,SInt16 *itemHit){	Boolean	handledEvent = false;		if((eventStrucPtr->what == updateEvt) && 		 ((WindowRef) eventStrucPtr->message != GetDialogWindow(dialogPtr)))	{		doUpdate(eventStrucPtr);	}	return handledEvent;}// *******************************************************************************************