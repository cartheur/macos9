// *******************************************************************************************// Windows2.c                                                              CLASSIC EVENT MODEL// *******************************************************************************************// // This program demonstrates the following Window Manager features and functions introduced// with Mac OS 8.5:// // ╔	Creating floating windows and document windows using CreateNewWindow.//// ╔	Saving document windows and their associated data to a 'wind' resource.//// ╔	Creating document windows from 'wind' resources using CreateWindowFromResource.//// ╔	Managing windows in a floating windows environment.//// ╔	Setting and getting a window's property.//// ╔	Showing and hiding windows using TransitionWindow.//// ╔	Displaying window proxy icons.//// The program also demonstrates the creation of the system-managed Window menu introduced// with Carbon and, on Mac OS X, a partial implementation of live window resizing.//// Those aspects of the newer Window Manager features not demonstrated in this program (full// implementation of window proxy icons and window path pop-up menus) are demonstrated at the// demonstration program Files (Chapter 18).//// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	An 'MBAR' resource, and 'MENU' resources for Apple, File, Edit, Document Windows and//		Floating Windows menus (preload, non-purgeable).//// ╔	'TEXT' resources for the document windows (non-purgeable).  //// ╔	'PICT' resources for the floating windows (non-purgeable).//// ╔	An 'ALRT' resource (purgeable), plus associated 'DITL', 'alrx', and 'dftb' resources//		(all purgeable), for a movable modal alert invoked when the user chooses the About//		Windows2... item from the	Apple/Application menu.//// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// In addition, the program itself creates a 'wind' resource, and saves it to the resource// fork of the file titled "Document", when the user chooses CreateNewWindow from the // Document Windows menu.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar				128#define mFile						129#define  iQuit					12#define rAboutAlert			128#define rText						128#define rColoursPicture	128#define rToolsPicture		129#define rWind						128#define MIN(a,b) 				((a) < (b) ? (a) : (b))// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии typedefstypedef struct{	TEHandle	editStrucHdl;} docStructure, **docStructureHandle;// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean		gRunningOnX = false;SInt16		gDocResFileRefNum;WindowRef	gColoursFloatingWindowRef;WindowRef	gToolsFloatingWindowRef;Boolean		gDone;// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid		main												(void);void		doPreliminaries							(void);OSErr		quitAppEventHandler					(AppleEvent *,AppleEvent *,SInt32);void		doEvents										(EventRecord *);void		doMouseDown									(EventRecord *);void		doUpdate										(EventRecord *);void		doUpdateDocumentWindow			(WindowRef);void		doActivate									(EventRecord *);void		doActivateDocumentWindow		(WindowRef,Boolean);void		doOSEvent										(EventRecord *);void		doAdjustMenus								(void);void		doMenuChoice								(SInt32);OSErr		doCreateNewWindow						(void);OSErr		doSaveWindow								(WindowRef);OSErr		doCreateWindowFromResource	(void);OSErr		doCreateFloatingWindows			(void);void		doCloseWindow								(WindowRef);void		doErrorAlert								(SInt16);void		doConcatPStrings						(Str255,Str255);// ************************************************************************************** mainvoid  main(void){	MenuBarHandle				menubarHdl;	SInt32							response;	MenuRef							menuRef;	OSErr								osError;	SInt16							numberOfItems, a;	MenuCommand					menuCommandID;	FSSpec							fileSpecTemp;	EventRecord					eventStructure;	SInt32							sleepTime;	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	UInt32							actualSize;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииии set up menu bar and menus, customise Window menu if running on OS X	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		ExitToShell();	SetMenuBar(menubarHdl);	CreateStandardWindowMenu(0,&menuRef);	InsertMenu(menuRef,0);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}		gRunningOnX = true;	}	// иииииииииииииииии open resource fork of file "Windows2 Document" and store file reference number	osError = FSMakeFSSpec(0,0,"\pWindows2 Document",&fileSpecTemp);	if(osError == noErr)		gDocResFileRefNum = FSpOpenResFile(&fileSpecTemp,fsWrPerm);	else		doErrorAlert(osError);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии create floating windows	if(osError = doCreateFloatingWindows())		doErrorAlert(osError);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop	gDone = false;	sleepTime = GetCaretTime();	while(!gDone)	{		if(WaitNextEvent(everyEvent,&eventStructure,sleepTime,NULL))			doEvents(&eventStructure);		else		{			if(eventStructure.what == nullEvent)			{				if(windowRef = FrontNonFloatingWindow())				{					if(!(GetWindowProperty(windowRef,0,'docs',sizeof(docStrucHdl),&actualSize,																 &docStrucHdl)))						TEIdle((*docStrucHdl)->editStrucHdl);				}			}		}	}}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(128);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	switch(eventStrucPtr->what)	{		case mouseDown:			doMouseDown(eventStrucPtr);			break;		case keyDown:			if((eventStrucPtr->modifiers & cmdKey) != 0)			{				doAdjustMenus();				doMenuChoice(MenuEvent(eventStrucPtr));			}			break;		case updateEvt:			doUpdate(eventStrucPtr);			break;		case activateEvt:			doActivate(eventStrucPtr);			break;		case osEvt:			doOSEvent(eventStrucPtr);			break;	}}// ******************************************************************************* doMouseDownvoid	doMouseDown(EventRecord *eventStrucPtr){	WindowRef				windowRef;	WindowPartCode	partCode, zoomPart;	SInt32					menuChoice;	WindowClass			windowClass;	BitMap					screenBits;	Rect						portRect, mainScreenRect;	Point						standardStateHeightAndWidth;	partCode = FindWindow(eventStrucPtr->where,&windowRef);		switch(partCode)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case inMenuBar:			doAdjustMenus();			doMenuChoice(MenuSelect(eventStrucPtr->where));			break;		case inContent:			GetWindowClass(windowRef,&windowClass);			if(windowClass == kFloatingWindowClass)			{				if(windowRef != FrontWindow())					SelectWindow(windowRef);				else				{					if(windowRef == gColoursFloatingWindowRef)						; // Appropriate action for Colours floating window here. 					else if(windowRef == gToolsFloatingWindowRef)						; // Appropriate action for Tools floating window here.				}			}			else			{					if(windowRef != FrontNonFloatingWindow())					SelectWindow(windowRef);				else					; // Appropriate action for active document window here.			}			break;		case inDrag:			DragWindow(windowRef,eventStrucPtr->where,NULL);			break;		case inGoAway:			GetWindowClass(windowRef,&windowClass);			if(windowClass == kFloatingWindowClass)			{				if(TrackGoAway(windowRef,eventStrucPtr->where) == true)					TransitionWindow(windowRef,kWindowZoomTransitionEffect,													 kWindowHideTransitionAction,NULL);			}			else				if(TrackGoAway(windowRef,eventStrucPtr->where) == true)					doCloseWindow(windowRef);			break;		case inGrow:			ResizeWindow(windowRef,eventStrucPtr->where,NULL,NULL);			GetWindowPortBounds(windowRef,&portRect);			InvalWindowRect(windowRef,&portRect);			break;		case inZoomIn:		case inZoomOut:			mainScreenRect = GetQDGlobalsScreenBits(&screenBits)->bounds;			standardStateHeightAndWidth.v = mainScreenRect.bottom - 100;			standardStateHeightAndWidth.h = 600;			if(IsWindowInStandardState(windowRef,&standardStateHeightAndWidth,NULL))				zoomPart = inZoomIn;			else				zoomPart = inZoomOut;			if(TrackBox(windowRef,eventStrucPtr->where,partCode))				ZoomWindowIdeal(windowRef,zoomPart,&standardStateHeightAndWidth);			break;	}}// ********************************************************************************** doUpdatevoid  doUpdate(EventRecord *eventStrucPtr){	GrafPtr		oldPort;	WindowRef	windowRef;	GetPort(&oldPort);	windowRef = (WindowRef) eventStrucPtr->message;	BeginUpdate(windowRef);	SetPortWindowPort(windowRef);	doUpdateDocumentWindow(windowRef);	EndUpdate(windowRef);	SetPort(oldPort);}// ******************************************************************** doUpdateDocumentWindowvoid  doUpdateDocumentWindow(WindowRef windowRef){	RgnHandle						visibleRegionHdl = NewRgn();	Rect 								contentRect;	OSStatus						osError;	UInt32							actualSize;	docStructureHandle	docStrucHdl;	TEHandle						editStrucHdl; 	GetPortVisibleRegion(GetWindowPort(windowRef),visibleRegionHdl);	EraseRgn(visibleRegionHdl);	DrawGrowIcon(windowRef);	if(!(osError = GetWindowProperty(windowRef,0,'docs',sizeof(docStrucHdl),&actualSize,																	 &docStrucHdl)))	{		GetWindowPortBounds(windowRef,&contentRect);		InsetRect(&contentRect,3,3);		contentRect.right -= 15;		contentRect.bottom -= 15;		editStrucHdl = (*docStrucHdl)->editStrucHdl;		(*editStrucHdl)->destRect = (*editStrucHdl)->viewRect = contentRect;		TECalText(editStrucHdl);		TEUpdate(&contentRect,(*docStrucHdl)->editStrucHdl);	}}// ******************************************************************************** doActivatevoid  doActivate(EventRecord *eventStrucPtr){	WindowRef	windowRef;	Boolean		becomingActive;	windowRef = (WindowRef) eventStrucPtr->message;	becomingActive = ((eventStrucPtr->modifiers & activeFlag) == activeFlag);	doActivateDocumentWindow(windowRef,becomingActive);}// ****************************************************************** doActivateDocumentWindowvoid  doActivateDocumentWindow(WindowRef windowRef,Boolean becomingActive){	docStructureHandle	docStrucHdl;	UInt32							actualSize;	OSStatus						osError;	if(!(osError = GetWindowProperty(windowRef,0,'docs',sizeof(docStrucHdl),&actualSize,																	 &docStrucHdl)))	{		if(becomingActive)			TEActivate((*docStrucHdl)->editStrucHdl);		else			TEDeactivate((*docStrucHdl)->editStrucHdl);	}}// ********************************************************************************* doOSEventvoid	doOSEvent(EventRecord *eventStrucPtr){	switch((eventStrucPtr->message >> 24) & 0x000000FF)	{		case suspendResumeMessage:			if((eventStrucPtr->message & resumeFlag) == 1)				SetThemeCursor(kThemeArrowCursor);			break;	}}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef				floatMenuRef;	Boolean				isVisible;	MenuItemIndex	menuItem;	isVisible = IsWindowVisible(gColoursFloatingWindowRef);	GetIndMenuItemWithCommandID(NULL,'fcol',1,&floatMenuRef,&menuItem);	CheckMenuItem(floatMenuRef,menuItem,isVisible);	isVisible = IsWindowVisible(gToolsFloatingWindowRef);	GetIndMenuItemWithCommandID(NULL,'ftoo',1,&floatMenuRef,&menuItem);	CheckMenuItem(floatMenuRef,menuItem,isVisible);	DrawMenuBar();}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;	OSErr					osError;	MenuCommand		commandID;	menuID = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	osError = GetMenuItemCommandID(GetMenuRef(menuID),menuItem,&commandID);	if(osError == noErr && commandID != 0)	{		switch(commandID)		{			case 'abou':				Alert(rAboutAlert,NULL);				break;			case 'quit':				gDone = true;				break;			case 'cwin':				if(osError = doCreateNewWindow())					doErrorAlert(osError);				break;			case 'cwir':				if(osError = doCreateWindowFromResource())					doErrorAlert(osError);				break;			case 'fcol':				if(IsWindowVisible(gColoursFloatingWindowRef))					TransitionWindow(gColoursFloatingWindowRef,kWindowZoomTransitionEffect,													 kWindowHideTransitionAction,NULL);				else					TransitionWindow(gColoursFloatingWindowRef,kWindowZoomTransitionEffect,													 kWindowShowTransitionAction,NULL);				break;			case 'ftoo':				if(IsWindowVisible(gToolsFloatingWindowRef))					TransitionWindow(gToolsFloatingWindowRef,kWindowZoomTransitionEffect,													 kWindowHideTransitionAction,NULL);				else					TransitionWindow(gToolsFloatingWindowRef,kWindowZoomTransitionEffect,													 kWindowShowTransitionAction,NULL);				break;		}	}	HiliteMenu(0);}// ******************************************************************* doCreateFloatingWindowsOSErr  doCreateFloatingWindows(void){	Rect			contentRect;	OSStatus	osError;	PicHandle	pictureHdl;	SetRect(&contentRect,102,59,391,132);	if(!(osError = CreateNewWindow(kFloatingWindowClass,																 kWindowStandardFloatingAttributes | 																 kWindowSideTitlebarAttribute,																 &contentRect,&gColoursFloatingWindowRef)))	{		if(pictureHdl = GetPicture(rColoursPicture))			SetWindowPic(gColoursFloatingWindowRef,pictureHdl);		osError = TransitionWindow(gColoursFloatingWindowRef,kWindowZoomTransitionEffect,															 kWindowShowTransitionAction,NULL);	}	if(osError != noErr)		return osError;	SetRect(&contentRect,149,88,213,280);	if(!(osError = CreateNewWindow(kFloatingWindowClass,																 kWindowStandardFloatingAttributes,																 &contentRect,&gToolsFloatingWindowRef)))	{		if(pictureHdl = GetPicture(rToolsPicture))			SetWindowPic(gToolsFloatingWindowRef,pictureHdl);		osError = TransitionWindow(gToolsFloatingWindowRef,kWindowZoomTransitionEffect,															 kWindowShowTransitionAction,NULL);	}	return osError;				}// ************************************************************************* doCreateNewWindowOSErr  doCreateNewWindow(void){	Rect								contentRect;	OSStatus						osError;	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	Handle							textHdl;	MenuRef							menuRef;	SetRect(&contentRect,10,40,470,340);	do	{		if(osError = CreateNewWindow(kDocumentWindowClass,kWindowStandardDocumentAttributes,																 &contentRect,&windowRef))			break;		if(gRunningOnX)			ChangeWindowAttributes(windowRef,kWindowLiveResizeAttribute,0);		if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))		{			osError = MemError();			break;		}		if(osError = SetWindowProperty(windowRef,0,'docs',sizeof(docStructure),																	 &docStrucHdl))			break;		SetPortWindowPort(windowRef);		UseThemeFont(kThemeSmallSystemFont,smSystemScript);		textHdl = GetResource('TEXT',rText);		osError = ResError();		if(osError != noErr)			break;		OffsetRect(&contentRect,-contentRect.left,-contentRect.top);		InsetRect(&contentRect,3,3);		contentRect.right -= 15;		contentRect.bottom -= 15;		(*docStrucHdl)->editStrucHdl = TENew(&contentRect,&contentRect);		TEInsert(*textHdl,GetHandleSize(textHdl),(*docStrucHdl)->editStrucHdl);		SetWTitle(windowRef,"\pCreateNewWindow");				if(osError = SetWindowProxyCreatorAndType(windowRef,0,'TEXT',kOnSystemDisk))			break;		if(osError = SetWindowModified(windowRef,false))			break;		if(osError = RepositionWindow(windowRef,NULL,kWindowCascadeOnMainScreen))			break;		if(osError = TransitionWindow(windowRef,kWindowZoomTransitionEffect,																	kWindowShowTransitionAction,NULL))			break;		if(osError = doSaveWindow(windowRef))			break;	} while(false);	if(osError)	{		if(windowRef)			DisposeWindow(windowRef);					if(docStrucHdl)			DisposeHandle((Handle) docStrucHdl);	}	return osError;}// ****************************************************************************** doSaveWindowOSErr  doSaveWindow(WindowRef windowRef){	SInt16							oldResFileRefNum;	Collection					collection = NULL;	OSStatus						osError;	docStructureHandle	docStrucHdl;	UInt32							actualSize;	Handle							flatCollectHdl, flatCollectResHdl, existingResHdl;	oldResFileRefNum = CurResFile();	UseResFile(gDocResFileRefNum);	do	{		if(!(collection = NewCollection()))		{			osError = MemError();			break;		}				if(osError = StoreWindowIntoCollection(windowRef,collection))			break;					if(osError = GetWindowProperty(windowRef,0,'docs',sizeof(docStrucHdl),&actualSize,																	 &docStrucHdl))			break;					if(osError = AddCollectionItemHdl(collection,'TEXT',1,																			(*(*docStrucHdl)->editStrucHdl)->hText))			break;		if(!(flatCollectHdl = NewHandle(0)))		{			osError = MemError();			break;		}		if(osError = FlattenCollectionToHdl(collection,flatCollectHdl))			break;		existingResHdl = Get1Resource('wind',rWind);		osError = ResError();		if(osError != noErr && osError != resNotFound)			break;		if(existingResHdl != NULL)			RemoveResource(existingResHdl);		osError = ResError();		if(osError != noErr)			break;		AddResource(flatCollectHdl,'wind',rWind,"\p");		osError = ResError();		if(osError != noErr)			break;		flatCollectResHdl = flatCollectHdl;		flatCollectHdl = NULL;		WriteResource(flatCollectResHdl);		osError = ResError();		if(osError != noErr)			break;		UpdateResFile(gDocResFileRefNum);		osError = ResError();		if(osError != noErr)			break;	} while(false);	if(collection)		DisposeCollection(collection);	if(flatCollectHdl)		DisposeHandle(flatCollectHdl);	if(flatCollectResHdl)		ReleaseResource(flatCollectResHdl);	UseResFile(oldResFileRefNum);	return osError;}// **************************************************************** doCreateWindowFromResourceOSErr  doCreateWindowFromResource(void){	SInt16							oldResFileRefNum;	OSStatus						osError;	WindowRef						windowRef;	Collection					unflattenedCollection = NULL;	Handle							windResHdl;	docStructureHandle	docStrucHdl;	SInt32							dataSize = 0;	Handle							textHdl;	Rect								contentRect;	oldResFileRefNum = CurResFile();	UseResFile(gDocResFileRefNum);	do	{		if(osError = CreateWindowFromResource(rWind,&windowRef))			break;		if(gRunningOnX)			ChangeWindowAttributes(windowRef,kWindowLiveResizeAttribute,0);		if(!(unflattenedCollection = NewCollection()))		{			osError = MemError();			break;		}		windResHdl = GetResource('wind',rWind);		osError = ResError();		if(osError != noErr)			break;		if(osError = UnflattenCollectionFromHdl(unflattenedCollection,windResHdl))			break;		if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))		{			osError = MemError();			break;		}		if(osError = GetCollectionItem(unflattenedCollection,'TEXT',1,&dataSize,																	 kCollectionDontWantData))			break;		if(!(textHdl = NewHandle(dataSize)))		{			osError = MemError();			break;		}		if(osError = GetCollectionItem(unflattenedCollection,'TEXT',1,kCollectionDontWantSize,																	 *textHdl))			break;		GetWindowPortBounds(windowRef,&contentRect);		contentRect.right -= 15;		contentRect.bottom -= 15;		SetPortWindowPort(windowRef);		UseThemeFont(kThemeSmallSystemFont,smSystemScript);		(*docStrucHdl)->editStrucHdl = TENew(&contentRect,&contentRect);		TEInsert(*textHdl,dataSize,(*docStrucHdl)->editStrucHdl);		if(osError = SetWindowProperty(windowRef,0,'docs',sizeof(docStrucHdl),&docStrucHdl))			break;		SetWTitle(windowRef,"\pCreateWindowFromResource");		if(osError = SetWindowProxyCreatorAndType(windowRef,0,'TEXT',kOnSystemDisk))			break;		if(osError = SetWindowModified(windowRef,false))			break;		if(osError = RepositionWindow(windowRef,NULL,kWindowCascadeOnMainScreen))			break;		if(osError = TransitionWindow(windowRef,kWindowZoomTransitionEffect,																	kWindowShowTransitionAction,NULL))			break;	} while(false);	if(unflattenedCollection)		DisposeCollection(unflattenedCollection);	if(windResHdl)		ReleaseResource(windResHdl);	UseResFile(oldResFileRefNum);	return osError;}// ***************************************************************************** doCloseWindowvoid  doCloseWindow(WindowRef windowRef){	OSStatus						osError;	docStructureHandle	docStrucHdl;	UInt32							actualSize;	do	{		if(osError = TransitionWindow(windowRef,kWindowZoomTransitionEffect,																	kWindowHideTransitionAction,NULL))		break;		if(osError = GetWindowProperty(windowRef,0,'docs',sizeof(docStrucHdl),&actualSize,																	 &docStrucHdl))		break;	} while(false);	if(osError)		doErrorAlert(osError);	if((*docStrucHdl)->editStrucHdl)		TEDispose((*docStrucHdl)->editStrucHdl);	if(docStrucHdl)		DisposeHandle((Handle) docStrucHdl);	DisposeWindow(windowRef);}// ****************************************************************************** doErrorAlertvoid  doErrorAlert(SInt16 errorCode){	Str255	errorCodeString;	Str255	theString = "\pAn error occurred.  The error code is ";	SInt16	itemHit;	NumToString((SInt32) errorCode,errorCodeString);	doConcatPStrings(theString,errorCodeString);	StandardAlert(kAlertStopAlert,theString,NULL,NULL,&itemHit);	ExitToShell();}// ************************************************************************** doConcatPStringsvoid  doConcatPStrings(Str255 targetString,Str255 appendString){	SInt16	appendLength;	appendLength = MIN(appendString[0],255 - targetString[0]);	if(appendLength > 0)	{		BlockMoveData(appendString+1,targetString+targetString[0]+1,(SInt32) appendLength);		targetString[0] += appendLength;	}}// *******************************************************************************************