// *******************************************************************************************// Drag.c// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include "Drag.h"// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesControlActionUPP				gScrollActionFunctionUPP;TEClickLoopUPP					gCustomClickLoopUPP;DragTrackingHandlerUPP	gDragTrackingHandlerUPP;DragReceiveHandlerUPP		gDragReceiveHandlerUPP;Boolean									gRunningOnX							= false;SInt16									gNumberOfWindows				= 0;SInt16 									gOldControlValue;Boolean									gEnableDragUndoRedoItem = false;Boolean									gUndoFlag;// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	EventTypeSpec	applicationEvents[] =	{ { kEventClassApplication, kEventAppActivated    },																				{ kEventClassApplication, kEventAppDeactivated  },																				{ kEventClassCommand,     kEventProcessCommand  },																				{ kEventClassMenu,        kEventMenuEnableItems },																				{ kEventClassMouse,       kEventMouseMoved      } };	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииии create universal procedure pointers	gScrollActionFunctionUPP = NewControlActionUPP((ControlActionProcPtr) scrollActionFunction);	gCustomClickLoopUPP      = NewTEClickLoopUPP((TEClickLoopProcPtr) customClickLoop);	gDragTrackingHandlerUPP  = NewDragTrackingHandlerUPP((DragTrackingHandlerProcPtr)																											 dragTrackingHandler);	gDragReceiveHandlerUPP   = NewDragReceiveHandlerUPP((DragReceiveHandlerProcPtr)																											dragReceiveHandler);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		doErrorAlert(eMenuBar);	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);		}		gRunningOnX = true;	}	else	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)			SetMenuItemCommandID(menuRef,iQuit,kHICommandQuit);	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииии install application event handler  	InstallApplicationEventHandler(NewEventHandlerUPP((EventHandlerProcPtr) appEventHandler),																 GetEventTypeCount(applicationEvents),applicationEvents,																 0,NULL);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии install a timer	InstallEventLoopTimer(GetCurrentEventLoop(),0,TicksToEventTime(GetCaretTime()),												NewEventLoopTimerUPP((EventLoopTimerProcPtr) doIdle),NULL,												NULL);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open window	doNewDocWindow();	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии run application event loop	RunApplicationEventLoop();}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	MoreMasterPointers(192);	InitCursor();}// *************************************************************************** appEventHandlerOSStatus  appEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,													void * userData){	OSStatus			result = eventNotHandledErr;	UInt32				eventClass;	UInt32				eventKind;	HICommand			hiCommand;	MenuID				menuID;	MenuItemIndex	menuItem;	WindowClass		windowClass;	eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	switch(eventClass)	{		case kEventClassApplication:			if(eventKind == kEventAppActivated)				SetThemeCursor(kThemeArrowCursor);			break;		case kEventClassCommand:			if(eventKind == kEventProcessCommand)			{				GetEventParameter(eventRef,kEventParamDirectObject,typeHICommand,NULL,													sizeof(HICommand),NULL,&hiCommand);				menuID = GetMenuID(hiCommand.menu.menuRef);				menuItem = hiCommand.menu.menuItemIndex;				if((hiCommand.commandID != kHICommandQuit) && 					 (menuID >= mAppleApplication && menuID <= mEdit))				{					doMenuChoice(menuID,menuItem);					result = noErr;				}			}			break;		case kEventClassMenu:			if(eventKind == kEventMenuEnableItems)			{				GetWindowClass(FrontWindow(),&windowClass);				if(windowClass == kDocumentWindowClass)					doAdjustMenus();				result = noErr;			}			break;		case kEventClassMouse:			if(eventKind == kEventMouseMoved)			{				GetWindowClass(FrontWindow(),&windowClass);				if(windowClass == kDocumentWindowClass)					doAdjustCursor(FrontWindow());				result = noErr;			}			break;	}	return result;}// ************************************************************************ windowEventHandlerOSStatus  windowEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,														 void* userData){	OSStatus				result = eventNotHandledErr;	UInt32					eventClass;	UInt32					eventKind;	WindowRef				windowRef;	UInt32					modifiers; 	Point						mouseLocation;	Boolean					shiftKeyDown = false;	EventRecord			eventRecord;	ControlRef			controlRef;	ControlPartCode	controlPartCode;	SInt8						charCode;	eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	switch(eventClass)	{		case kEventClassWindow:																							 // event class window			GetEventParameter(eventRef,kEventParamDirectObject,typeWindowRef,NULL,sizeof(windowRef),												NULL,&windowRef);			switch(eventKind)			{				case kEventWindowDrawContent:					doDrawContent(windowRef);					result = noErr;					break;				case kEventWindowActivated:					doActivateDeactivate(windowRef,true);					result = noErr;					break;				case kEventWindowDeactivated:					doActivateDeactivate(windowRef,false);					result = noErr;					break;				case kEventWindowClickContentRgn:					SetPortWindowPort(FrontWindow());					GetMouse(&mouseLocation);					GetEventParameter(eventRef,kEventParamKeyModifiers,typeUInt32,NULL,														sizeof(modifiers),NULL,&modifiers);					if(modifiers & shiftKey)						shiftKeyDown = true;					ConvertEventRefToEventRecord(eventRef,&eventRecord);					doInContent(mouseLocation,&eventRecord,shiftKeyDown);					result = noErr;					break;				case kEventWindowClose:					doCloseWindow(windowRef);					result = noErr;					break;			}			break;		case kEventClassMouse:																								// event class mouse			switch(eventKind)			{				case kEventMouseDown:					GetEventParameter(eventRef,kEventParamMouseLocation,typeQDPoint,NULL,														sizeof(mouseLocation),NULL,&mouseLocation);					SetPortWindowPort(FrontWindow());					GlobalToLocal(&mouseLocation);					controlRef = FindControlUnderMouse(mouseLocation,FrontWindow(),&controlPartCode);					if(controlRef)					{						gOldControlValue = GetControlValue(controlRef);						TrackControl(controlRef,mouseLocation,gScrollActionFunctionUPP);						result = noErr;					}				break;			}			break;		case kEventClassKeyboard:																					 // event class keyboard			switch(eventKind)			{				case kEventRawKeyDown:				case kEventRawKeyRepeat: 					GetEventParameter(eventRef,kEventParamKeyMacCharCodes,typeChar,NULL,														sizeof(charCode),NULL,&charCode);					GetEventParameter(eventRef,kEventParamKeyModifiers,typeUInt32,NULL,														sizeof(modifiers),NULL,&modifiers);					if((modifiers & cmdKey) == 0)						doKeyEvent(charCode);					result = noErr;					break;			}			break;	}	return result;}// ************************************************************************************ doIdlevoid  doIdle(void){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	windowRef = FrontWindow();	if(GetWindowKind(windowRef) == kApplicationWindowKind)	{		docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));		if(docStrucPtr != NULL)			TEIdle(docStrucPtr->textEditStrucHdl);	}}// ******************************************************************************** doKeyEventvoid  doKeyEvent(SInt8 charCode){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt16							selectionLength;	if(charCode <= kEscape && charCode != kBackSpace && charCode != kReturn)		return;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	gEnableDragUndoRedoItem = false;	if(charCode == kTab)	{		// Do tab key handling here if required.	}	else if(charCode == kForwardDelete)	{		selectionLength = doGetSelectLength(textEditStrucHdl);		if(selectionLength == 0)			(*textEditStrucHdl)->selEnd += 1;		TEDelete(textEditStrucHdl);		doAdjustScrollbar(windowRef);	}	else	{		selectionLength = doGetSelectLength(textEditStrucHdl);		if(((*textEditStrucHdl)->teLength - selectionLength + 1) < kMaxTELength)		{			TEKey(charCode,textEditStrucHdl);			doAdjustScrollbar(windowRef);		}		else			doErrorAlert(eExceedChara);	}}// ********************************************************************** scrollActionFunctionvoid  scrollActionFunction(ControlRef controlRef,SInt16 partCode){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt16							linesToScroll;	SInt16							controlValue, controlMax;	windowRef = GetControlOwner(controlRef);	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));;	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	controlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	if(partCode)	{		if(partCode != kControlIndicatorPart)		{			switch(partCode)			{				case kControlUpButtonPart:				case kControlDownButtonPart:					linesToScroll = 1;					break;								case kControlPageUpPart:				case kControlPageDownPart:					linesToScroll = (((*textEditStrucHdl)->viewRect.bottom - 													(*textEditStrucHdl)->viewRect.top) /													(*textEditStrucHdl)->lineHeight) - 1;					break;			}			if((partCode == kControlDownButtonPart) || (partCode == kControlPageDownPart))				linesToScroll = -linesToScroll;			linesToScroll = controlValue - linesToScroll;			if(linesToScroll < 0)				linesToScroll = 0;			else if(linesToScroll > controlMax)				linesToScroll = controlMax;			SetControlValue(controlRef,linesToScroll);			linesToScroll = controlValue - linesToScroll;		}		else		{			linesToScroll = gOldControlValue - controlValue;			gOldControlValue = controlValue;		}		if(linesToScroll != 0)			TEScroll(0,linesToScroll * (*textEditStrucHdl)->lineHeight,textEditStrucHdl);	}}// ******************************************************************************* doInContentvoid  doInContent(Point mouseLocation,EventRecord * eventStrucPtr,Boolean shiftKeyDown){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	RgnHandle						hiliteRgn;	OSErr								osError;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) GetWRefCon(windowRef);	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	if(PtInRect(mouseLocation,&(*textEditStrucHdl)->viewRect))	{		hiliteRgn = NewRgn();				TEGetHiliteRgn(hiliteRgn,textEditStrucHdl);		if(!EmptyRgn(hiliteRgn) && PtInRgn(mouseLocation,hiliteRgn))		{			if(WaitMouseMoved(mouseLocation))			{				osError = doStartDrag(eventStrucPtr,hiliteRgn,textEditStrucHdl);				if(osError != noErr)					doErrorAlert(eDrag);			}			}		else		{			TEClick(mouseLocation,shiftKeyDown,textEditStrucHdl);			gEnableDragUndoRedoItem = false;				} 		DisposeRgn(hiliteRgn);	}}// ***************************************************************************** doDrawContentvoid	doDrawContent(WindowRef windowRef){	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	GrafPtr							oldPort;	RgnHandle						visibleRegionHdl = NewRgn();	Rect								portRect;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;		GetPort(&oldPort);	SetPortWindowPort(windowRef);	GetPortVisibleRegion(GetWindowPort(windowRef),visibleRegionHdl);  EraseRgn(visibleRegionHdl);	UpdateControls(windowRef,visibleRegionHdl);	GetWindowPortBounds(windowRef,&portRect);	TEUpdate(&(*textEditStrucHdl)->viewRect,textEditStrucHdl);	DisposeRgn(visibleRegionHdl);	SetPort(oldPort);}// *********************************************************************** doActivateDocWindowvoid  doActivateDeactivate(WindowRef windowRef,Boolean becomingActive){	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	if(becomingActive)	{		SetPortWindowPort(windowRef);		(*textEditStrucHdl)->viewRect.bottom = ((((*textEditStrucHdl)->viewRect.bottom -																						(*textEditStrucHdl)->viewRect.top) / 																						(*textEditStrucHdl)->lineHeight) * 																						(*textEditStrucHdl)->lineHeight) + 																						(*textEditStrucHdl)->viewRect.top;		(*textEditStrucHdl)->destRect.bottom = (*textEditStrucHdl)->viewRect.bottom;		TEActivate(textEditStrucHdl);		ActivateControl(docStrucPtr->vScrollbarRef);		doAdjustScrollbar(windowRef);		doAdjustCursor(windowRef);	}	else	{		TEDeactivate(textEditStrucHdl);		DeactivateControl(docStrucPtr->vScrollbarRef);	}}// **************************************************************************** doNewDocWindowWindowRef  doNewDocWindow(void){	WindowRef 					windowRef;	OSStatus						osError;	Rect								contentRect = { 100,100,400,595 };	WindowAttributes		attributes  = kWindowStandardHandlerAttribute |																		kWindowStandardDocumentAttributes;	docStructurePointer	docStrucPtr;	Rect								portRect, destAndViewRect;	EventTypeSpec		windowEvents[] = { { kEventClassWindow,	  kEventWindowDrawContent     },																		 { kEventClassWindow,	  kEventWindowActivated       },																		 { kEventClassWindow,  	kEventWindowDeactivated     },																		 { kEventClassWindow,	  kEventWindowClickContentRgn	},																		 { kEventClassWindow,   kEventWindowClose           },																		 { kEventClassMouse,    kEventMouseDown             },																		 { kEventClassKeyboard, kEventRawKeyDown            },																		 { kEventClassKeyboard, kEventRawKeyRepeat          } };	osError = CreateNewWindow(kDocumentWindowClass,attributes,&contentRect,&windowRef);	if(osError != noErr)	{		doErrorAlert(eWindow);		return NULL;	}	ChangeWindowAttributes(windowRef,0,kWindowResizableAttribute);	RepositionWindow(windowRef,NULL,kWindowCascadeOnMainScreen);	SetWTitle(windowRef,"\puntitled");	SetPortWindowPort(windowRef);	TextSize(10);	if(!(docStrucPtr = (docStructurePointer) NewPtr(sizeof(docStructure))))	{		doErrorAlert(eDocStructure);		return NULL;	}	SetWRefCon(windowRef,(SInt32) docStrucPtr);	SetWindowProxyCreatorAndType(windowRef,0,'TEXT',kUserDomain);	InstallWindowEventHandler(windowRef,doGetHandlerUPP(),GetEventTypeCount(windowEvents),														windowEvents,0,NULL);	gNumberOfWindows ++;	docStrucPtr->windowRef     = windowRef;	docStrucPtr->windowTouched = false;	docStrucPtr->preDragText   = NULL;	docStrucPtr->vScrollbarRef = GetNewControl(rVScrollbar,windowRef);		GetWindowPortBounds(windowRef,&portRect);	destAndViewRect = portRect;	destAndViewRect.right -= 15;	InsetRect(&destAndViewRect,2,2);	if(!(docStrucPtr->textEditStrucHdl = TENew(&destAndViewRect,&destAndViewRect)))	{		DisposeWindow(windowRef);		gNumberOfWindows --;		DisposePtr((Ptr) docStrucPtr);		doErrorAlert(eTextEdit);		return NULL;	}	TESetClickLoop(gCustomClickLoopUPP,docStrucPtr->textEditStrucHdl);	TEAutoView(true,docStrucPtr->textEditStrucHdl);	TEFeatureFlag(teFOutlineHilite,teBitSet,docStrucPtr->textEditStrucHdl);	if(osError = InstallTrackingHandler(gDragTrackingHandlerUPP,windowRef,docStrucPtr))	{		DisposeWindow(windowRef);		gNumberOfWindows --;		DisposePtr((Ptr) docStrucPtr);		doErrorAlert(eDragHandler);		return NULL;	}	if(osError = InstallReceiveHandler(gDragReceiveHandlerUPP,windowRef,docStrucPtr))	{		RemoveTrackingHandler(gDragTrackingHandlerUPP,windowRef);		DisposeWindow(windowRef);		gNumberOfWindows --;		DisposePtr((Ptr) docStrucPtr);		doErrorAlert(eDragHandler);		return NULL;	}	ShowWindow(windowRef);	return windowRef;}// *************************************************************************** doGetHandlerUPPEventHandlerUPP  doGetHandlerUPP(void){	static EventHandlerUPP	windowEventHandlerUPP;	if(windowEventHandlerUPP == NULL)		windowEventHandlerUPP = NewEventHandlerUPP((EventHandlerProcPtr) windowEventHandler);	return windowEventHandlerUPP;}// *************************************************************************** customClickLoopBoolean  customClickLoop(void){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	GrafPtr							oldPort;	RgnHandle						oldClip;	Rect								tempRect, portRect;	Point								mouseXY;	SInt16							linesToScroll = 0;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	oldClip = NewRgn();	GetClip(oldClip);	SetRect(&tempRect,-32767,-32767,32767,32767);	ClipRect(&tempRect);	GetMouse(&mouseXY);	GetWindowPortBounds(windowRef,&portRect);	if(mouseXY.v < portRect.top)	{		linesToScroll = 1;		doSetScrollBarValue(docStrucPtr->vScrollbarRef,&linesToScroll);		if(linesToScroll != 0)			TEScroll(0,linesToScroll * ((*textEditStrucHdl)->lineHeight),textEditStrucHdl);	}	else if(mouseXY.v > portRect.bottom)	{		linesToScroll = -1;		doSetScrollBarValue(docStrucPtr->vScrollbarRef,&linesToScroll);		if(linesToScroll != 0)			TEScroll(0,linesToScroll * ((*textEditStrucHdl)->lineHeight),textEditStrucHdl);	}	SetClip(oldClip);	DisposeRgn(oldClip);	SetPort(oldPort);	return true;}// *********************************************************************** doSetScrollBarValuevoid  doSetScrollBarValue(ControlRef controlRef,SInt16 *linesToScroll){	SInt16	controlValue, controlMax;	controlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	*linesToScroll = controlValue - *linesToScroll;	if(*linesToScroll < 0)		*linesToScroll = 0;	else if(*linesToScroll > controlMax)		*linesToScroll = controlMax;	SetControlValue(controlRef,*linesToScroll);	*linesToScroll = controlValue - *linesToScroll;}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef							fileMenuRef, editMenuRef;	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	ScrapRef						scrapRef;	OSStatus						osError;	ScrapFlavorFlags		scrapFlavorFlags;	fileMenuRef = GetMenuRef(mFile);	editMenuRef = GetMenuRef(mEdit);	if(gNumberOfWindows > 0)	{		windowRef = FrontWindow();		docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));;		textEditStrucHdl = docStrucPtr->textEditStrucHdl;		EnableMenuItem(fileMenuRef,iClose);		if(gEnableDragUndoRedoItem)		{			EnableMenuItem(editMenuRef,iUndo);			if(gUndoFlag)				SetMenuItemText(editMenuRef,iUndo,"\pUndo Drag & Drop");			else				SetMenuItemText(editMenuRef,iUndo,"\pRedo Drag & Drop");		}		else		{			DisableMenuItem(editMenuRef,iUndo);			SetMenuItemText(editMenuRef,iUndo,"\pRedo Drag & Drop");		}					if((*textEditStrucHdl)->selStart < (*textEditStrucHdl)->selEnd)		{			EnableMenuItem(editMenuRef,iCut);			EnableMenuItem(editMenuRef,iCopy);			EnableMenuItem(editMenuRef,iClear);		}		else		{			DisableMenuItem(editMenuRef,iCut);			DisableMenuItem(editMenuRef,iCopy);			DisableMenuItem(editMenuRef,iClear);		}		GetCurrentScrap(&scrapRef);		osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&scrapFlavorFlags);		if(osError == noErr)			EnableMenuItem(editMenuRef,iPaste);		else			DisableMenuItem(editMenuRef,iPaste);		if((*textEditStrucHdl)->teLength > 0)		{			EnableMenuItem(fileMenuRef,iSaveAs);			EnableMenuItem(editMenuRef,iSelectAll);		}		else		{			DisableMenuItem(fileMenuRef,iSaveAs);			DisableMenuItem(editMenuRef,iSelectAll);		}	}	else	{		DisableMenuItem(fileMenuRef,iClose);		DisableMenuItem(fileMenuRef,iSaveAs);		DisableMenuItem(editMenuRef,iClear);		DisableMenuItem(editMenuRef,iSelectAll);	}	DrawMenuBar();}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(MenuID menuID,MenuItemIndex menuItem){	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;		case mFile:			doFileMenu(menuItem);			break;		case mEdit:			doEditMenu(menuItem);			break;	}}// ******************************************************************************** doFileMenuvoid	doFileMenu(MenuItemIndex menuItem){	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	switch(menuItem)	{		case iNew:			doNewDocWindow();			break;		case iOpen:			doOpenCommand(); 			doAdjustScrollbar(FrontWindow());			break;		case iClose:			doCloseWindow(FrontWindow());			break;		case iSaveAs:			docStrucPtr = (docStructurePointer) (GetWRefCon(FrontWindow()));			textEditStrucHdl = docStrucPtr->textEditStrucHdl;			doSaveAsFile(textEditStrucHdl);			break;	}}// ******************************************************************************** doEditMenuvoid	doEditMenu(MenuItemIndex menuItem){	WindowRef						windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt32							totalSize, contigSize, newSize;	SInt16							selectionLength;	ScrapRef						scrapRef;	Size								sizeOfTextData;	windowRef = FrontWindow();	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	switch(menuItem)	{		case iUndo:			doUndoRedoDrag(windowRef);			break;		case iCut:			if(ClearCurrentScrap() == noErr)			{				PurgeSpace(&totalSize,&contigSize);				selectionLength = doGetSelectLength(textEditStrucHdl);				if(selectionLength > contigSize)					doErrorAlert(eNoSpaceCut);				else				{					TECut(textEditStrucHdl);					doAdjustScrollbar(windowRef);					if(TEToScrap() != noErr)						ClearCurrentScrap();				}			}			break;		case iCopy:			if(ClearCurrentScrap() == noErr)			{				TECopy(textEditStrucHdl);				if(TEToScrap() != noErr)					ClearCurrentScrap();			}			break;		case iPaste:			GetCurrentScrap(&scrapRef);;			GetScrapFlavorSize(scrapRef,kScrapFlavorTypeText,&sizeOfTextData);			newSize = (*textEditStrucHdl)->teLength + sizeOfTextData;			if(newSize > kMaxTELength)				doErrorAlert(eNoSpacePaste);			else			{				if(TEFromScrap() == noErr)				{					TEPaste(textEditStrucHdl);					doAdjustScrollbar(windowRef);				}			}			break;		case iClear:			TEDelete(textEditStrucHdl);			doAdjustScrollbar(windowRef);			break;		case iSelectAll:			TESetSelect(0,(*textEditStrucHdl)->teLength,textEditStrucHdl);			break;	}}// ************************************************************************* doGetSelectLengthSInt16  doGetSelectLength(TEHandle textEditStrucHdl){	SInt16	selectionLength;	selectionLength = (*textEditStrucHdl)->selEnd - (*textEditStrucHdl)->selStart;	return selectionLength;}// ************************************************************************* doAdjustScrollbarvoid  doAdjustScrollbar(WindowRef windowRef){	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt16							numberOfLines, controlMax, controlValue;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));;	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	numberOfLines = (*textEditStrucHdl)->nLines;	if(*(*(*textEditStrucHdl)->hText + (*textEditStrucHdl)->teLength - 1) == kReturn)		numberOfLines += 1;	controlMax = numberOfLines - (((*textEditStrucHdl)->viewRect.bottom - 							 (*textEditStrucHdl)->viewRect.top) /							 (*textEditStrucHdl)->lineHeight);	if(controlMax < 0)		controlMax = 0;	SetControlMaximum(docStrucPtr->vScrollbarRef,controlMax);	controlValue = ((*textEditStrucHdl)->viewRect.top - (*textEditStrucHdl)->destRect.top) / 									(*textEditStrucHdl)->lineHeight;	if(controlValue < 0)		controlValue = 0;	else if(controlValue > controlMax)		controlValue = controlMax;	SetControlValue(docStrucPtr->vScrollbarRef,controlValue);	SetControlViewSize(docStrucPtr->vScrollbarRef,(*textEditStrucHdl)->viewRect.bottom - 										 (*textEditStrucHdl)->viewRect.top);		TEScroll(0,((*textEditStrucHdl)->viewRect.top - (*textEditStrucHdl)->destRect.top) - 					 		(GetControlValue(docStrucPtr->vScrollbarRef) *							(*textEditStrucHdl)->lineHeight),textEditStrucHdl);}// **************************************************************************** doAdjustCursorvoid  doAdjustCursor(WindowRef windowRef){	GrafPtr							oldPort;	RgnHandle						arrowRegion, iBeamRegion, hiliteRgn;	Rect								portRect, cursorRect;	docStructurePointer	docStrucPtr;	Point								offset, mouseXY;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	arrowRegion = NewRgn();	iBeamRegion = NewRgn();	hiliteRgn		= NewRgn();		SetRectRgn(arrowRegion,-32768,-32768,32766,32766);	GetWindowPortBounds(windowRef,&portRect);	cursorRect = portRect;	cursorRect.right	-= 15;	LocalToGlobal(&topLeft(cursorRect));	LocalToGlobal(&botRight(cursorRect));		RectRgn(iBeamRegion,&cursorRect);	DiffRgn(arrowRegion,iBeamRegion,arrowRegion);	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	TEGetHiliteRgn(hiliteRgn,docStrucPtr->textEditStrucHdl);	LocalToGlobal(&topLeft(portRect));		offset = topLeft(portRect);	OffsetRgn(hiliteRgn,offset.h,offset.v);	DiffRgn(iBeamRegion,hiliteRgn,iBeamRegion);		GetGlobalMouse(&mouseXY);	if(PtInRgn(mouseXY,iBeamRegion))		SetThemeCursor(kThemeIBeamCursor);	else if(PtInRgn(mouseXY,hiliteRgn))		SetThemeCursor(kThemeArrowCursor);	else		SetThemeCursor(kThemeArrowCursor);	DisposeRgn(arrowRegion);	DisposeRgn(iBeamRegion);	DisposeRgn(hiliteRgn);	SetPort(oldPort);}// ***************************************************************************** doCloseWindowvoid  doCloseWindow(WindowRef windowRef){	docStructurePointer	docStrucPtr;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));;	DisposeControl(docStrucPtr->vScrollbarRef);	TEDispose(docStrucPtr->textEditStrucHdl);	DisposePtr((Ptr) docStrucPtr);	if(docStrucPtr->preDragText == NULL)		DisposeHandle(docStrucPtr->preDragText);	RemoveTrackingHandler(gDragTrackingHandlerUPP,windowRef);	RemoveReceiveHandler(gDragReceiveHandlerUPP,windowRef);		DisposeWindow(windowRef);	gNumberOfWindows --;}// ****************************************************************************** doSaveAsFilevoid  doSaveAsFile(TEHandle textEditStrucHdl){	OSErr							osError = noErr;	NavDialogOptions	dialogOptions;	NavEventUPP				navEventFunctionUPP;	WindowRef					windowRef;	OSType						fileType;	NavReplyRecord		navReplyStruc;	AEKeyword					theKeyword;	DescType					actualType;	FSSpec						fileSpec;		SInt16						fileRefNum;	Size							actualSize;	SInt32						dataLength;	Handle						editTextHdl;	osError = NavGetDefaultDialogOptions(&dialogOptions);	if(osError == noErr)	{		windowRef = FrontWindow();		fileType = 'TEXT';		navEventFunctionUPP = NewNavEventUPP((NavEventProcPtr) navEventFunction);		osError = NavPutFile(NULL,&navReplyStruc,&dialogOptions,navEventFunctionUPP,fileType,												 'kbKB',NULL);		DisposeNavEventUPP(navEventFunctionUPP);		if(navReplyStruc.validRecord && osError == noErr)		{			if((osError = AEGetNthPtr(&(navReplyStruc.selection),1,typeFSS,&theKeyword,																&actualType,&fileSpec,sizeof(fileSpec),&actualSize)) == noErr)			{				if(!navReplyStruc.replacing)				{					osError = FSpCreate(&fileSpec,'kkkB',fileType,navReplyStruc.keyScript);					if(osError != noErr)					{						NavDisposeReply(&navReplyStruc);					}				}								if(osError == noErr)					osError = FSpOpenDF(&fileSpec,fsRdWrPerm,&fileRefNum);				if(osError == noErr)				{					SetWTitle(windowRef,fileSpec.name);					dataLength = (*textEditStrucHdl)->teLength;					editTextHdl = (*textEditStrucHdl)->hText;					FSWrite(fileRefNum,&dataLength,*editTextHdl);				}				NavCompleteSave(&navReplyStruc,kNavTranslateInPlace);			}			NavDisposeReply(&navReplyStruc);		}	}}// ***************************************************************************** doOpenCommandvoid  doOpenCommand(void){		OSErr							osError	= noErr;	NavDialogOptions	dialogOptions;	NavEventUPP				navEventFunctionUPP;	NavReplyRecord		navReplyStruc;	SInt32						index, count;	AEKeyword					theKeyword;	DescType					actualType;	FSSpec						fileSpec;		Size							actualSize;	FInfo							fileInfo;	osError = NavGetDefaultDialogOptions(&dialogOptions);	if(osError == noErr)	{		navEventFunctionUPP = NewNavEventUPP((NavEventProcPtr) navEventFunction);		osError = NavGetFile(NULL,&navReplyStruc,&dialogOptions,navEventFunctionUPP,NULL,NULL,												 NULL,NULL);		DisposeNavEventUPP(navEventFunctionUPP);		if(osError == noErr && navReplyStruc.validRecord)		{			if(osError == noErr)			{				if(osError == noErr)				{					osError = AECountItems(&(navReplyStruc.selection),&count);					for(index=1;index<=count;index++)					{						osError = AEGetNthPtr(&(navReplyStruc.selection),index,typeFSS,&theKeyword,																&actualType,&fileSpec,sizeof(fileSpec),&actualSize);						{							if((osError = FSpGetFInfo(&fileSpec,&fileInfo)) == noErr)								doOpenFile(fileSpec);						}					}				}			}			NavDisposeReply(&navReplyStruc);			}	}}// ******************************************************************************** doOpenFilevoid  doOpenFile(FSSpec fileSpec){	WindowRef 					windowRef;	docStructurePointer	docStrucPtr;	TEHandle						textEditStrucHdl;	SInt16							fileRefNum;	SInt32							textLength;	Handle							textBuffer;	if((windowRef = doNewDocWindow()) == NULL)		return;	docStrucPtr = (docStructurePointer) (GetWRefCon(windowRef));	textEditStrucHdl = docStrucPtr->textEditStrucHdl;	SetWTitle(windowRef,fileSpec.name);	FSpOpenDF(&fileSpec,fsCurPerm,&fileRefNum);	SetFPos(fileRefNum,fsFromStart,0);	GetEOF(fileRefNum,&textLength);	if(textLength > 32767)		textLength = 32767;	textBuffer = NewHandle((Size) textLength);	FSRead(fileRefNum,&textLength,*textBuffer);	MoveHHi(textBuffer);	HLock(textBuffer);	TESetText(*textBuffer,textLength,textEditStrucHdl);	HUnlock(textBuffer);	DisposeHandle(textBuffer);	FSClose(fileRefNum);	(*textEditStrucHdl)->selStart = 0;	(*textEditStrucHdl)->selEnd = 0;	doDrawContent(windowRef);}// ****************************************************************************** doErrorAlertvoid  doErrorAlert(SInt16 errorCode){	Str255	errorString;	SInt16	itemHit;	GetIndString(errorString,rErrorStrings,errorCode);	if(errorCode < eWindow)	{		StandardAlert(kAlertStopAlert,errorString,NULL,NULL,&itemHit);		ExitToShell();	}	else	{		StandardAlert(kAlertCautionAlert,errorString,NULL,NULL,&itemHit);	}}// ************************************************************************** navEventFunctionvoid  navEventFunction(NavEventCallbackMessage callBackSelector,NavCBRecPtr callBackParms,											 NavCallBackUserData callBackUD){}// *******************************************************************************************