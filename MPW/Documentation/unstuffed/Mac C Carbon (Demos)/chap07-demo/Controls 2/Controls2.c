// *******************************************************************************************// Controls2.c                                                             CLASSIC EVENT MODEL// *******************************************************************************************// // This program://// ╔	Opens a kWindowDocumentProc window with a two horizontal scroll bars, each of which//		relates to the picture displayed immediately above it.//// ╔	Allows the user to horizontally scroll the pictures within the window using the scroll//		box/scroller, the scroll arrows and the gray area/track of each scroll bar.  //// The top scroll bar uses the non-live-feedback variant of the scroll bar CDEF.  The bottom// scroll bar uses the live-feedback variant.    //// With regard to the scroll bars, the principal differences between this program and // Controls1 are that, in this program://// ╔	The scroll bar scroll boxes are made proportional.//// ╔	The action functions are set using the function SetControlAction.//// ╔	References to the scroll bar controls are not stored in, and retrieved from, a document//		structure associated with the window.  Instead,	each control is assigned a controlID //		using SetControlID, allowing the ID of the control to be retrieved using GetControlID//		and a reference to the control to be obtained using GetControlByID. //// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	An 'MBAR' resource, and 'MENU' resources for Apple, File and Edit (preload, non-//		purgeable).//// ╔	A 'WIND' resource (purgeable) (initially visible).//// ╔	Two 'CNTL' resource for the horizontal scroll bars (purgeable).//// ╔	'PICT' resources containing the pictures to be scrolled (non-purgeable).//// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar						128#define rNewWindow					128#define rPictureNonLive			128#define rPictureLive				129#define mAppleApplication		128#define  iAbout							1#define mFile								129#define  iQuit							12#define cScrollbarNonLive		128#define cScrollbarLive			129#define kScrollbarNonLiveID	1#define kScrollbarLiveID		2#define MAX_UINT32					0xFFFFFFFF// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesControlActionUPP	gActionFuncNonLiveUPP;ControlActionUPP	gActionFuncLiveUPP;Boolean						gDone;Rect							gPictRectNonLive, gPictRectLive;PicHandle					gPictHandleNonLive, gPictHandleLive ;// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid	main								(void);void	doPreliminaries			(void);OSErr	quitAppEventHandler	(AppleEvent *,AppleEvent *,SInt32);void	doEvents						(EventRecord *);void	doMouseDown					(EventRecord *);void	doUpdate						(EventRecord *);void	doActivate					(EventRecord *);void	doActivateWindow		(WindowRef,Boolean);void	doOSEvent						(EventRecord *);void	doMenuChoice				(SInt32);void	doInContent					(EventRecord *,WindowRef);void	doNonLiveScrollBars	(ControlPartCode,WindowRef,ControlRef,Point);void	actionFuncNonLive		(ControlRef,ControlPartCode);void	actionFuncLive			(ControlRef,ControlPartCode);void	doMoveScrollBox			(ControlRef,SInt16);// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	WindowRef			windowRef;	ControlRef		controlRefScrollbarNonLive, controlRefScrollbarLive;	ControlID			controlID;	Rect					portRect;	EventRecord		eventStructure;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииии create universal procedure pointers	gActionFuncNonLiveUPP = NewControlActionUPP((ControlActionProcPtr) actionFuncNonLive);	gActionFuncLiveUPP		= NewControlActionUPP((ControlActionProcPtr) actionFuncLive);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		ExitToShell();	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open a window	if(!(windowRef = GetNewCWindow(rNewWindow,NULL,(WindowRef)-1)))		ExitToShell();	SetPortWindowPort(windowRef);	// ииииииииииииииииииииииииииииииииииии get controls and set ID and control action functions	controlRefScrollbarNonLive	= GetNewControl(cScrollbarNonLive,windowRef);	controlID.signature = 'kjB ';	controlID.id = kScrollbarNonLiveID;	SetControlID(controlRefScrollbarNonLive,&controlID);	SetControlAction(controlRefScrollbarNonLive,gActionFuncNonLiveUPP);		controlRefScrollbarLive = GetNewControl(cScrollbarLive,windowRef);	controlID.id = kScrollbarLiveID;	SetControlID(controlRefScrollbarLive,&controlID);	SetControlAction(controlRefScrollbarLive,gActionFuncLiveUPP);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии get picture	if(!(gPictHandleNonLive = GetPicture(rPictureNonLive)))		ExitToShell();	gPictRectNonLive = (*gPictHandleNonLive)->picFrame;	if(!(gPictHandleLive = GetPicture(rPictureLive)))		ExitToShell();	gPictRectLive = (*gPictHandleLive)->picFrame;	OffsetRect(&gPictRectLive,0,191);	// ииииииииииииииииииииииииииииииииииииииииииииииииииии set up for proportional scroll boxes	GetWindowPortBounds(windowRef,&portRect);	SetControlViewSize(controlRefScrollbarNonLive,portRect.right);	SetControlViewSize(controlRefScrollbarLive,portRect.right);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop	gDone = false;	while(!gDone)	{		if(WaitNextEvent(everyEvent,&eventStructure,MAX_UINT32,NULL))			doEvents(&eventStructure);	}}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(32);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case mouseDown:			doMouseDown(eventStrucPtr);			break;		case updateEvt:			doUpdate(eventStrucPtr);			break;		case activateEvt:			doActivate(eventStrucPtr);			break;		case osEvt:			doOSEvent(eventStrucPtr);			break;	}}// ******************************************************************************* doMouseDownvoid	doMouseDown(EventRecord *eventStrucPtr){	WindowRef				windowRef;	WindowPartCode	partCode;		partCode = FindWindow(eventStrucPtr->where,&windowRef);		switch(partCode)	{		case inMenuBar:			doMenuChoice(MenuSelect(eventStrucPtr->where));			break;		case inContent:			if(windowRef != FrontWindow())				SelectWindow(windowRef);			else				doInContent(eventStrucPtr,windowRef);			break;		case inDrag:			DragWindow(windowRef,eventStrucPtr->where,NULL);			break;	}}// ********************************************************************************** doUpdatevoid  doUpdate(EventRecord *eventStrucPtr){	WindowRef		windowRef;	RgnHandle		regionHdl;	ControlID		controlID;	ControlRef	controlRef;	windowRef = (WindowRef) eventStrucPtr->message;	BeginUpdate(windowRef);	SetPortWindowPort(windowRef);	regionHdl = NewRgn();	if(regionHdl)	{		GetPortVisibleRegion(GetWindowPort(windowRef),regionHdl);		UpdateControls(windowRef,regionHdl);		DisposeRgn(regionHdl);	}	controlID.signature = 'kjB ';	controlID.id = kScrollbarNonLiveID;	GetControlByID(windowRef,&controlID,&controlRef);	SetOrigin(GetControlValue(controlRef),0);	DrawPicture(gPictHandleNonLive,&gPictRectNonLive);	SetOrigin(0,0);	controlID.id = kScrollbarLiveID;	GetControlByID(windowRef,&controlID,&controlRef);	SetOrigin(GetControlValue(controlRef),0);	DrawPicture(gPictHandleLive,&gPictRectLive);	SetOrigin(0,0);	EndUpdate(windowRef);}// ******************************************************************************** doActivatevoid  doActivate(EventRecord *eventStrucPtr){	WindowRef	windowRef;	Boolean		becomingActive;	windowRef = (WindowRef) eventStrucPtr->message;	becomingActive = ((eventStrucPtr->modifiers & activeFlag) == activeFlag);	doActivateWindow(windowRef,becomingActive);}// ************************************************************************** doActivateWindowvoid  doActivateWindow(WindowRef windowRef,Boolean becomingActive){		ControlID		controlID;	ControlRef	controlRefScrollbarNonLive, controlRefScrollbarLive;	controlID.signature = 'kjB ';	controlID.id = kScrollbarNonLiveID;	GetControlByID(windowRef,&controlID,&controlRefScrollbarNonLive);	controlID.id = kScrollbarLiveID;	GetControlByID(windowRef,&controlID,&controlRefScrollbarLive);	if(becomingActive)	{		ActivateControl(controlRefScrollbarNonLive);		ActivateControl(controlRefScrollbarLive);	}	else	{		DeactivateControl(controlRefScrollbarNonLive);		DeactivateControl(controlRefScrollbarLive);	}}// ********************************************************************************* doOSEventvoid	doOSEvent(EventRecord *eventStrucPtr){	switch((eventStrucPtr->message >> 24) & 0x000000FF)	{		case suspendResumeMessage:			if((eventStrucPtr->message & resumeFlag) == 1)				SetThemeCursor(kThemeArrowCursor);			break;	}}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;	menuID = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;					case mFile:			if(menuItem == iQuit)				gDone = true;			break;	}	HiliteMenu(0);}// ******************************************************************************* doIncontentvoid  doInContent(EventRecord *eventStrucPtr,WindowRef windowRef){	ControlPartCode	controlPartCode;	ControlRef			controlRef;	ControlID				controlID;	SetPortWindowPort(windowRef);	GlobalToLocal(&eventStrucPtr->where);	if(controlPartCode = FindControl(eventStrucPtr->where,windowRef,&controlRef))	{		GetControlID(controlRef,&controlID);		if(controlID.id == kScrollbarNonLiveID)			doNonLiveScrollBars(controlPartCode,windowRef,controlRef,eventStrucPtr->where);		else if(controlID.id == kScrollbarLiveID)			TrackControl(controlRef,eventStrucPtr->where,(ControlActionUPP) -1);	}}// *********************************************************************** doNonLiveScrollBarsvoid  doNonLiveScrollBars(ControlPartCode controlPartCode,WindowRef windowRef,									 				ControlRef controlRef,Point mouseXY){	SInt16		oldControlValue;	SInt16		scrollDistance;	RgnHandle	updateRgnHdl;	switch(controlPartCode)	{		case kControlIndicatorPart:			oldControlValue = GetControlValue(controlRef);			if(TrackControl(controlRef,mouseXY,NULL))			{				scrollDistance = oldControlValue - GetControlValue(controlRef);				if(scrollDistance != 0)				{					updateRgnHdl = NewRgn();					ScrollRect(&gPictRectNonLive,scrollDistance,0,updateRgnHdl);					InvalWindowRgn(windowRef,updateRgnHdl);					DisposeRgn(updateRgnHdl);				}			}			break;		case kControlUpButtonPart:		case kControlDownButtonPart:		case kControlPageUpPart:		case kControlPageDownPart:			TrackControl(controlRef,mouseXY,(ControlActionUPP) -1);			break;	}}// ************************************************************************* actionFuncNonLivevoid  actionFuncNonLive(ControlRef controlRef,ControlPartCode controlPartCode){	WindowRef	windowRef;	SInt16		scrollDistance, controlValue;	Rect			portRect; 						RgnHandle	updateRgnHdl;	if(controlPartCode)	{		windowRef = GetControlOwner(controlRef);		switch(controlPartCode)		{			case kControlUpButtonPart:			case kControlDownButtonPart:				scrollDistance = 2;				break;			case kControlPageUpPart:			case kControlPageDownPart:				GetWindowPortBounds(windowRef,&portRect);				scrollDistance = (portRect.right - portRect.left - 10);				break;		}		if((controlPartCode == kControlDownButtonPart) || 			 (controlPartCode == kControlPageDownPart))			scrollDistance = -scrollDistance;		controlValue = GetControlValue(controlRef);		if(((controlValue == GetControlMaximum(controlRef)) && scrollDistance < 0) || 			 ((controlValue == GetControlMinimum(controlRef)) && scrollDistance > 0))			return;		doMoveScrollBox(controlRef,scrollDistance);		if(controlPartCode == kControlUpButtonPart || 			 controlPartCode == kControlDownButtonPart)		{			updateRgnHdl = NewRgn();			ScrollRect(&gPictRectNonLive,scrollDistance,0,updateRgnHdl);			InvalWindowRgn(windowRef,updateRgnHdl);			DisposeRgn(updateRgnHdl);			BeginUpdate(windowRef);		}		SetOrigin(GetControlValue(controlRef),0);		DrawPicture(gPictHandleNonLive,&gPictRectNonLive);		SetOrigin(0,0);		if(controlPartCode == kControlUpButtonPart || controlPartCode == kControlDownButtonPart)			EndUpdate(windowRef);	}}// *************************************************************************** actionFuncLivevoid  actionFuncLive(ControlRef controlRef,ControlPartCode partCode){	WindowRef	windowRef;	SInt16		scrollDistance, controlValue;	Rect			portRect;	windowRef = GetControlOwner(controlRef);	if(partCode != 0)	{		if(partCode != kControlIndicatorPart)		{			switch(partCode)			{				case kControlUpButtonPart:				case kControlDownButtonPart:					scrollDistance = 2;					break;				case kControlPageUpPart:				case kControlPageDownPart:					GetWindowPortBounds(windowRef,&portRect);					scrollDistance = (portRect.right - portRect.left) - 10;					break;			}			if((partCode == kControlDownButtonPart) || (partCode == kControlPageDownPart))				scrollDistance = -scrollDistance;			controlValue = GetControlValue(controlRef);			if(((controlValue == GetControlMaximum(controlRef)) && scrollDistance < 0) || 				 ((controlValue == GetControlMinimum(controlRef)) && scrollDistance > 0))				return;			doMoveScrollBox(controlRef,scrollDistance);		}		SetOrigin(GetControlValue(controlRef),0);		DrawPicture(gPictHandleLive,&gPictRectLive);		SetOrigin(0,0);	}}// *************************************************************************** doMoveScrollBoxvoid doMoveScrollBox(ControlRef controlRef,SInt16 scrollDistance){	SInt16	oldControlValue, controlValue, controlMax;	oldControlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	controlValue = oldControlValue - scrollDistance;		if(controlValue < 0)		controlValue = 0;	else if(controlValue > controlMax)		controlValue = controlMax;	SetControlValue(controlRef,controlValue);}// *******************************************************************************************