// *******************************************************************************************// MonoTextEdit.c                                                          CLASSIC EVENT MODEL// *******************************************************************************************//// This program demonstrates://// ╔	A "bare-bones" monostyled text editor.//// ╔	A Help dialog which features the integrated scrolling of multistyled text and pictures.//// In the monostyled text editor demonstration, a panel is displayed at the bottom of all// opened windows.  This panel displays the edit record length, number of lines, line height,// destination rectangle (top), scroll bar value, and scroll bar maximum value. //// The bulk of the source code for the Help dialog is contained in the file HelpDialog.c.// The dialog itself displays information intended to assist the user in adapting the Help// dialog source code and resources to the requirements of his/her own application.//// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	An 'MBAR' resource, and 'MENU' resources for Apple, File, Edit, and Help dialog pop-up//		menus (preload, non-purgeable).  //// ╔	A 'WIND' resource (purgeable) (initially visible).  //// ╔	'CNTL' resources (purgeable) for the vertical scroll bars in the text editor window and//		Help dialog, and for the pop-up menu in the Help Dialog.//     // ╔	A 'DLOG' resource (purgeable, initially invisible) and associated 'dctb' resource //		(purgeable) for the Help dialog.//// ╔	'TEXT' and associated 'styl' resources (all purgeable) for the Help dialog.//// ╔	'PICT' resources (purgeable) for the Help dialog.//// ╔	A 'STR#' resource  (purgeable) containing error text strings.  //// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar					128#define mAppleApplication	128#define  iAbout						1#define  iHelp  					2#define mFile							129#define  iNew							1#define  iOpen						2#define  iClose						4#define  iSaveAs					6#define  iQuit						12#define mEdit							130#define  iUndo						1#define  iCut							3#define  iCopy						4#define  iPaste						5#define  iClear						6#define  iSelectAll				7#define rWindow						128#define rVScrollbar				128#define rErrorStrings			128#define  eMenuBar					1#define  eWindow					2#define  eDocStructure		3#define  eEditRecord			4#define  eExceedChara			5#define  eNoSpaceCut			6#define  eNoSpacePaste		7#define kMaxTELength			32767#define kTab							0x09#define kDel							0x7F#define kReturn						0x0D#define kFileCreator			'kjbB'#define topLeft(r)				(((Point *) &(r))[0])#define botRight(r)				(((Point *) &(r))[1])// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии typedefstypedef struct{	TEHandle		textEditStrucHdl;	ControlRef	vScrollbarRef;} docStructure, **docStructureHandle;// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean						gRunningOnX = false;MenuID						gHelpMenu;ControlActionUPP	gScrollActionFunctionUPP;TEClickLoopUPP		gCustomClickLoopUPP;Boolean						gDone;RgnHandle					gCursorRegion;SInt16						gNumberOfWindows = 0;SInt16 						gOldControlValue;// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid			main									(void);void			doPreliminaries				(void);OSErr			quitAppEventHandler		(AppleEvent *,AppleEvent *,SInt32);void			eventLoop							(void);void			doIdle								(void);void			doEvents							(EventRecord *);void			doKeyEvent						(SInt8);void  		scrollActionFunction	(ControlRef,SInt16);void			doInContent						(EventRecord *);void			doUpdate							(EventRecord *);void			doActivate						(EventRecord *);void			doActivateDocWindow		(WindowRef,Boolean);void			doOSEvent							(EventRecord *);WindowRef	doNewDocWindow				(void);Boolean		customClickLoop				(void);void			doSetScrollBarValue		(ControlRef,SInt16 *);void			doAdjustMenus					(void);void			doMenuChoice					(SInt32);void			doFileMenu						(MenuItemIndex);void			doEditMenu						(MenuItemIndex);SInt16		doGetSelectLength			(TEHandle);void			doAdjustScrollbar			(WindowRef);void			doAdjustCursor				(WindowRef);void			doCloseWindow					(WindowRef);void			doSaveAsFile					(TEHandle);void			doOpenCommand					(void);void			navEventFunction			(NavEventCallbackMessage,NavCBRecPtr,NavCallBackUserData);void			doOpenFile						(FSSpec);void			doDrawDataPanel				(WindowRef);void			doErrorAlert					(SInt16);extern void	doHelp							(void);// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus		menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		doErrorAlert(eMenuBar);	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);		}		menuRef = GetMenuRef(mAppleApplication);		DeleteMenuItem(menuRef,iHelp);		HMGetHelpMenu(&menuRef,NULL);		InsertMenuItem(menuRef,"\pMonoTextEdit Help",0);		gHelpMenu = GetMenuID(menuRef);		gRunningOnX = true;	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииии create universal procedure pointers	gScrollActionFunctionUPP = NewControlActionUPP((ControlActionProcPtr) scrollActionFunction);	gCustomClickLoopUPP			 = NewTEClickLoopUPP((TEClickLoopProcPtr) customClickLoop);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open an untitled window	doNewDocWindow();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop	eventLoop();}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(192);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************* eventLoopvoid  eventLoop(void){	EventRecord	eventStructure;	Boolean			gotEvent;	SInt32			sleepTime;	gDone = false;	gCursorRegion = NewRgn();	doAdjustCursor(FrontWindow());	sleepTime = GetCaretTime();	while(!gDone)	{		gotEvent = WaitNextEvent(everyEvent,&eventStructure,sleepTime,gCursorRegion);		if(gotEvent)			doEvents(&eventStructure);		else		{			if(eventStructure.what == nullEvent)				if(gNumberOfWindows > 0)					doIdle();		}	}}// ************************************************************************************ doIdlevoid  doIdle(void){	docStructureHandle	docStrucHdl;	WindowRef						windowRef;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	if(docStrucHdl != NULL)		TEIdle((*docStrucHdl)->textEditStrucHdl);}	// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	WindowRef				windowRef;	WindowPartCode	partCode;	SInt8						charCode;	switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case mouseDown:			partCode = FindWindow(eventStrucPtr->where,&windowRef);			switch(partCode)			{				case inMenuBar:					doAdjustMenus();					doMenuChoice(MenuSelect(eventStrucPtr->where));					break;				case inContent:					if(windowRef != FrontWindow())						SelectWindow(windowRef);					else						doInContent(eventStrucPtr);					break;				case inDrag:					DragWindow(windowRef,eventStrucPtr->where,NULL);					doAdjustCursor(windowRef);					break;				case inGoAway:					if(TrackGoAway(windowRef,eventStrucPtr->where))						doCloseWindow(FrontWindow());					break;			}			break;		case keyDown:			charCode = eventStrucPtr->message & charCodeMask;			if((eventStrucPtr->modifiers & cmdKey) != 0)			{				doAdjustMenus();				doMenuChoice(MenuEvent(eventStrucPtr));			}			else				doKeyEvent(charCode);			break;		case autoKey:			charCode = eventStrucPtr->message & charCodeMask;			if((eventStrucPtr->modifiers & cmdKey) == 0)				doKeyEvent(charCode);			break;		case updateEvt:			doUpdate(eventStrucPtr);			break;		case activateEvt:			doActivate(eventStrucPtr);			break;		case osEvt:			doOSEvent(eventStrucPtr);			break;	}}// ******************************************************************************** doKeyEventvoid  doKeyEvent(SInt8 charCode){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							selectionLength;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	if(charCode == kTab)	{		// Do tab key handling here if required.	}	else if(charCode == kDel)	{		selectionLength = doGetSelectLength(textEditStrucHdl);		if(selectionLength == 0)			(*textEditStrucHdl)->selEnd += 1;		TEDelete(textEditStrucHdl);		doAdjustScrollbar(windowRef);	}	else	{		selectionLength = doGetSelectLength(textEditStrucHdl);		if(((*textEditStrucHdl)->teLength - selectionLength + 1) < kMaxTELength)		{			TEKey(charCode,textEditStrucHdl);			doAdjustScrollbar(windowRef);		}		else			doErrorAlert(eExceedChara);	}	doDrawDataPanel(windowRef);}// ********************************************************************** scrollActionFunctionvoid  scrollActionFunction(ControlRef controlRef,SInt16 partCode){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							linesToScroll;	SInt16							controlValue, controlMax;	windowRef = GetControlOwner(controlRef);	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	controlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	if(partCode)	{		if(partCode != kControlIndicatorPart)		{			switch(partCode)			{				case kControlUpButtonPart:				case kControlDownButtonPart:					linesToScroll = 1;					break;				case kControlPageUpPart:				case kControlPageDownPart:					linesToScroll = (((*textEditStrucHdl)->viewRect.bottom - 														(*textEditStrucHdl)->viewRect.top) /														(*textEditStrucHdl)->lineHeight) - 1;					break;			}			if((partCode == kControlDownButtonPart) || (partCode == kControlPageDownPart))				linesToScroll = -linesToScroll;			linesToScroll = controlValue - linesToScroll;			if(linesToScroll < 0)				linesToScroll = 0;			else if(linesToScroll > controlMax)				linesToScroll = controlMax;			SetControlValue(controlRef,linesToScroll);			linesToScroll = controlValue - linesToScroll;		}		else		{			linesToScroll = gOldControlValue - controlValue;			gOldControlValue = controlValue;		}		if(linesToScroll != 0)		{			TEScroll(0,linesToScroll * (*textEditStrucHdl)->lineHeight,textEditStrucHdl);			doDrawDataPanel(windowRef);		}	}}// ******************************************************************************* doInContentvoid  doInContent(EventRecord *eventStrucPtr){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	Point								mouseXY;	ControlRef					controlRef;	SInt16							partCode;	Boolean							shiftKeyPosition = false;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	mouseXY = eventStrucPtr->where;	SetPortWindowPort(windowRef);	GlobalToLocal(&mouseXY);	if((partCode = FindControl(mouseXY,windowRef,&controlRef)) != 0)	{		gOldControlValue = GetControlValue(controlRef);		TrackControl(controlRef,mouseXY,gScrollActionFunctionUPP);	}	else if(PtInRect(mouseXY,&(*textEditStrucHdl)->viewRect))	{		if((eventStrucPtr->modifiers & shiftKey) != 0)			shiftKeyPosition = true;		TEClick(mouseXY,shiftKeyPosition,textEditStrucHdl);	}}// ********************************************************************************** doUpdatevoid	doUpdate(EventRecord *eventStrucPtr){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	GrafPtr							oldPort;	RgnHandle						visibleRegionHdl = NewRgn();	Rect								portRect;	windowRef = (WindowRef) eventStrucPtr->message;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;		GetPort(&oldPort);	SetPortWindowPort(windowRef);	BeginUpdate((WindowRef) eventStrucPtr->message);	GetPortVisibleRegion(GetWindowPort(windowRef),visibleRegionHdl);	EraseRgn(visibleRegionHdl);	UpdateControls(windowRef,visibleRegionHdl);	GetWindowPortBounds(windowRef,&portRect);	TEUpdate(&portRect,textEditStrucHdl);	doDrawDataPanel(windowRef);	EndUpdate((WindowRef) eventStrucPtr->message);	DisposeRgn(visibleRegionHdl);	SetPort(oldPort);}// ******************************************************************************** doActivatevoid  doActivate(EventRecord *eventStrucPtr){	WindowRef	windowRef;	Boolean		becomingActive;	windowRef = (WindowRef) eventStrucPtr->message;	becomingActive = ((eventStrucPtr->modifiers & activeFlag) == activeFlag);	doActivateDocWindow(windowRef,becomingActive);}// *********************************************************************** doActivateDocWindowvoid  doActivateDocWindow(WindowRef windowRef,Boolean becomingActive){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	if(becomingActive)	{		SetPortWindowPort(windowRef);		(*textEditStrucHdl)->viewRect.bottom = ((((*textEditStrucHdl)->viewRect.bottom -																							(*textEditStrucHdl)->viewRect.top) / 																							(*textEditStrucHdl)->lineHeight) * 																							(*textEditStrucHdl)->lineHeight) + 																							(*textEditStrucHdl)->viewRect.top;		(*textEditStrucHdl)->destRect.bottom = (*textEditStrucHdl)->viewRect.bottom;		TEActivate(textEditStrucHdl);		ActivateControl((*docStrucHdl)->vScrollbarRef);		doAdjustScrollbar(windowRef);		doAdjustCursor(windowRef);	}	else	{		TEDeactivate(textEditStrucHdl);		DeactivateControl((*docStrucHdl)->vScrollbarRef);	}}// ********************************************************************************* doOSEventvoid	doOSEvent(EventRecord *eventStrucPtr){	switch((eventStrucPtr->message >> 24) & 0x000000FF)	{		case suspendResumeMessage:			if((eventStrucPtr->message & resumeFlag) == 1)				SetThemeCursor(kThemeArrowCursor);			break;		case mouseMovedMessage:			doAdjustCursor(FrontWindow());			break;	}}// **************************************************************************** doNewDocWindowWindowRef  doNewDocWindow(void){	WindowRef 					windowRef;	docStructureHandle	docStrucHdl;	Rect								portRect, destAndViewRect;	if(!(windowRef = GetNewCWindow(rWindow,NULL,(WindowRef) -1)))	{		doErrorAlert(eWindow);		return NULL;	}	SetPortWindowPort(windowRef);	TextSize(10);	if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))	{		doErrorAlert(eDocStructure);		return NULL;	}	SetWRefCon(windowRef,(SInt32) docStrucHdl);	gNumberOfWindows ++;	(*docStrucHdl)->vScrollbarRef = GetNewControl(rVScrollbar,windowRef);		GetWindowPortBounds(windowRef,&portRect);	destAndViewRect = portRect;	destAndViewRect.right -= 15;	destAndViewRect.bottom -= 15;	InsetRect(&destAndViewRect,2,2);	MoveHHi((Handle) docStrucHdl);	HLock((Handle) docStrucHdl);	if(!((*docStrucHdl)->textEditStrucHdl = TENew(&destAndViewRect,&destAndViewRect)))	{		DisposeWindow(windowRef);		gNumberOfWindows --;		DisposeHandle((Handle) docStrucHdl);		doErrorAlert(eEditRecord);		return NULL;	}	HUnlock((Handle) docStrucHdl);	TESetClickLoop(gCustomClickLoopUPP,(*docStrucHdl)->textEditStrucHdl);	TEAutoView(true,(*docStrucHdl)->textEditStrucHdl);	TEFeatureFlag(teFOutlineHilite,1,(*docStrucHdl)->textEditStrucHdl);	return windowRef;}// *************************************************************************** customClickLoopBoolean  customClickLoop(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	GrafPtr							oldPort;	RgnHandle						oldClip;	Rect								tempRect, portRect;	Point								mouseXY;	SInt16							linesToScroll = 0;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	oldClip = NewRgn();	GetClip(oldClip);	SetRect(&tempRect,-32767,-32767,32767,32767);	ClipRect(&tempRect);	GetMouse(&mouseXY);	GetWindowPortBounds(windowRef,&portRect);		if(mouseXY.v < portRect.top)	{		linesToScroll = 1;		doSetScrollBarValue((*docStrucHdl)->vScrollbarRef,&linesToScroll);		if(linesToScroll != 0)			TEScroll(0,linesToScroll * ((*textEditStrucHdl)->lineHeight),textEditStrucHdl);	}	else if(mouseXY.v > portRect.bottom)	{		linesToScroll = -1;		doSetScrollBarValue((*docStrucHdl)->vScrollbarRef,&linesToScroll);		if(linesToScroll != 0)			TEScroll(0,linesToScroll * ((*textEditStrucHdl)->lineHeight),textEditStrucHdl);	}	if(linesToScroll != 0)		doDrawDataPanel(windowRef);	SetClip(oldClip);	DisposeRgn(oldClip);	SetPort(oldPort);	return true;}// *********************************************************************** doSetScrollBarValuevoid  doSetScrollBarValue(ControlRef controlRef,SInt16 *linesToScroll){	SInt16	controlValue, controlMax;	controlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	*linesToScroll = controlValue - *linesToScroll;	if(*linesToScroll < 0)		*linesToScroll = 0;	else if(*linesToScroll > controlMax)		*linesToScroll = controlMax;	SetControlValue(controlRef,*linesToScroll);	*linesToScroll = controlValue - *linesToScroll;}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef							fileMenuHdl, editMenuHdl;	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	ScrapRef						scrapRef;	OSStatus						osError;	ScrapFlavorFlags		scrapFlavorFlags;	fileMenuHdl = GetMenuRef(mFile);	editMenuHdl = GetMenuRef(mEdit);	if(gNumberOfWindows > 0)	{		windowRef = FrontWindow();		docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));		textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;		EnableMenuItem(fileMenuHdl,iClose);		if((*textEditStrucHdl)->selStart < (*textEditStrucHdl)->selEnd)		{			EnableMenuItem(editMenuHdl,iCut);			EnableMenuItem(editMenuHdl,iCopy);			EnableMenuItem(editMenuHdl,iClear);		}		else		{			DisableMenuItem(editMenuHdl,iCut);			DisableMenuItem(editMenuHdl,iCopy);			DisableMenuItem(editMenuHdl,iClear);		}		GetCurrentScrap(&scrapRef);		osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&scrapFlavorFlags);		if(osError == noErr)			EnableMenuItem(editMenuHdl,iPaste);		else			DisableMenuItem(editMenuHdl,iPaste);					if((*textEditStrucHdl)->teLength > 0)		{			EnableMenuItem(fileMenuHdl,iSaveAs);			EnableMenuItem(editMenuHdl,iSelectAll);		}		else		{			DisableMenuItem(fileMenuHdl,iSaveAs);			DisableMenuItem(editMenuHdl,iSelectAll);		}	}	else	{		DisableMenuItem(fileMenuHdl,iClose);		DisableMenuItem(fileMenuHdl,iSaveAs);		DisableMenuItem(editMenuHdl,iClear);		DisableMenuItem(editMenuHdl,iSelectAll);	}			DrawMenuBar();}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;	menuID	 = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	if(gRunningOnX)		if(menuID == gHelpMenu)			if(menuItem == 1)				doHelp();	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			else if(menuItem == iHelp)				doHelp();			break;		case mFile:			doFileMenu(menuItem);			break;		case mEdit:			doEditMenu(menuItem);			break;	}	HiliteMenu(0);}// ******************************************************************************** doFileMenuvoid	doFileMenu(MenuItemIndex menuItem){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	switch(menuItem)	{		case iNew:			if(windowRef = doNewDocWindow())				ShowWindow(windowRef);			break;		case iOpen:			doOpenCommand();			break;		case iClose:			doCloseWindow(FrontWindow());			break;		case iSaveAs:			docStrucHdl = (docStructureHandle) (GetWRefCon(FrontWindow()));			textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;			doSaveAsFile(textEditStrucHdl);			break;		case iQuit:			gDone = true;			break;	}}// ******************************************************************************** doEditMenuvoid	doEditMenu(MenuItemIndex menuItem){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt32							totalSize, contigSize, newSize;	SInt16							selectionLength;	ScrapRef						scrapRef;	Size								sizeOfTextData;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	switch(menuItem)	{		case iUndo:			break;		case iCut:			if(ClearCurrentScrap() == noErr)			{				PurgeSpace(&totalSize,&contigSize);				selectionLength = doGetSelectLength(textEditStrucHdl);				if(selectionLength > contigSize)					doErrorAlert(eNoSpaceCut);				else				{					TECut(textEditStrucHdl);					doAdjustScrollbar(windowRef);					if(TEToScrap() != noErr)						ClearCurrentScrap();				}			}			break;		case iCopy:			if(ClearCurrentScrap() == noErr)				TECopy(textEditStrucHdl);			if(TEToScrap() != noErr)				ClearCurrentScrap();			break;		case iPaste:			GetCurrentScrap(&scrapRef);;			GetScrapFlavorSize(scrapRef,kScrapFlavorTypeText,&sizeOfTextData);			newSize = (*textEditStrucHdl)->teLength + sizeOfTextData;			if(newSize > kMaxTELength)				doErrorAlert(eNoSpacePaste);			else			{				if(TEFromScrap() == noErr)				{					TEPaste(textEditStrucHdl);					doAdjustScrollbar(windowRef);				}			}			break;		case iClear:			TEDelete(textEditStrucHdl);			doAdjustScrollbar(windowRef);			break;		case iSelectAll:			TESetSelect(0,(*textEditStrucHdl)->teLength,textEditStrucHdl);			break;	}	doDrawDataPanel(windowRef);}// ************************************************************************* doGetSelectLengthSInt16  doGetSelectLength(TEHandle textEditStrucHdl){	SInt16	selectionLength;	selectionLength = (*textEditStrucHdl)->selEnd - (*textEditStrucHdl)->selStart;	return selectionLength;}// ************************************************************************* doAdjustScrollbarvoid  doAdjustScrollbar(WindowRef windowRef){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							numberOfLines, controlMax, controlValue;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	numberOfLines = (*textEditStrucHdl)->nLines;	if(*(*(*textEditStrucHdl)->hText + (*textEditStrucHdl)->teLength - 1) == kReturn)		numberOfLines += 1;	controlMax = numberOfLines - (((*textEditStrucHdl)->viewRect.bottom - 							 (*textEditStrucHdl)->viewRect.top) /							 (*textEditStrucHdl)->lineHeight);	if(controlMax < 0)		controlMax = 0;	SetControlMaximum((*docStrucHdl)->vScrollbarRef,controlMax);	controlValue = ((*textEditStrucHdl)->viewRect.top - (*textEditStrucHdl)->destRect.top) / 									(*textEditStrucHdl)->lineHeight;	if(controlValue < 0)		controlValue = 0;	else if(controlValue > controlMax)		controlValue = controlMax;	SetControlValue((*docStrucHdl)->vScrollbarRef,controlValue);	SetControlViewSize((*docStrucHdl)->vScrollbarRef,(*textEditStrucHdl)->viewRect.bottom - 										 (*textEditStrucHdl)->viewRect.top);		TEScroll(0,((*textEditStrucHdl)->viewRect.top - (*textEditStrucHdl)->destRect.top) - 					 		(GetControlValue((*docStrucHdl)->vScrollbarRef) *							(*textEditStrucHdl)->lineHeight),textEditStrucHdl);}// **************************************************************************** doAdjustCursorvoid  doAdjustCursor(WindowRef windowRef){	GrafPtr		oldPort;	RgnHandle	arrowRegion, iBeamRegion;	Rect			portRect, cursorRect;	Point			mouseXY;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	arrowRegion = NewRgn();	iBeamRegion = NewRgn();		SetRectRgn(arrowRegion,-32768,-32768,32766,32766);	GetWindowPortBounds(windowRef,&portRect);	cursorRect = portRect;	cursorRect.bottom -= 15;	cursorRect.right	-= 15;	LocalToGlobal(&topLeft(cursorRect));	LocalToGlobal(&botRight(cursorRect));		RectRgn(iBeamRegion,&cursorRect);	DiffRgn(arrowRegion,iBeamRegion,arrowRegion);	GetGlobalMouse(&mouseXY);	if(PtInRgn(mouseXY,iBeamRegion))	{		SetThemeCursor(kThemeIBeamCursor);		CopyRgn(iBeamRegion,gCursorRegion);	}	else	{		SetThemeCursor(kThemeArrowCursor);		CopyRgn(arrowRegion,gCursorRegion);	}	DisposeRgn(arrowRegion);	DisposeRgn(iBeamRegion);	SetPort(oldPort);}// ***************************************************************************** doCloseWindowvoid  doCloseWindow(WindowRef windowRef){	docStructureHandle	docStrucHdl;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	DisposeControl((*docStrucHdl)->vScrollbarRef);	TEDispose((*docStrucHdl)->textEditStrucHdl);	DisposeHandle((Handle) docStrucHdl);	DisposeWindow(windowRef);	gNumberOfWindows --;}// ****************************************************************************** doSaveAsFilevoid  doSaveAsFile(TEHandle textEditStrucHdl){	OSErr							osError = noErr;	NavDialogOptions	dialogOptions;	WindowRef					windowRef;	OSType						fileType;	NavEventUPP				navEventFunctionUPP;	NavReplyRecord		navReplyStruc;	AEKeyword					theKeyword;	DescType					actualType;	FSSpec						fileSpec;		SInt16						fileRefNum;	Size							actualSize;	SInt32						dataLength;	Handle						editTextHdl;	osError = NavGetDefaultDialogOptions(&dialogOptions);	if(osError == noErr)	{		windowRef = FrontWindow();		fileType = 'TEXT';		navEventFunctionUPP = NewNavEventUPP((NavEventProcPtr) navEventFunction);		osError = NavPutFile(NULL,&navReplyStruc,&dialogOptions,navEventFunctionUPP,fileType,												 kFileCreator,NULL);		DisposeNavEventUPP(navEventFunctionUPP);		if(navReplyStruc.validRecord && osError == noErr)		{			if((osError = AEGetNthPtr(&(navReplyStruc.selection),1,typeFSS,&theKeyword,																&actualType,&fileSpec,sizeof(fileSpec),&actualSize)) == noErr)			{				if(!navReplyStruc.replacing)				{					osError = FSpCreate(&fileSpec,kFileCreator,fileType,navReplyStruc.keyScript);					if(osError != noErr)					{						NavDisposeReply(&navReplyStruc);					}				}								if(osError == noErr)					osError = FSpOpenDF(&fileSpec,fsRdWrPerm,&fileRefNum);				if(osError == noErr)				{					SetWTitle(windowRef,fileSpec.name);					dataLength = (*textEditStrucHdl)->teLength;					editTextHdl = (*textEditStrucHdl)->hText;					FSWrite(fileRefNum,&dataLength,*editTextHdl);				}				NavCompleteSave(&navReplyStruc,kNavTranslateInPlace);			}			NavDisposeReply(&navReplyStruc);		}	}}// ***************************************************************************** doOpenCommandvoid  doOpenCommand(void){		OSErr							osError	= noErr;	NavDialogOptions	dialogOptions;	NavEventUPP				navEventFunctionUPP;	NavReplyRecord		navReplyStruc;	SInt32						index, count;	AEKeyword					theKeyword;	DescType					actualType;	FSSpec						fileSpec;		Size							actualSize;	FInfo							fileInfo;	osError = NavGetDefaultDialogOptions(&dialogOptions);	if(osError == noErr)	{		navEventFunctionUPP = NewNavEventUPP((NavEventProcPtr) navEventFunction);		osError = NavGetFile(NULL,&navReplyStruc,&dialogOptions,navEventFunctionUPP,NULL,NULL,												 NULL,0);		DisposeNavEventUPP(navEventFunctionUPP);		if(osError == noErr && navReplyStruc.validRecord)		{			osError = AECountItems(&(navReplyStruc.selection),&count);			if(osError == noErr)			{				for(index=1;index<=count;index++)				{					osError = AEGetNthPtr(&(navReplyStruc.selection),index,typeFSS,&theKeyword,																&actualType,&fileSpec,sizeof(fileSpec),&actualSize);					{						if((osError = FSpGetFInfo(&fileSpec,&fileInfo)) == noErr)							doOpenFile(fileSpec);					}				}			}			NavDisposeReply(&navReplyStruc);			}	}}// ************************************************************************** navEventFunctionvoid  navEventFunction(NavEventCallbackMessage callBackSelector,NavCBRecPtr callBackParms,											 NavCallBackUserData callBackUD){	WindowRef	windowRef;	if(callBackParms != NULL)	{		switch(callBackSelector)		{			case kNavCBEvent:				switch(callBackParms->eventData.eventDataParms.event->what)				{					case updateEvt:						windowRef = (WindowRef) callBackParms->eventData.eventDataParms.event->message;						if(GetWindowKind(windowRef) != kDialogWindowKind)							doUpdate((EventRecord*) callBackParms->eventData.eventDataParms.event);						break;				}				break;		}	}}// ******************************************************************************** doOpenFilevoid  doOpenFile(FSSpec fileSpec){	WindowRef 					windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							fileRefNum;	SInt32							textLength;	Handle							textBuffer;	if((windowRef = doNewDocWindow()) == NULL)		return;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	SetWTitle(windowRef,fileSpec.name);	FSpOpenDF(&fileSpec,fsCurPerm,&fileRefNum);	SetFPos(fileRefNum,fsFromStart,0);	GetEOF(fileRefNum,&textLength);	if(textLength > 32767)		textLength = 32767;	textBuffer = NewHandle((Size) textLength);	FSRead(fileRefNum,&textLength,*textBuffer);	MoveHHi(textBuffer);	HLock(textBuffer);	TESetText(*textBuffer,textLength,textEditStrucHdl);	HUnlock(textBuffer);	DisposeHandle(textBuffer);	FSClose(fileRefNum);	(*textEditStrucHdl)->selStart = 0;	(*textEditStrucHdl)->selEnd = 0;}// *************************************************************************** doDrawDataPanelvoid  doDrawDataPanel(WindowRef windowRef){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	RGBColor						whiteColour = { 0xFFFF, 0xFFFF, 0xFFFF };	RGBColor						blackColour = { 0x0000, 0x0000, 0x0000 };	RGBColor						blueColour = { 0x1818, 0x4B4B, 0x8181 };	ControlRef					controlRef;	Rect								panelRect;	Str255							textString;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	controlRef = (*docStrucHdl)->vScrollbarRef;	MoveTo(0,282);	LineTo(495,282);	RGBForeColor(&whiteColour);	RGBBackColor(&blueColour);	SetRect(&panelRect,0,283,495,300);	EraseRect(&panelRect);	MoveTo(3,295);	DrawString("\pteLength               nLines          lineHeight");	MoveTo(225,295);	DrawString("\pdestRect.top              controlValue           contrlMax");	SetRect(&panelRect,47,284,88,299);	EraseRect(&panelRect);		SetRect(&panelRect,124,284,149,299);	EraseRect(&panelRect);		SetRect(&panelRect,204,284,222,299);	EraseRect(&panelRect);		SetRect(&panelRect,286,284,323,299);	EraseRect(&panelRect);		SetRect(&panelRect,389,284,416,299);	EraseRect(&panelRect);		SetRect(&panelRect,472,284,495,299);	EraseRect(&panelRect);		NumToString((SInt32) (*textEditStrucHdl)->teLength,textString);	MoveTo(47,295);	DrawString(textString);	NumToString((SInt32) (*textEditStrucHdl)->nLines,textString);	MoveTo(124,295);	DrawString(textString);	NumToString((SInt32) (*textEditStrucHdl)->lineHeight,textString);	MoveTo(204,295);	DrawString(textString);	NumToString((SInt32) (*textEditStrucHdl)->destRect.top,textString);	MoveTo(286,295);	DrawString(textString);	NumToString((SInt32) GetControlValue(controlRef),textString);	MoveTo(389,295);	DrawString(textString);	NumToString((SInt32) GetControlMaximum(controlRef),textString);	MoveTo(472,295);	DrawString(textString);	RGBForeColor(&blackColour);	RGBBackColor(&whiteColour);}// ****************************************************************************** doErrorAlertvoid  doErrorAlert(SInt16 errorCode){	Str255	errorString;	SInt16	itemHit;	GetIndString(errorString,rErrorStrings,errorCode);	if(errorCode < eWindow)	{		StandardAlert(kAlertStopAlert,errorString,NULL,NULL,&itemHit);		ExitToShell();	}	else	{		StandardAlert(kAlertCautionAlert,errorString,NULL,NULL,&itemHit);	}}// *******************************************************************************************