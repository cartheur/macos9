// *******************************************************************************************// Lists.c// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include "Lists.h"// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesListDefUPP				gListDefFunctionUPP;Boolean						gRunningOnX	= false;backColourPattern	gBackColourPattern;// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	EventTypeSpec	applicationEvents[] =	{ { kEventClassApplication, kEventAppActivated    },																				{ kEventClassCommand,     kEventProcessCommand  },																				{ kEventClassMenu,        kEventMenuEnableItems } };	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииии create universal procedure pointers	gListDefFunctionUPP = NewListDefUPP((ListDefProcPtr) listDefFunction);		// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		ExitToShell();	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}		gRunningOnX = true;	}	else	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)			SetMenuItemCommandID(menuRef,iQuit,kHICommandQuit);	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииии install application event handler  	InstallApplicationEventHandler(NewEventHandlerUPP((EventHandlerProcPtr) appEventHandler),																 GetEventTypeCount(applicationEvents),applicationEvents,																 0,NULL);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии run application event loop	RunApplicationEventLoop();}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	MoreMasterPointers(256);	InitCursor();}// *************************************************************************** appEventHandlerOSStatus  appEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,													void * userData){	OSStatus			result = eventNotHandledErr;	UInt32				eventClass;	UInt32				eventKind;	HICommand			hiCommand;	MenuID				menuID;	MenuItemIndex	menuItem;	WindowClass		windowClass;	eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	switch(eventClass)	{		case kEventClassApplication:			if(eventKind == kEventAppActivated)				SetThemeCursor(kThemeArrowCursor);			break;		case kEventClassCommand:			if(eventKind == kEventProcessCommand)			{				GetEventParameter(eventRef,kEventParamDirectObject,typeHICommand,NULL,													sizeof(HICommand),NULL,&hiCommand);				menuID = GetMenuID(hiCommand.menu.menuRef);				menuItem = hiCommand.menu.menuItemIndex;				if((hiCommand.commandID != kHICommandQuit) && 					 (menuID >= mAppleApplication && menuID <= mDemonstration))				{					doMenuChoice(menuID,menuItem);					result = noErr;				}			}			break;		case kEventClassMenu:			if(eventKind == kEventMenuEnableItems)			{				GetWindowClass(FrontWindow(),&windowClass);				if(windowClass == kDocumentWindowClass)					doAdjustMenus();				result = noErr;			}			break;	}	return result;}// ************************************************************************ windowEventHandlerOSStatus  windowEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,														 void* userData){	OSStatus						result = eventNotHandledErr;	UInt32							eventClass;	UInt32							eventKind;	WindowRef						windowRef;	EventRecord					eventRecord;	docStructureHandle	docStrucHdl;	ControlRef					controlRef = NULL;	ControlPartCode			controlPartCode;	SInt8								charCode;	UInt32							modifiers; 	Point								mouseLocation;	eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	switch(eventClass)	{		case kEventClassWindow:																							 // event class window			GetEventParameter(eventRef,kEventParamDirectObject,typeWindowRef,NULL,sizeof(windowRef),												NULL,&windowRef);			switch(eventKind)			{				case kEventWindowDrawContent:					doDrawContent(windowRef);					result = noErr;					break;				case kEventWindowActivated:					doActivateDeactivate(windowRef,true);					result = noErr;					break;				case kEventWindowDeactivated:					doActivateDeactivate(windowRef,false);					result = noErr;					break;				case kEventWindowClickContentRgn:					GetEventParameter(eventRef,kEventParamMouseLocation,typeQDPoint,NULL,														sizeof(mouseLocation),NULL,&mouseLocation);					SetPortWindowPort(FrontWindow());					GlobalToLocal(&mouseLocation);					GetEventParameter(eventRef,kEventParamKeyModifiers,typeUInt32,NULL,														sizeof(modifiers),NULL,&modifiers);					doInContent(mouseLocation,modifiers);					result = noErr;					break;				case kEventWindowClose:					docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);					LDispose((*docStrucHdl)->textListHdl);					LDispose((*docStrucHdl)->iconListHdl);					DisposeHandle((Handle) docStrucHdl);					DisposeWindow(windowRef);					result = noErr;					break;			}			break;		case kEventClassMouse:																								// event class mouse			switch(eventKind)			{				case kEventMouseDown:					GetEventParameter(eventRef,kEventParamMouseLocation,typeQDPoint,NULL,														sizeof(mouseLocation),NULL,&mouseLocation);					SetPortWindowPort(FrontWindow());					GlobalToLocal(&mouseLocation);					controlRef = FindControlUnderMouse(mouseLocation,FrontWindow(),&controlPartCode);					if(controlRef)					{						doControlHit(FrontWindow(),controlRef,mouseLocation);						result = noErr;					}					break;			}			break;		case kEventClassKeyboard:																					 // event class keyboard			switch(eventKind)			{				case kEventRawKeyDown:					GetEventParameter(eventRef,kEventParamKeyMacCharCodes,typeChar,NULL,														sizeof(charCode),NULL,&charCode);					GetEventParameter(eventRef,kEventParamKeyModifiers,typeUInt32,NULL,														sizeof(modifiers),NULL,&modifiers);					eventRecord.what      = keyDown;					eventRecord.message   = charCode;					eventRecord.when      = EventTimeToTicks(GetEventTime(eventRef));					eventRecord.modifiers = modifiers;					doKeyDown(charCode,&eventRecord);					result = noErr;					break;			}			break;	}	return result;}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef	menuRef;	menuRef = GetMenuRef(mDemonstration);	if(FrontWindow())		DisableMenuItem(menuRef,1);	else		EnableMenuItem(menuRef,1);}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(MenuID menuID,MenuItemIndex menuItem){	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;		case mDemonstration:			if(menuItem == iHandMadeLists)				doOpenListsWindow();			else if(menuItem == iListControlLists)				doListsDialog();			break;	}}// ************************************************************************** doSaveBackgroundvoid  doSaveBackground(backColourPattern *gBackColourPattern){	GrafPtr				currentPort;	PixPatHandle	backPixPatHdl;		GetPort(&currentPort);	GetBackColor(&gBackColourPattern->backColour);	gBackColourPattern->backPixelPattern	= NULL;	backPixPatHdl = NewPixPat();	GetPortBackPixPat(currentPort,backPixPatHdl);	if((*backPixPatHdl)->patType != 0)		gBackColourPattern->backPixelPattern = backPixPatHdl;	else		gBackColourPattern->backBitPattern = *(PatPtr) (*(*backPixPatHdl)->patData);			DisposePixPat(backPixPatHdl);}// *********************************************************************** doRestoreBackgroundvoid  doRestoreBackground(backColourPattern *gBackColourPattern){	RGBBackColor(&gBackColourPattern->backColour);	if(gBackColourPattern->backPixelPattern)		BackPixPat(gBackColourPattern->backPixelPattern);	else		BackPat(&gBackColourPattern->backBitPattern);}// ********************************************************************** doSetBackgroundWhitevoid  doSetBackgroundWhite(void){	RGBColor	whiteColour = { 0xFFFF, 0xFFFF, 0xFFFF };	Pattern		whitePattern;		RGBBackColor(&whiteColour);	GetQDGlobalsWhite(&whitePattern);	BackPat(&whitePattern);}// *******************************************************************************************