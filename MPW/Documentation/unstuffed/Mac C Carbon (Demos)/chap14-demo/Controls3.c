// *******************************************************************************************// Controls3.c// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include "Controls3.h"// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean	gRunningOnX									= false;Boolean	gInBackground								= false;Boolean	gDone;Str255	gCurrentString;Boolean	gBevelAndImageActive				= false;Boolean	gGroupArrowsProgressActive	= false;Boolean	gSlidersActive							= false;// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	EventRecord		eventStructure;	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do prelimiaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus		menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		ExitToShell();	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}		menuRef = GetMenuRef(mDemonstration);		if(menuRef != NULL)			EnableMenuItem(menuRef,iSmallControls);		gRunningOnX = true;	}	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop	gDone = false;	while(!gDone)	{		if(WaitNextEvent(everyEvent,&eventStructure,MAX_UINT32,NULL))			doEvents(&eventStructure);	}}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(512);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************** doEventsvoid  doEvents(EventRecord *eventStrucPtr){	SInt32	menuChoice;	SInt16	menuID, menuItem;	switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case keyDown:			if((eventStrucPtr->modifiers & cmdKey) != 0)			{				menuChoice = MenuEvent(eventStrucPtr);				menuID = HiWord(menuChoice);				menuItem = LoWord(menuChoice);				if(menuID == mFile && menuItem  == iQuit)					gDone = true;			}			break;		case mouseDown:			doMouseDown(eventStrucPtr);			break;		case updateEvt:			doUpdate(eventStrucPtr);			break;		case activateEvt:			doActivate(eventStrucPtr);			break;		case osEvt:			switch((eventStrucPtr->message >> 24) & 0x000000FF)			{				case suspendResumeMessage:					if((eventStrucPtr->message & resumeFlag) == 1)					{						SetThemeCursor(kThemeArrowCursor);						gInBackground = false;					}					else						gInBackground = true;			}			break;	}}// ******************************************************************************* doMouseDownvoid  doMouseDown(EventRecord *eventStrucPtr){	WindowPartCode	partCode;	WindowRef				windowRef;	MenuRef					menuRef;	WindowClass			windowClass;	partCode = FindWindow(eventStrucPtr->where,&windowRef);	switch(partCode)	{		case inMenuBar:			menuRef = GetMenuRef(mDemonstration);			if(gBevelAndImageActive)				DisableMenuItem(menuRef,iBevelAndImage);			else				EnableMenuItem(menuRef,iBevelAndImage);			doMenuChoice(MenuSelect(eventStrucPtr->where));			break;		case inContent:			GetWindowClass(windowRef,&windowClass);			if(windowClass == kFloatingWindowClass)				doMouseDownSmallControls(windowRef,eventStrucPtr);			else if(windowRef != FrontNonFloatingWindow())				SelectWindow(windowRef);			else			{				if(gBevelAndImageActive)					doBevelImagePictIconContent(eventStrucPtr,windowRef);			}			break;		case inDrag:			DragWindow(windowRef,eventStrucPtr->where,NULL);			break;		case inGoAway:			if(TrackGoAway(windowRef,eventStrucPtr->where) == true)			{				DisposeWindow(windowRef);				gBevelAndImageActive = false;			}			break;	}}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;	MenuRef				menuRef;		menuID = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;		case mFile:			if(menuItem == iQuit)				gDone = true;			break;		case mDemonstration:			switch(menuItem)			{				case iBevelAndImage:					gBevelAndImageActive = true;					doBevelImagePictIcon();					break;				case iTabEditClock:					doTabEditClock();					break;				case iGroupArrowsProgress:					gGroupArrowsProgressActive = true;					doGroupArrowsProgress();					break;								case iSliders:					gSlidersActive = true;					doSliderUserPane();					break;				case iTextBoxes:					doTextBox();					break;				case iSmallControls:					doSmallControls();					menuRef = GetMenuRef(mDemonstration);					DisableMenuItem(menuRef,iSmallControls);					break;			}			break;	}	HiliteMenu(0);}// ********************************************************************************** doUpdatevoid  doUpdate(EventRecord *eventStrucPtr){	WindowRef	windowRef;	RgnHandle	visibleRegionHdl = NewRgn();	Boolean		drawMode = false;	windowRef = (WindowRef) eventStrucPtr->message;	BeginUpdate(windowRef);	SetPortWindowPort(windowRef);			GetPortVisibleRegion(GetWindowPort(windowRef),visibleRegionHdl);	UpdateControls(windowRef,visibleRegionHdl);	if(gBevelAndImageActive)	{		if(windowRef == FrontNonFloatingWindow())		{					doDrawMessage(windowRef,!gInBackground);			doDrawLegends(windowRef,!gInBackground);		}		else		{			doDrawMessage(windowRef,gInBackground);			doDrawLegends(windowRef,gInBackground);		}	}	EndUpdate(windowRef);}// ******************************************************************************** doActivatevoid  doActivate(EventRecord *eventStrucPtr){	WindowRef	windowRef;	Boolean		becomingActive;	windowRef = (WindowRef) eventStrucPtr->message;	becomingActive = ((eventStrucPtr->modifiers & activeFlag) == activeFlag);	doActivateWindow(windowRef,becomingActive);}// ************************************************************************** doActivateWindowvoid  doActivateWindow(WindowRef windowRef,Boolean becomingActive){		ControlRef	controlRef;	GetRootControl(windowRef,&controlRef);	if(becomingActive)	{		if(gBevelAndImageActive)		{			ActivateControl(controlRef);			doDrawMessage(windowRef,becomingActive);			doDrawLegends(windowRef,becomingActive);		}	}	else	{		if(gBevelAndImageActive)		{			DeactivateControl(controlRef);			doDrawMessage(windowRef,becomingActive);			doDrawLegends(windowRef,becomingActive);		}	}}// ************************************************************************** doConcatPStringsvoid  doConcatPStrings(Str255 targetString,Str255 appendString){	SInt16	appendLength;	appendLength = MIN(appendString[0],255 - targetString[0]);	if(appendLength > 0)	{		BlockMoveData(appendString+1,targetString+targetString[0]+1,(SInt32) appendLength);		targetString[0] += appendLength;	}}// ***************************************************************************** doCopyPStringvoid  doCopyPString(Str255 sourceString,Str255 destinationString){	SInt16	stringLength;	stringLength = sourceString[0];	BlockMove(sourceString + 1,destinationString + 1,stringLength);	destinationString[0] = stringLength;}// *******************************************************************************************