// *******************************************************************************************// QuickDraw.c                                                             CLASSIC EVENT MODEL// *******************************************************************************************// // This program opens a window in which the results of various QuickDraw drawing operations // are displayed.  Individual line and text drawing, framing, painting, filling, erasing,// inverting, copying, etc., operations are chosen from a Demonstration pull-down menu.//// To keep the non-QuickDraw code to a minimum, the program contains no functions for// updating the window or for responding to activate and operating system events.//// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	'WIND' resources for the main window, and a small window used for the CopyBits//		demonstration (purgeable) (initially visible).//// ╔	An 'MBAR' resource and associated 'MENU' resources (preload, non-purgeable).//// ╔	Two 'ICON' resources (purgeable) used for the boolean source modes demonstration. //// ╔	Two 'PICT' resources (purgeable) used in the arithmetic source modes demonstration.//// ╔	'STR#' resources (purgeable) containing strings used in the source modes and text//		drawing demonstrations.//// ╔	Three 'ppat' resources (purgeable), two of which are used in various drawing, //		framing, painting, filling, and erasing demonstrations.  The third is used in the//		drawing with mouse demonstration.//// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar								128#define mAppleApplication				128#define  iAbout									1#define mFile										129#define  iQuit									12#define mDemonstration					131#define  iLine									1#define  iFrameAndPaint					2#define  iFillEraseInvert				3#define  iPolygonRegion					4#define  iText									5#define  iScrolling							6#define  iBooleanSourceModes		7#define  iArithmeticSourceModes	8#define  iHighlighting					9#define  iDrawWithMouse	 				10#define  iDrawingState					11#define rWindow									128#define rPixelPattern1					128#define rPixelPattern2					129#define rPixelPattern3					130#define rDestinationIcon				128#define rSourceIcon							129#define rFontsStringList				128#define rBooleanStringList			129#define rArithmeticStringList		130#define rPicture								128#define MAX_UINT32							0xFFFFFFFF// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean		gRunningOnX			= false;Boolean		gDone;WindowRef	gWindowRef;Boolean		gDrawWithMouseActivated;SInt16		gPixelDepth;	Boolean		gIsColourDevice	= false;RGBColor 	gWhiteColour		= { 0xFFFF, 0xFFFF, 0xFFFF };RGBColor 	gBlackColour		= { 0x0000, 0x0000, 0x0000 };RGBColor 	gRedColour			= { 0xAAAA, 0x0000, 0x0000 };RGBColor 	gYellowColour		= { 0xFFFF, 0xCCCC, 0x0000 };RGBColor	gGreenColour		= { 0x0000, 0x9999, 0x0000 };RGBColor 	gBlueColour			= { 0x6666, 0x6666, 0x9999 };// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid		main										(void);void		doPreliminaries					(void);OSErr		quitAppEventHandler			(AppleEvent *,AppleEvent *,SInt32);void		doEvents								(EventRecord *);void		doDemonstrationMenu			(MenuItemIndex);void		doLines									(void);void		doFrameAndPaint					(void);void		doFillEraseInvert				(void);void		doPolygonAndRegion			(void);void		doScrolling							(void);void		doText									(void);void		doBooleanSourceModes		(void);void		doArithmeticSourceModes	(void);void		doHighlighting					(void);void		doDrawWithMouse					(void);void		doDrawingState					(void);void		doDrawingStateProof			(SInt16);void		doGetDepthAndDevice			(void);UInt16	doRandomNumber					(UInt16,UInt16);// ************************************************************************************** mainvoid  main(void){	UInt32				seconds;	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	EventRecord		eventStructure;	Boolean				gotEvent;			// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do prelimiaries	doPreliminaries();	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии seed random number generator	GetDateTime(&seconds);	SetQDGlobalsRandomSeed(seconds);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		ExitToShell();	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}		gRunningOnX = true;	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open window	if(!(gWindowRef = GetNewCWindow(rWindow,NULL,(WindowRef)-1)))		ExitToShell();	SetPortWindowPort(gWindowRef);	UseThemeFont(kThemeSmallSystemFont,smSystemScript);	// ииииии get pixel depth and whether colour device for certain Appearance Manager functions		doGetDepthAndDevice();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии eventLoop	gDone = false;	while(!gDone)	{		gotEvent = WaitNextEvent(everyEvent,&eventStructure,MAX_UINT32,NULL);		if(gotEvent)			doEvents(&eventStructure);	}}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(32);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();	}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	SInt32					menuChoice;	MenuID					menuID;	MenuItemIndex		menuItem;	WindowPartCode	partCode;	WindowRef				windowRef;		switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case keyDown:			if((eventStrucPtr->modifiers & cmdKey) != 0)			{				menuChoice = MenuEvent(eventStrucPtr);				menuID = HiWord(menuChoice);				menuItem = LoWord(menuChoice);				if(menuID == mFile && menuItem  == iQuit)					gDone = true;			}			break;		case mouseDown:			if(partCode = FindWindow(eventStrucPtr->where,&windowRef))			{				switch(partCode)				{					case inMenuBar:						menuChoice = MenuSelect(eventStrucPtr->where);						menuID = HiWord(menuChoice);						menuItem = LoWord(menuChoice);						if(menuID == 0)							return;						switch(menuID)						{							case mAppleApplication:								if(menuItem == iAbout)									SysBeep(10);								break;							case mFile:								if(menuItem == iQuit)									gDone = true;								break;															case mDemonstration:								doDemonstrationMenu(menuItem);								break;						}						break;					case inDrag:						DragWindow(windowRef,eventStrucPtr->where,NULL);						break;					case inContent:						if(windowRef != FrontWindow())							SelectWindow(windowRef);						else							if(gDrawWithMouseActivated)								doDrawWithMouse();						break;				}			}			break;		case updateEvt:			windowRef = (WindowRef) eventStrucPtr->message;			BeginUpdate(windowRef);			EndUpdate(windowRef);			break;	}}// *********************************************************************** doDemonstrationMenuvoid	doDemonstrationMenu(MenuItemIndex menuItem){	Rect		portRect;	Pattern	whitePattern;		gDrawWithMouseActivated = false;	switch(menuItem)	{		case iLine:			doLines();			break;		case iFrameAndPaint:			doFrameAndPaint();			break;					case iFillEraseInvert:			doFillEraseInvert();			break;		case iPolygonRegion:			doPolygonAndRegion();			break;		case iText:			doText();			break;		case iScrolling:			doScrolling();			break;		case iBooleanSourceModes:			doBooleanSourceModes();			break;			case iArithmeticSourceModes:			doArithmeticSourceModes();			break;		case iHighlighting:			doHighlighting();			break;		case iDrawWithMouse:			SetWTitle(gWindowRef,"\pDrawing with the mouse");			RGBBackColor(&gWhiteColour);			GetWindowPortBounds(gWindowRef,&portRect);			FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));			gDrawWithMouseActivated = true;			break;		case iDrawingState:			doDrawingState();			break;	}	HiliteMenu(0);}// *********************************************************************************** doLinesvoid  doLines(void){	Rect					portRect, newClipRect;	Pattern				whitePattern, systemPattern, blackPattern;	RgnHandle			oldClipRgn;	SInt16				a, b, c;	RGBColor 			theColour;	UInt32				finalTicks;	PixPatHandle	pixpatHdl;		PenNormal();	RGBBackColor(&gBlueColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	newClipRect = portRect;	InsetRect(&newClipRect,10,10);	oldClipRgn = NewRgn();	GetClip(oldClipRgn);	ClipRect(&newClipRect);	// ииииииииииииииииииииииииииииииии lines drawn with foreground colour and black pen pattern	SetWTitle(gWindowRef,"\pDrawing lines with colours");	RGBBackColor(&gWhiteColour);	FillRect(&portRect,&whitePattern);	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	for(a=1;a<60;a++)	{		b = doRandomNumber(0,portRect.right - portRect.left);		c = doRandomNumber(0,portRect.right - portRect.left);		theColour.red   = doRandomNumber(0,65535);		theColour.green = doRandomNumber(0,65535);		theColour.blue  = doRandomNumber(0,65535);		RGBForeColor(&theColour);			PenSize(a * 2,1);				MoveTo(b,portRect.top);		LineTo(c,portRect.bottom);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(2,&finalTicks);	}	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);	// иииииииииииииииииииииииииииииииииииииииииии lines drawn with system-supplied bit patterns	SetWTitle(gWindowRef,"\pClick mouse for more lines");	QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	while(!Button()) ;		SetWTitle(gWindowRef,"\pDrawing lines with system-supplied bit patterns");	FillRect(&portRect,&whitePattern);	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	for(a=1;a<39;a++)	{		b = doRandomNumber(0,portRect.bottom - portRect.top);		c = doRandomNumber(0,portRect.bottom - portRect.top);		theColour.red   = doRandomNumber(0,32767);		theColour.green = doRandomNumber(0,32767);		theColour.blue  = doRandomNumber(0,32767);		RGBForeColor(&theColour);			GetIndPattern(&systemPattern,sysPatListID,a);		PenPat(&systemPattern);		PenSize(1, a * 2);				MoveTo(portRect.left,b);		LineTo(portRect.right,c);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(5,&finalTicks);	}	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииии lines drawn with a pixel pattern	SetWTitle(gWindowRef,"\pClick mouse for more lines");	QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	while(!Button()) ;		SetWTitle(gWindowRef,"\pDrawing lines with a pixel pattern");	FillRect(&portRect,&whitePattern);	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	if(!(pixpatHdl = GetPixPat(rPixelPattern1)))		ExitToShell();	PenPixPat(pixpatHdl);	for(a=1;a<60;a++)	{		b = doRandomNumber(0,portRect.right - portRect.left);		c = doRandomNumber(0,portRect.right - portRect.left);		PenSize(a * 2,1);				MoveTo(b,portRect.top);		LineTo(c,portRect.bottom);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(5,&finalTicks);	}	DisposePixPat(pixpatHdl);	SetClip(oldClipRgn);	DisposeRgn(oldClipRgn);	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);	// ииииииииииииииииииииииииииииииииииииииииииииииииииии lines drawn with pattern mode patXor	SetWTitle(gWindowRef,"\pClick mouse for more lines");	QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	while(!Button()) ;	SetWTitle(gWindowRef,"\pDrawing lines using pattern mode patXor");	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	RGBBackColor(&gRedColour);	FillRect(&portRect,&whitePattern);	PenSize(1,1);			PenPat(GetQDGlobalsBlack(&blackPattern));	PenMode(patXor);	InsetRect(&portRect,10,10);	for(a = portRect.left,b = portRect.right;a < portRect.right + 1;a++,b--)	{		MoveTo(a,portRect.top);		LineTo(b,portRect.bottom);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	}	for(a = portRect.bottom,b = portRect.top;b < portRect.bottom + 1;a--,b++)	{		MoveTo(portRect.left,a);		LineTo(portRect.right,b);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	}	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);}// *************************************************************************** doFrameAndPaintvoid  doFrameAndPaint(void){	SInt16				a;	Rect					portRect, theRect;	Pattern				whitePattern;	UInt32				finalTicks;	Pattern				systemPattern;	PixPatHandle	pixpatHdl;		PenNormal();	PenSize(30,20);		for(a=0;a<3;a++)	{		RGBBackColor(&gWhiteColour);		GetWindowPortBounds(gWindowRef,&portRect);		FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));		if(!gRunningOnX)			SetThemeCursor(kThemeWatchCursor);		// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии preparation		if(a == 0)		{			SetWTitle(gWindowRef,"\pFraming and painting with a colour");			RGBForeColor(&gRedColour);															 // set foreground colour to red		}		else if(a == 1)		{			SetWTitle(gWindowRef,"\pFraming and painting with a bit pattern");			RGBForeColor(&gBlueColour);															// set foreground colour to blue			RGBBackColor(&gYellowColour);													// set foreground colour to yellow			GetIndPattern(&systemPattern,sysPatListID,16);								// get bit pattern for pen			PenPat(&systemPattern);																						// set pen bit pattern		}		else if (a == 2)		{			SetWTitle(gWindowRef,"\pFraming and painting with a pixel pattern");			if(!(pixpatHdl = GetPixPat(rPixelPattern1)))								// get pixel pattern for pen				ExitToShell();			PenPixPat(pixpatHdl);																						// set pen pixel pattern		}		// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии framing and painting			SetRect(&theRect,30,32,151,191);				FrameRect(&theRect);																													// FrameRect		MoveTo(30,29);		DrawString("\pFrameRect");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		FrameRoundRect(&theRect,30,50);																					 // FrameRoundRect		MoveTo(170,29);		DrawString("\pFrameRoundRect");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		FrameOval(&theRect);																													// FrameOval		MoveTo(310,29);		DrawString("\pFrameOval");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		FrameArc(&theRect,330,300);																										 // FrameArc		MoveTo(450,29);		DrawString("\pFrameArc");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);			OffsetRect(&theRect,-420,186);		PaintRect(&theRect);																													// PaintRect		MoveTo(30,214);		DrawString("\pPaintRect");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		PaintRoundRect(&theRect,30,50);																					 // PaintRoundRect		MoveTo(170,214);		DrawString("\pPaintRoundRect");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		PaintOval(&theRect);																													// PaintOval		MoveTo(310,214);		DrawString("\pPaintOval");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		PaintArc(&theRect,330,300);																										 // PaintArc		MoveTo(450,214);		DrawString("\pPaintArc");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);			if(!gRunningOnX)			SetThemeCursor(kThemeArrowCursor);		if(a < 2)		{			SetWTitle(gWindowRef,"\pClick mouse for more");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);			while(!Button()) ;		}		}	DisposePixPat(pixpatHdl);}// ************************************************************************* doFillEraseInvertvoid  doFillEraseInvert(void){	SInt16				a;	Rect					portRect, theRect;	Pattern				whitePattern, fillPat, backPat;	PixPatHandle	fillPixpatHdl, backPixpatHdl;		UInt32				finalTicks;	PenNormal();	PenSize(30,20);	for(a=0;a<4;a++)	{		if(a < 3)		{			RGBBackColor(&gWhiteColour);			GetWindowPortBounds(gWindowRef,&portRect);			FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));		}		if(!gRunningOnX)			SetThemeCursor(kThemeWatchCursor);		// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии preparation		if(a == 0)		{			SetWTitle(gWindowRef,"\pFilling and erasing with colours");			RGBForeColor(&gBlueColour);														 // set blue colour for foreground			RGBBackColor(&gRedColour);															// set red colour for background			GetIndPattern(&fillPat,sysPatListID,1);			 // get black bit pattern for fill functions			BackPat(&whitePattern);													 // set white bit pattern for background		}		else if(a == 1)		{			SetWTitle(gWindowRef,"\pFilling and erasing with bit patterns");			RGBForeColor(&gBlueColour);														 // set blue colour for foreground			RGBBackColor(&gYellowColour);												 // set yellow colour for background			GetIndPattern(&fillPat,sysPatListID,37);					 // get bit pattern for fill functions			GetIndPattern(&backPat,sysPatListID,19);							 // get bit pattern for background			BackPat(&backPat);																		 // set bit pattern for background		}		else if (a == 2)		{			SetWTitle(gWindowRef,"\pFilling and erasing with pixel patterns");			if(!(fillPixpatHdl = GetPixPat(rPixelPattern1)))			// get pixel patt - fill functions				ExitToShell();			if(!(backPixpatHdl = GetPixPat(rPixelPattern2)))			 // get pixel pattern - background				ExitToShell();			BackPixPat(backPixpatHdl);														 // set pixel pattern - background		}		else if(a == 3)		{			SetWTitle(gWindowRef,"\pInverting");			BackPat(&whitePattern);			SetRect(&theRect,30,15,570,29);			EraseRect(&theRect);			SetRect(&theRect,30,200,570,214);			EraseRect(&theRect);		}		// иииииииииииииииииииииииииииииииииииииииииииииииииииииии filling, erasing, and inverting				SetRect(&theRect,30,32,151,191);				MoveTo(30,29);		if(a < 2)		{			FillRect(&theRect,&fillPat);																								 // FillRect			DrawString("\pFillRect");			}		else if(a == 2)		{			FillCRect(&theRect,fillPixpatHdl);																					// FillCRect			DrawString("\pFillCRect");			}		else if(a == 3)		{			InvertRect(&theRect);																											 // InvertRect			DrawString("\pInvertRect");			}				QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		MoveTo(170,29);		if(a < 2)		{			FillRoundRect(&theRect,30,50,&fillPat);																	// FillRoundRect			DrawString("\pFillRoundRect");			}		else if(a == 2)		{			FillCRoundRect(&theRect,30,50,fillPixpatHdl);													 // FillCRoundRect			DrawString("\pFillCRoundRect");			}		else if(a == 3)		{			InvertRoundRect(&theRect,30,50);																			// InvertRoundRect			DrawString("\pInvertRoundRect");			}				QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		MoveTo(310,29);		if(a < 2)		{			FillOval(&theRect,&fillPat);																								 // FillOval			DrawString("\pFillOval");			}		else if(a == 2)		{			FillCOval(&theRect,fillPixpatHdl);																					// FillCOval			DrawString("\pFillCOval");			}		else if(a == 3)		{			InvertOval(&theRect);																											 // InvertOval			DrawString("\pInvertOval");			}				QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		MoveTo(450,29);		if(a < 2)		{			FillArc(&theRect,330,300,&fillPat);																						// FillArc			DrawString("\pFillArc");			}		else if(a == 2)		{			FillCArc(&theRect,330,300,fillPixpatHdl);																		 // FillCArc			DrawString("\pFillCArc");			}		else if(a == 3)		{			InvertArc(&theRect,330,300);																								// InvertArc			DrawString("\pInvertArc");			}				QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);			OffsetRect(&theRect,-420,186);		MoveTo(30,214);		if(a < 3)		{			EraseRect(&theRect);																												// EraseRect			DrawString("\pEraseRect");			}		else		{			InvertRect(&theRect);																											 // InvertRect			DrawString("\pInvertRect");			}		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		MoveTo(170,214);		if(a < 3)		{			EraseRoundRect(&theRect,30,50);																				 // EraseRoundRect			DrawString("\pEraseRoundRect");			}		else		{			InvertRoundRect(&theRect,30,50);																			// InvertRoundRect			DrawString("\pInvertRoundRect");			}		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		MoveTo(310,214);		if(a < 3)		{				EraseOval(&theRect);																												// EraseOval			DrawString("\pEraseOval");			}		else		{			InvertOval(&theRect);																											 // InvertOval			DrawString("\pInvertOval");			}		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		OffsetRect(&theRect,140,0);		MoveTo(450,214);		if(a < 3)		{			EraseArc(&theRect,330,300);																									 // EraseArc			DrawString("\pEraseArc");			}		else		{			InvertArc(&theRect,330,300);																								// InvertArc			DrawString("\pInvertArc");			}		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);		if(!gRunningOnX)			SetThemeCursor(kThemeArrowCursor);		if(a < 3)		{			SetWTitle(gWindowRef,"\pClick mouse for more");			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);			while(!Button()) ;		}		}	DisposePixPat(fillPixpatHdl);	DisposePixPat(backPixpatHdl);}// ************************************************************************ doPolygonAndRegionvoid  doPolygonAndRegion(void){	Rect					portRect, theRect;	Pattern				whitePattern, backPat;	PixPatHandle	fillPixpatHdl;		PolyHandle		polygonHdl;	RgnHandle			regionHdl;	UInt32				finalTicks;	SetWTitle(gWindowRef,"\pFraming, painting, filling, and erasing polygons and regions");	RGBBackColor(&gWhiteColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии preparation	GetIndPattern(&backPat,sysPatListID,17);									 // get bit pattern for background	BackPat(&backPat);																				 // set bit pattern for background	if(!(fillPixpatHdl = GetPixPat(rPixelPattern2)))		 // get pixel pattern for fill functions		ExitToShell();	RGBForeColor(&gRedColour);																	// set red colour for foreground	RGBBackColor(&gYellowColour);														 // set yellow colour for background	PenNormal();		polygonHdl = OpenPoly();																									 // define polygon	MoveTo(30,32);	LineTo(151,32);	LineTo(96,103);	LineTo(151,134);		LineTo(151,191);	LineTo(30,191);	LineTo(66,75);	ClosePoly();	regionHdl = NewRgn();																												// define region	OpenRgn();	SetRect(&theRect,30,218,151,279);	FrameRect(&theRect);	SetRect(&theRect,30,316,151,377);	FrameRect(&theRect);	SetRect(&theRect,39,248,142,341);	FrameOval(&theRect);	CloseRgn(regionHdl);	// иииииииииииииииииииииииииииииииииииииииииииииииии framing, painting, filling, and erasing	FramePoly(polygonHdl);																													// FramePoly	MoveTo(30,29);	DrawString("\pFramePoly (colour)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	Delay(30,&finalTicks);	OffsetPoly(polygonHdl,140,0);	PaintPoly(polygonHdl);																													// PaintPoly	MoveTo(170,29);	DrawString("\pPaintPoly (colour)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	Delay(30,&finalTicks);	OffsetPoly(polygonHdl,140,0);	FillCPoly(polygonHdl,fillPixpatHdl);																						// FillCPoly	MoveTo(310,29);	DrawString("\pFillCPoly (pixel pattern)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	Delay(30,&finalTicks);	OffsetPoly(polygonHdl,140,0);	ErasePoly(polygonHdl);																													// ErasePoly	MoveTo(450,29);	DrawString("\pErasePoly (bit pattern)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	Delay(30,&finalTicks);		FrameRgn(regionHdl);																														 // FrameRgn	MoveTo(30,214);	DrawString("\pFrameRgn (colour)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	Delay(30,&finalTicks);	OffsetRgn(regionHdl,140,0);	PaintRgn(regionHdl);																														 // PaintRgn	MoveTo(170,214);	DrawString("\pPaintRgn (colour)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	Delay(30,&finalTicks);	OffsetRgn(regionHdl,140,0);	FillCRgn(regionHdl,fillPixpatHdl);																							 // FillCRgn	MoveTo(310,214);	DrawString("\pFillCRgn (pixel pattern)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	Delay(30,&finalTicks);	OffsetRgn(regionHdl,140,0);	EraseRgn(regionHdl);																														 // EraseRgn	MoveTo(450,214);	DrawString("\pEraseRgn (bit pattern)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	Delay(30,&finalTicks);	KillPoly(polygonHdl);	DisposeRgn(regionHdl);	DisposePixPat(fillPixpatHdl);	BackPat(&whitePattern);		if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);}// ************************************************************************************ doTextvoid  doText(void){	Rect		portRect, theRect;	Pattern	whitePattern;	SInt16	windowCentre, a, fontNum, stringWidth;	Str255	textString;	UInt32	finalTicks;			RGBBackColor(&gWhiteColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));               	SetWTitle(gWindowRef,"\pDrawing text with default source mode (srcOr)");		windowCentre = (portRect.right - portRect.left) / 2;	SetRect(&theRect,windowCentre,portRect.top,portRect.right,portRect.bottom);	RGBBackColor(&gBlueColour);	FillRect(&theRect,&whitePattern);	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	for(a=1;a<9;a++)	{		// иииииииииииииииииииииииииии set various text fonts, text styles, and foreground colours		if(a == 1)		{			GetFNum("\pGeneva",&fontNum);			TextFont(fontNum);			TextFace(normal);			RGBForeColor(&gRedColour);		}		else if(a == 2)			TextFace(bold);		else if(a == 3)		{			GetFNum("\pTimes",&fontNum);			TextFont(fontNum);			TextFace(italic);			RGBForeColor(&gYellowColour);		}		else if(a == 4)			TextFace(underline);		else if(a == 5)		{			GetFNum("\pHelvetica",&fontNum);			TextFont(fontNum);			TextFace(normal);			RGBForeColor(&gGreenColour);		}		else if(a == 6)			TextFace(bold + italic);		else if(a == 7)		{			GetFNum("\pCharcoal",&fontNum);			TextFont(fontNum);			TextFace(condense);			RGBForeColor(&gBlackColour);		}		else if(a == 8)		{			TextFace(extend);		}		// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set text size		if(a < 7)			TextSize(a * 2 + 15);		else			TextSize(12);					// ииииииииии get a string and draw it in the set font, style, size, and foreground colour		GetIndString(textString,rFontsStringList,a);		stringWidth = StringWidth(textString);		MoveTo(windowCentre - (stringWidth / 2),a * 46 - 10);		DrawString(textString);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(30,&finalTicks);	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии reset to Geneva 10pt normal	GetFNum("\pGeneva",&fontNum);	TextFont(fontNum);	TextSize(10);	TextFace(normal);	// ииииииииииии erase a rectangle, get a string, and use TETextBox to draw it left justified	SetRect(&theRect,portRect.left + 5,portRect.bottom - 55,portRect.left + 118,					portRect.bottom - 5);	EraseRect(&theRect);	InsetRect(&theRect,5,5);	GetIndString(textString,rFontsStringList,9);	RGBForeColor(&gWhiteColour);	TETextBox(&textString[1],textString[0],&theRect,teFlushLeft);	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);}// ******************************************************************************* doScrollingvoid  doScrolling(void){	Rect					portRect, theRect;	Pattern				whitePattern;	PixPatHandle	pixpat1Hdl, pixpat2Hdl;	RgnHandle			oldClipHdl, regionAHdl, regionBHdl, regionCHdl, scrollRegionHdl;	SInt16				a;	UInt32				finalTicks;	SetWTitle(gWindowRef,"\pScrolling pixels");	RGBBackColor(&gWhiteColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	if(!(pixpat1Hdl = GetPixPat(rPixelPattern1)))		ExitToShell();	PenPixPat(pixpat1Hdl);	PenSize(50,0);	SetRect(&theRect,30,30,286,371);	FrameRect(&theRect);	SetRect(&theRect,315,30,571,371);	FillCRect(&theRect,pixpat1Hdl);	if(!(pixpat2Hdl = GetPixPat(rPixelPattern2)))		ExitToShell();		BackPixPat(pixpat2Hdl);	regionAHdl = NewRgn();	regionBHdl = NewRgn();	regionCHdl = NewRgn();	SetRect(&theRect,80,30,236,371);	RectRgn(regionAHdl,&theRect);	SetRect(&theRect,315,30,571,371);	RectRgn(regionBHdl,&theRect);	UnionRgn(regionAHdl,regionBHdl,regionCHdl);	oldClipHdl = NewRgn();	GetClip(oldClipHdl);	SetClip(regionCHdl);	SetRect(&theRect,80,30,571,371);	scrollRegionHdl = NewRgn();	for(a=0;a<371;a++)	{		ScrollRect(&theRect,0,1,scrollRegionHdl);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		theRect.top ++;		Delay(1,&finalTicks);	}	SetRect(&theRect,80,30,571,371);	BackPixPat(pixpat1Hdl);	for(a=0;a<371;a++)	{		ScrollRect(&theRect,0,-1,scrollRegionHdl);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		theRect.bottom --;		Delay(1,&finalTicks);	}	SetClip(oldClipHdl);	DisposePixPat(pixpat1Hdl);	DisposePixPat(pixpat2Hdl);	DisposeRgn(oldClipHdl);	DisposeRgn(regionAHdl);	DisposeRgn(regionBHdl);	DisposeRgn(regionCHdl);	DisposeRgn(scrollRegionHdl);	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);}// ********************************************************************** doBooleanSourceModesvoid  doBooleanSourceModes(void){	Rect					portRect, theRect;	Pattern				whitePattern;	Handle				destIconHdl, sourceIconHdl;	SInt16				a, b;	UInt32				finalTicks;	BitMap				sourceIconMap;	Str255				sourceString;	PixMapHandle	destinationPixMapHdl;	SetWTitle(gWindowRef,"\pBoolean source modes");	RGBForeColor(&gBlackColour);	RGBBackColor(&gGreenColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	SetRect(&theRect,portRect.left,portRect.top,portRect.right,					(portRect.bottom - portRect.top) / 2);	RGBBackColor(&gWhiteColour);	FillRect(&theRect,&whitePattern);		if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	destIconHdl = GetIcon(rDestinationIcon);	sourceIconHdl = GetIcon(rSourceIcon);	for(a=0;a<2;a++)	{		if(a == 1)		{			RGBForeColor(&gYellowColour);			RGBBackColor(&gRedColour);		}		SetRect(&theRect,235,a * 191 + 30,299,a * 191 + 94);		PlotIcon(&theRect,destIconHdl);		MoveTo(235,a * 191 + 27);		DrawString("\pDestination");		SetRect(&theRect,304,a * 191 + 30,368,a * 191 + 94);		PlotIcon(&theRect,sourceIconHdl);		MoveTo(304,a * 191 + 27);		DrawString("\pSource");	}	RGBForeColor(&gBlackColour);	RGBBackColor(&gWhiteColour);	for(a=0;a<2;a++)	{		if(a == 1)		{			RGBForeColor(&gYellowColour);			RGBBackColor(&gRedColour);		}				for(b=0;b<8;b++)		{			SetRect(&theRect,b * 69 + 28,a * 191 + 121,b * 69 + 92,a * 191 + 185);			PlotIcon(&theRect,destIconHdl);		}	}	QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	RGBForeColor(&gBlackColour);	RGBBackColor(&gWhiteColour);	HLock(sourceIconHdl);	sourceIconMap.baseAddr = *sourceIconHdl;	sourceIconMap.rowBytes = 4;	SetRect(&sourceIconMap.bounds,0,0,32,32);	destinationPixMapHdl = GetPortPixMap(GetQDGlobalsThePort());	for(a=0;a<2;a++)	{		if(a == 1)		{			RGBForeColor(&gYellowColour);			RGBBackColor(&gRedColour);		}				for(b=0;b<8;b++)		{			Delay(30,&finalTicks);			SetRect(&theRect,b * 69 + 28,a * 191 + 121,b * 69 + 92,a * 191 + 185);			CopyBits(&sourceIconMap,							 (BitMap *) *destinationPixMapHdl,							 &sourceIconMap.bounds,							 &theRect,							 b,NULL);			GetIndString(sourceString,rBooleanStringList,b + 1);			MoveTo(b * 69 + 28,a * 191 + 118);			DrawString(sourceString);			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		}	}	HUnlock(sourceIconHdl);	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);}// ******************************************************************* doArithmeticSourceModesvoid  doArithmeticSourceModes(void){	Rect					portRect, sourceRect, destRect;	Pattern				whitePattern;	PicHandle			sourceHdl, destinationHdl;	SInt16				a, b, arithmeticMode = 32;	PixMapHandle	currentPixMapHdl;	Str255				modeString;	UInt32				finalTicks;	SetWTitle(gWindowRef,"\pCopyBits with arithmetic source modes");	RGBForeColor(&gBlackColour);	RGBBackColor(&gWhiteColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	if(!(sourceHdl = GetPicture(rPicture)))		ExitToShell();	SetRect(&sourceRect,44,21,201,133);	HNoPurge((Handle) sourceHdl);	DrawPicture(sourceHdl,&sourceRect);	HPurge((Handle) sourceHdl);	MoveTo(44,19);	DrawString("\pSOURCE IMAGE");	if(!(destinationHdl = GetPicture(rPicture + 1)))		ExitToShell();	HNoPurge((Handle) destinationHdl);	for(a=44;a<403;a+=179)	{		for(b=21;b<274;b+=126)		{			if(a == 44 && b == 21)			 continue;			SetRect(&destRect,a,b,a+157,b+112);			DrawPicture(destinationHdl,&destRect);		}	}	HPurge((Handle) destinationHdl);	QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	currentPixMapHdl = GetPortPixMap(GetWindowPort(gWindowRef));	for(a=44;a<403;a+=179)	{		for(b=21;b<274;b+=126)		{			if(a == 44 && b == 21)			 continue;					Delay(60,&finalTicks);			GetIndString(modeString,rArithmeticStringList,arithmeticMode - 31);			MoveTo(a,b - 2);			DrawString(modeString);			SetRect(&destRect,a,b,a+157,b+112);			CopyBits((BitMap *) *currentPixMapHdl,							 (BitMap *) *currentPixMapHdl,							 &sourceRect,&destRect,							 arithmeticMode + ditherCopy,NULL);			arithmeticMode ++;			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		}	}	ReleaseResource((Handle) sourceHdl);	ReleaseResource((Handle) destinationHdl);		if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);}// **************************************************************************** doHighlightingvoid  doHighlighting(void){	Rect			portRect, theRect;	Pattern		whitePattern;	RGBColor	oldHighlightColour;	SInt16		a;	UInt8			hiliteVal;	UInt32		finalTicks;	SetWTitle(gWindowRef,"\pHighlighting");	RGBForeColor(&gBlackColour);	RGBBackColor(&gWhiteColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	LMGetHiliteRGB(&oldHighlightColour);	for(a=0;a<3;a++)	{		MoveTo(50,a * 100 + 60);		DrawString("\pClearing the highlight bit and calling InvertRect.");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(60,&finalTicks);		SetRect(&theRect,44,a * 100 + 44,557,a * 100 + 104);		hiliteVal = LMGetHiliteMode();		BitClr(&hiliteVal,pHiliteBit);		LMSetHiliteMode(hiliteVal);		if(a == 1)			HiliteColor(&gYellowColour);		else if(a == 2)			HiliteColor(&gGreenColour);		InvertRect(&theRect);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		MoveTo(50,a * 100 + 75);		Delay(60,&finalTicks);		DrawString("\pClick mouse to unhighlight.  ");		DrawString("\p(Note:  The call to InvertRect reset the highlight bit ...");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		while(!Button()) ;		MoveTo(45,a * 100 + 90);		DrawString("\p... so we clear the highlight bit again before calling InvertRect.)");		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);		Delay(60,&finalTicks);		LMSetHiliteMode(hiliteVal);		InvertRect(&theRect);			QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);	}	HiliteColor(&oldHighlightColour);	Delay(60,&finalTicks);	MoveTo(50,350);	DrawString("\pOriginal highlight colour has been reset.");	QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);}// *************************************************************************** doDrawWithMousevoid  doDrawWithMouse(void){	Rect					portRect, drawRect;	Pattern				whitePattern, blackPattern;	PixPatHandle	pixpatHdl;	Point					initialMouse, previousMouse, currentMouse;	UInt16				randomNumber;	RGBColor			theColour;	RGBBackColor(&gWhiteColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	if(!(pixpatHdl = GetPixPat(rPixelPattern3)))		ExitToShell();	PenPixPat(pixpatHdl);	PenSize(1,1);	PenMode(patXor);	GetMouse(&initialMouse);                     	drawRect.left = drawRect.right  = initialMouse.h;	drawRect.top  = drawRect.bottom = initialMouse.v;	GetMouse(&previousMouse);	while(StillDown())	{		GetMouse(&currentMouse);		if(currentMouse.v != previousMouse.v || currentMouse.h != previousMouse.h)		{			FrameRect(&drawRect);			if(currentMouse.h >= initialMouse.h)				drawRect.right = currentMouse.h;			if(currentMouse.v >= initialMouse.v)				drawRect.bottom = currentMouse.v;			if(currentMouse.h <= initialMouse.h)				drawRect.left = currentMouse.h;			if(currentMouse.v <= initialMouse.v)				drawRect.top = currentMouse.v;						FrameRect(&drawRect);		}		previousMouse.v = currentMouse.v;		previousMouse.h = currentMouse.h;	}	FrameRect(&drawRect);	theColour.red   = doRandomNumber(0,65535);	theColour.green = doRandomNumber(0,65535);	theColour.blue  = doRandomNumber(0,65535);	RGBForeColor(&theColour);	PenMode(patCopy);	PenPat(GetQDGlobalsBlack(&blackPattern));	BackPixPat(pixpatHdl);	randomNumber = doRandomNumber(0,3);	if(randomNumber == 0)		PaintRect(&drawRect);	else if(randomNumber == 1)		EraseRoundRect(&drawRect,50,50);		else if(randomNumber == 2)		PaintOval(&drawRect);		else if(randomNumber == 3)		PaintArc(&drawRect,0,doRandomNumber(0,360));		BackPat(&whitePattern);}      // *************************************************************************** doDrawingStatevoid  doDrawingState(void){	Rect							portRect, theRect;	Pattern						whitePattern;	ThemeDrawingState	themeDrawingState;	SInt16						a;	UInt32						finalTicks;		RGBBackColor(&gBlueColour);	GetWindowPortBounds(gWindowRef,&portRect);	FillRect(&portRect,GetQDGlobalsWhite(&whitePattern));	SetWTitle(gWindowRef,"\pSaving and restoring the graphics port drawing state");	if(!gRunningOnX)		SetThemeCursor(kThemeWatchCursor);	NormalizeThemeDrawingState();	doDrawingStateProof(0);	Delay(120,&finalTicks);	GetThemeDrawingState(&themeDrawingState);	theRect = portRect;	theRect.right -= 300;	SetThemeBackground(kThemeBrushListViewBackground,gPixelDepth,gIsColourDevice);	EraseRect(&theRect);	theRect.left += 150;	SetThemeBackground(kThemeBrushListViewSortColumnBackground,gPixelDepth,gIsColourDevice);	EraseRect(&theRect);	SetThemePen(kThemeBrushListViewSeparator,gPixelDepth,gIsColourDevice);	theRect.left -= 150;	for(a=theRect.top;a<=theRect.bottom;a+=18)	{		MoveTo(theRect.left,a);		LineTo(theRect.right - 1,a);	}	Delay(120,&finalTicks);		doDrawingStateProof(1);	Delay(120,&finalTicks);		SetThemeDrawingState(themeDrawingState,true);	doDrawingStateProof(2);	if(!gRunningOnX)		SetThemeCursor(kThemeArrowCursor);}// ********************************************************************** doDrawingStateProofvoid  doDrawingStateProof(SInt16 phase){	Rect	theRect;	MoveTo(324,phase * 117 + 41);	if(phase == 0)		DrawString("\pBefore calls to SetThemePen and SetThemeBackground");	else if(phase == 1)		DrawString("\pAfter calls to SetThemePen and SetThemeBackground");	else if(phase == 2)		DrawString("\pAfter restoration of graphics port drawing state");	MoveTo(324,phase * 117 + 54);	DrawString("\pPen pattern/colour");	MoveTo(462,phase * 117 + 54);	DrawString("\pBackgrd pattern/colour");	SetRect(&theRect,324,phase * 117 + 58,438,phase * 117 + 132);			PaintRect(&theRect);	SetRect(&theRect,462,phase * 117 + 58,576,phase * 117 + 132);			EraseRect(&theRect);		QDFlushPortBuffer(GetWindowPort(FrontWindow()),NULL);}// *********************************************************************** doGetDepthAndDevicevoid doGetDepthAndDevice(void){	GDHandle	deviceHdl;	deviceHdl = GetMainDevice();	gPixelDepth = (*(*deviceHdl)->gdPMap)->pixelSize;	if(((1 << gdDevType) & (*deviceHdl)->gdFlags) != 0)		gIsColourDevice = true;}// **************************************************************************** doRandomNumberUInt16  doRandomNumber(UInt16 minimum,UInt16 maximum){	UInt16	randomNumber;	SInt32	range, t;	randomNumber = Random();	range = maximum - minimum + 1;	t = (randomNumber * range) / 65536;	return (t + minimum);}// *******************************************************************************************