// *******************************************************************************************// MonoTextEdit.c                                                           CARBON EVENT MODEL// *******************************************************************************************//// This program demonstrates://// ╔	A "bare-bones" monostyled text editor.//// ╔	A Help dialog which features the integrated scrolling of multistyled text and pictures.//// In the monostyled text editor demonstration, a panel is displayed at the bottom of all// opened windows.  This panel displays the edit record length, number of lines, line height,// destination rectangle (top), scroll bar/scroller value, and scroll bar/scroller maximum // value. //// The bulk of the source code for the Help dialog is contained in the file HelpDialog.c.// The dialog itself displays information intended to assist the user in adapting the Help// dialog source code and resources to the requirements of his/her own application.//// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	An 'MBAR' resource, and 'MENU' resources for Apple, File, Edit, and Help dialog pop-up//		menus (preload, non-purgeable).  //// ╔	A 'CNTL' resources (purgeable) for the vertical scroll bar in the text editor window.//     // ╔	'TEXT' and associated 'styl' resources (all purgeable) for the Help dialog.//// ╔	'PICT' resources (purgeable) for the Help dialog.//// ╔	A 'STR#' resource  (purgeable) containing error text strings.  //// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar					128#define mAppleApplication	128#define  iAbout						1#define  iHelp  					2#define mFile							129#define  iNew							1#define  iOpen						2#define  iClose						4#define  iSaveAs					6#define  iQuit						12#define mEdit							130#define  iUndo						1#define  iCut							3#define  iCopy						4#define  iPaste						5#define  iClear						6#define  iSelectAll				7#define rVScrollbar				128#define rErrorStrings			128#define  eMenuBar					1#define  eWindow					2#define  eDocStructure		3#define  eEditRecord			4#define  eExceedChara			5#define  eNoSpaceCut			6#define  eNoSpacePaste		7#define kMaxTELength			32767#define kTab							0x09#define kBackSpace				0x08#define kForwardDelete		0x7F#define kReturn						0x0D#define kEscape						0x1B#define topLeft(r)				(((Point *) &(r))[0])#define botRight(r)				(((Point *) &(r))[1])// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии typedefstypedef struct{	TEHandle		textEditStrucHdl;	ControlRef	vScrollbarRef;} docStructure, **docStructureHandle;// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean						gRunningOnX = false;MenuID						gHelpMenu;ControlActionUPP	gScrollActionFunctionUPP;TEClickLoopUPP		gCustomClickLoopUPP;SInt16						gNumberOfWindows = 0;SInt16 						gOldControlValue;// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid						main									(void);void						doPreliminaries				(void);OSStatus				appEventHandler				(EventHandlerCallRef,EventRef,void *);OSStatus				windowEventHandler		(EventHandlerCallRef,EventRef,void *);void						doIdle								(void);void						doKeyEvent						(SInt8);void  					scrollActionFunction	(ControlRef,SInt16);void						doInContent						(Point,Boolean);void						doDrawContent					(WindowPtr);void						doActivateDeactivate	(WindowRef,Boolean);WindowRef				doNewDocWindow				(void);EventHandlerUPP	doGetHandlerUPP				(void);Boolean					customClickLoop				(void);void						doSetScrollBarValue		(ControlRef,SInt16 *);void						doAdjustMenus					(void);void						doMenuChoice					(MenuID,MenuItemIndex);void						doFileMenu						(MenuItemIndex);void						doEditMenu						(MenuItemIndex);SInt16					doGetSelectLength			(TEHandle);void						doAdjustScrollbar			(WindowRef);void						doAdjustCursor				(WindowRef);void						doCloseWindow					(WindowRef);void						doSaveAsFile					(TEHandle);void						doOpenCommand					(void);void						doOpenFile						(FSSpec);void						doDrawDataPanel				(WindowRef);void						doErrorAlert					(SInt16);void						navEventFunction			(NavEventCallbackMessage,NavCBRecPtr,																			 NavCallBackUserData);extern void			doHelp								(void);// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	EventTypeSpec	applicationEvents[] =	{ { kEventClassApplication, kEventAppActivated    },																				{ kEventClassCommand,     kEventProcessCommand  },																				{ kEventClassMenu,        kEventMenuEnableItems },																		 		{ kEventClassMouse,       kEventMouseMoved      } };	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		doErrorAlert(eMenuBar);	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);		}		menuRef = GetMenuRef(mAppleApplication);		DeleteMenuItem(menuRef,iHelp);		HMGetHelpMenu(&menuRef,NULL);		InsertMenuItem(menuRef,"\pMonoTextEdit Help",0);		gHelpMenu = GetMenuID(menuRef);		gRunningOnX = true;	}	else	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)			SetMenuItemCommandID(menuRef,iQuit,kHICommandQuit);	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииии create universal procedure pointers	gScrollActionFunctionUPP = NewControlActionUPP((ControlActionProcPtr) scrollActionFunction);	gCustomClickLoopUPP			 = NewTEClickLoopUPP((TEClickLoopProcPtr) customClickLoop); 	// иииииииииииииииииииииииииииииииииииииииииииииииииииииии install application event handler  	InstallApplicationEventHandler(NewEventHandlerUPP((EventHandlerProcPtr) appEventHandler),																 GetEventTypeCount(applicationEvents),applicationEvents,																 0,NULL);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии install a timer	InstallEventLoopTimer(GetCurrentEventLoop(),0,TicksToEventTime(GetCaretTime()),												NewEventLoopTimerUPP((EventLoopTimerProcPtr) doIdle),NULL,												NULL);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open an untitled window	doNewDocWindow();	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии run application event loop	RunApplicationEventLoop();}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	MoreMasterPointers(192);	InitCursor();}// *************************************************************************** appEventHandlerOSStatus  appEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,													void * userData){	OSStatus			result = eventNotHandledErr;	UInt32				eventClass;	UInt32				eventKind;	HICommand			hiCommand;	MenuID				menuID;	MenuItemIndex	menuItem;	WindowClass		windowClass;	eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	switch(eventClass)	{		case kEventClassApplication:			if(eventKind == kEventAppActivated)				SetThemeCursor(kThemeArrowCursor);			break;		case kEventClassCommand:			if(eventKind == kEventProcessCommand)			{				GetEventParameter(eventRef,kEventParamDirectObject,typeHICommand,NULL,													sizeof(HICommand),NULL,&hiCommand);				menuID = GetMenuID(hiCommand.menu.menuRef);				menuItem = hiCommand.menu.menuItemIndex;				if((hiCommand.commandID != kHICommandQuit) && 					 ((menuID >= mAppleApplication && menuID <= mEdit)) || menuID == gHelpMenu)				{					doMenuChoice(menuID,menuItem);					result = noErr;				}			}			break;		case kEventClassMenu:			if(eventKind == kEventMenuEnableItems)			{				GetWindowClass(FrontWindow(),&windowClass);				if(windowClass == kDocumentWindowClass)					doAdjustMenus();				result = noErr;			}			break;		case kEventClassMouse:			if(eventKind == kEventMouseMoved)			{				GetWindowClass(FrontWindow(),&windowClass);				if(windowClass == kDocumentWindowClass)					doAdjustCursor(FrontWindow());				result = noErr;			}	}	return result;}// ************************************************************************ windowEventHandlerOSStatus  windowEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,														 void* userData){	OSStatus				result = eventNotHandledErr;	UInt32					eventClass;	UInt32					eventKind;	WindowRef				windowRef;	UInt32					modifiers; 	Point						mouseLocation;	Boolean					shiftKeyDown = false;	ControlRef			controlRef;	ControlPartCode	controlPartCode;	SInt8						charCode;	eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	switch(eventClass)	{		case kEventClassWindow:																							 // event class window			GetEventParameter(eventRef,kEventParamDirectObject,typeWindowRef,NULL,sizeof(windowRef),												NULL,&windowRef);			switch(eventKind)			{				case kEventWindowDrawContent:					doDrawContent(windowRef);					result = noErr;					break;				case kEventWindowActivated:					doActivateDeactivate(windowRef,true);					result = noErr;					break;				case kEventWindowDeactivated:					doActivateDeactivate(windowRef,false);					result = noErr;					break;				case kEventWindowClickContentRgn:					GetEventParameter(eventRef,kEventParamMouseLocation,typeQDPoint,NULL,														sizeof(mouseLocation),NULL,&mouseLocation);					SetPortWindowPort(FrontWindow());					GlobalToLocal(&mouseLocation);					GetEventParameter(eventRef,kEventParamKeyModifiers,typeUInt32,NULL,														sizeof(modifiers),NULL,&modifiers);					if(modifiers & shiftKey)						shiftKeyDown = true;					doInContent(mouseLocation,shiftKeyDown);					result = noErr;					break;				case kEventWindowClose:					doCloseWindow(windowRef);					result = noErr;					break;			}			break;		case kEventClassMouse:																								// event class mouse			switch(eventKind)			{				case kEventMouseDown:					GetEventParameter(eventRef,kEventParamMouseLocation,typeQDPoint,NULL,														sizeof(mouseLocation),NULL,&mouseLocation);					SetPortWindowPort(FrontWindow());					GlobalToLocal(&mouseLocation);					controlRef = FindControlUnderMouse(mouseLocation,FrontWindow(),&controlPartCode);					if(controlRef)					{						gOldControlValue = GetControlValue(controlRef);						TrackControl(controlRef,mouseLocation,gScrollActionFunctionUPP);						result = noErr;					}				break;			}			break;		case kEventClassKeyboard:																					 // event class keyboard			switch(eventKind)			{				case kEventRawKeyDown:				case kEventRawKeyRepeat: 					GetEventParameter(eventRef,kEventParamKeyMacCharCodes,typeChar,NULL,														sizeof(charCode),NULL,&charCode);					GetEventParameter(eventRef,kEventParamKeyModifiers,typeUInt32,NULL,														sizeof(modifiers),NULL,&modifiers);					if((modifiers & cmdKey) == 0)						doKeyEvent(charCode);					result = noErr;					break;			}			break;	}	return result;}// ************************************************************************************ doIdlevoid  doIdle(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	windowRef = FrontWindow();	if(GetWindowKind(windowRef) == kApplicationWindowKind)	{		docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));		if(docStrucHdl != NULL)			TEIdle((*docStrucHdl)->textEditStrucHdl);	}}// ******************************************************************************** doKeyEventvoid  doKeyEvent(SInt8 charCode){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							selectionLength;	if(charCode <= kEscape && charCode != kBackSpace && charCode != kReturn)		return;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	if(charCode == kTab)	{		// Do tab key handling here if required.	}	else if(charCode == kForwardDelete)	{		selectionLength = doGetSelectLength(textEditStrucHdl);		if(selectionLength == 0)			(*textEditStrucHdl)->selEnd += 1;		TEDelete(textEditStrucHdl);		doAdjustScrollbar(windowRef);	}	else	{		selectionLength = doGetSelectLength(textEditStrucHdl);		if(((*textEditStrucHdl)->teLength - selectionLength + 1) < kMaxTELength)		{			TEKey(charCode,textEditStrucHdl);			doAdjustScrollbar(windowRef);		}		else			doErrorAlert(eExceedChara);	}	doDrawDataPanel(windowRef);}// ********************************************************************** scrollActionFunctionvoid  scrollActionFunction(ControlRef controlRef,SInt16 partCode){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							linesToScroll;	SInt16							controlValue, controlMax;	windowRef = GetControlOwner(controlRef);	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	controlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	if(partCode)	{		if(partCode != kControlIndicatorPart)		{			switch(partCode)			{				case kControlUpButtonPart:				case kControlDownButtonPart:					linesToScroll = 1;					break;								case kControlPageUpPart:				case kControlPageDownPart:					linesToScroll = (((*textEditStrucHdl)->viewRect.bottom - 														(*textEditStrucHdl)->viewRect.top) /														(*textEditStrucHdl)->lineHeight) - 1;					break;			}			if((partCode == kControlDownButtonPart) || (partCode == kControlPageDownPart))				linesToScroll = -linesToScroll;			linesToScroll = controlValue - linesToScroll;			if(linesToScroll < 0)				linesToScroll = 0;			else if(linesToScroll > controlMax)				linesToScroll = controlMax;			SetControlValue(controlRef,linesToScroll);			linesToScroll = controlValue - linesToScroll;		}		else		{			linesToScroll = gOldControlValue - controlValue;			gOldControlValue = controlValue;		}		if(linesToScroll != 0)		{			TEScroll(0,linesToScroll * (*textEditStrucHdl)->lineHeight,textEditStrucHdl);			doDrawDataPanel(windowRef);		}	}}// ******************************************************************************* doInContentvoid  doInContent(Point mouseLocation,Boolean shiftKeyDown){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	if(PtInRect(mouseLocation,&(*textEditStrucHdl)->viewRect))		TEClick(mouseLocation,shiftKeyDown,textEditStrucHdl);}// ***************************************************************************** doDrawContentvoid	doDrawContent(WindowRef windowRef){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	GrafPtr							oldPort;	RgnHandle						visibleRegionHdl = NewRgn();	Rect								portRect;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	GetPortVisibleRegion(GetWindowPort(windowRef),visibleRegionHdl);	EraseRgn(visibleRegionHdl);	UpdateControls(windowRef,visibleRegionHdl);	GetWindowPortBounds(windowRef,&portRect);	TEUpdate(&portRect,textEditStrucHdl);	doDrawDataPanel(windowRef);	DisposeRgn(visibleRegionHdl);	SetPort(oldPort);}// *********************************************************************** doActivateDocWindowvoid  doActivateDeactivate(WindowRef windowRef,Boolean becomingActive){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	if(becomingActive)	{		SetPortWindowPort(windowRef);		(*textEditStrucHdl)->viewRect.bottom = ((((*textEditStrucHdl)->viewRect.bottom -																							(*textEditStrucHdl)->viewRect.top) / 																							(*textEditStrucHdl)->lineHeight) * 																							(*textEditStrucHdl)->lineHeight) + 																							(*textEditStrucHdl)->viewRect.top;		(*textEditStrucHdl)->destRect.bottom = (*textEditStrucHdl)->viewRect.bottom;		TEActivate(textEditStrucHdl);		ActivateControl((*docStrucHdl)->vScrollbarRef);		doAdjustScrollbar(windowRef);		doAdjustCursor(windowRef);	}	else	{		TEDeactivate(textEditStrucHdl);		DeactivateControl((*docStrucHdl)->vScrollbarRef);	}}// **************************************************************************** doNewDocWindowWindowRef  doNewDocWindow(void){	WindowRef 					windowRef;	OSStatus						osError;	Rect								contentRect = { 100,100,400,595 };	WindowAttributes		attributes  = kWindowStandardHandlerAttribute |																		kWindowStandardDocumentAttributes;	docStructureHandle	docStrucHdl;	Rect								portRect, destAndViewRect;	EventTypeSpec		windowEvents[] = { { kEventClassWindow,	  kEventWindowDrawContent     },																		 { kEventClassWindow,	  kEventWindowActivated       },																		 { kEventClassWindow,  	kEventWindowDeactivated     },																		 { kEventClassWindow,	  kEventWindowClickContentRgn	},																		 { kEventClassWindow,   kEventWindowClose           },																		 { kEventClassMouse,    kEventMouseDown             },																		 { kEventClassKeyboard, kEventRawKeyDown            },																		 { kEventClassKeyboard, kEventRawKeyRepeat          } };	osError = CreateNewWindow(kDocumentWindowClass,attributes,&contentRect,&windowRef);	if(osError != noErr)	{		doErrorAlert(eWindow);		return NULL;	}	ChangeWindowAttributes(windowRef,0,kWindowResizableAttribute);	RepositionWindow(windowRef,NULL,kWindowCascadeOnMainScreen);	SetWTitle(windowRef,"\puntitled");	SetPortWindowPort(windowRef);	TextSize(10);	InstallWindowEventHandler(windowRef,doGetHandlerUPP(),GetEventTypeCount(windowEvents),														windowEvents,0,NULL);	if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))	{		doErrorAlert(eDocStructure);		return NULL;	}	SetWRefCon(windowRef,(SInt32) docStrucHdl);	gNumberOfWindows ++;	(*docStrucHdl)->vScrollbarRef = GetNewControl(rVScrollbar,windowRef);	GetWindowPortBounds(windowRef,&portRect);	destAndViewRect = portRect;	destAndViewRect.right -= 15;	destAndViewRect.bottom -= 15;	InsetRect(&destAndViewRect,2,2);	MoveHHi((Handle) docStrucHdl);	HLock((Handle) docStrucHdl);	if(!((*docStrucHdl)->textEditStrucHdl = TENew(&destAndViewRect,&destAndViewRect)))	{		DisposeWindow(windowRef);		gNumberOfWindows --;		DisposeHandle((Handle) docStrucHdl);		doErrorAlert(eEditRecord);		return NULL;	}	HUnlock((Handle) docStrucHdl);	TESetClickLoop(gCustomClickLoopUPP,(*docStrucHdl)->textEditStrucHdl);	TEAutoView(true,(*docStrucHdl)->textEditStrucHdl);	TEFeatureFlag(teFOutlineHilite,1,(*docStrucHdl)->textEditStrucHdl);  ShowWindow(windowRef);	return windowRef;}// *************************************************************************** doGetHandlerUPPEventHandlerUPP  doGetHandlerUPP(void){	static EventHandlerUPP	windowEventHandlerUPP;	if(windowEventHandlerUPP == NULL)		windowEventHandlerUPP = NewEventHandlerUPP((EventHandlerProcPtr) windowEventHandler);	return windowEventHandlerUPP;}// *************************************************************************** customClickLoopBoolean  customClickLoop(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	GrafPtr							oldPort;	RgnHandle						oldClip;	Rect								tempRect, portRect;	Point								mouseXY;	SInt16							linesToScroll = 0;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	oldClip = NewRgn();	GetClip(oldClip);	SetRect(&tempRect,-32767,-32767,32767,32767);	ClipRect(&tempRect);	GetMouse(&mouseXY);	GetWindowPortBounds(windowRef,&portRect);		if(mouseXY.v < portRect.top)	{		linesToScroll = 1;		doSetScrollBarValue((*docStrucHdl)->vScrollbarRef,&linesToScroll);		if(linesToScroll != 0)			TEScroll(0,linesToScroll * ((*textEditStrucHdl)->lineHeight),textEditStrucHdl);	}	else if(mouseXY.v > portRect.bottom)	{		linesToScroll = -1;		doSetScrollBarValue((*docStrucHdl)->vScrollbarRef,&linesToScroll);		if(linesToScroll != 0)			TEScroll(0,linesToScroll * ((*textEditStrucHdl)->lineHeight),textEditStrucHdl);	}	if(linesToScroll != 0)		doDrawDataPanel(windowRef);	SetClip(oldClip);	DisposeRgn(oldClip);	SetPort(oldPort);	return true;}// *********************************************************************** doSetScrollBarValuevoid  doSetScrollBarValue(ControlRef controlRef,SInt16 *linesToScroll){	SInt16	controlValue, controlMax;	controlValue = GetControlValue(controlRef);	controlMax = GetControlMaximum(controlRef);	*linesToScroll = controlValue - *linesToScroll;	if(*linesToScroll < 0)		*linesToScroll = 0;	else if(*linesToScroll > controlMax)		*linesToScroll = controlMax;	SetControlValue(controlRef,*linesToScroll);	*linesToScroll = controlValue - *linesToScroll;}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef							fileMenuHdl, editMenuHdl;	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	ScrapRef						scrapRef;	OSStatus						osError;	ScrapFlavorFlags		scrapFlavorFlags;	fileMenuHdl = GetMenuRef(mFile);	editMenuHdl = GetMenuRef(mEdit);	if(gNumberOfWindows > 0)	{		windowRef = FrontWindow();		docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));		textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;		EnableMenuItem(fileMenuHdl,iClose);		if((*textEditStrucHdl)->selStart < (*textEditStrucHdl)->selEnd)		{			EnableMenuItem(editMenuHdl,iCut);			EnableMenuItem(editMenuHdl,iCopy);			EnableMenuItem(editMenuHdl,iClear);		}		else		{			DisableMenuItem(editMenuHdl,iCut);			DisableMenuItem(editMenuHdl,iCopy);			DisableMenuItem(editMenuHdl,iClear);		}		GetCurrentScrap(&scrapRef);		osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&scrapFlavorFlags);		if(osError == noErr)			EnableMenuItem(editMenuHdl,iPaste);		else			DisableMenuItem(editMenuHdl,iPaste);					if((*textEditStrucHdl)->teLength > 0)		{			EnableMenuItem(fileMenuHdl,iSaveAs);			EnableMenuItem(editMenuHdl,iSelectAll);		}		else		{			DisableMenuItem(fileMenuHdl,iSaveAs);			DisableMenuItem(editMenuHdl,iSelectAll);		}	}	else	{		DisableMenuItem(fileMenuHdl,iClose);		DisableMenuItem(fileMenuHdl,iSaveAs);		DisableMenuItem(editMenuHdl,iClear);		DisableMenuItem(editMenuHdl,iSelectAll);	}	DrawMenuBar();}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(MenuID menuID, MenuItemIndex menuItem){	if(menuID == 0)		return;	if(gRunningOnX)		if(menuID == gHelpMenu)			if(menuItem == 1)				doHelp();	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			else if(menuItem == iHelp)				doHelp();			break;		case mFile:			doFileMenu(menuItem);			break;		case mEdit:			doEditMenu(menuItem);			break;	}}// ******************************************************************************** doFileMenuvoid	doFileMenu(MenuItemIndex menuItem){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	switch(menuItem)	{		case iNew:			if(windowRef = doNewDocWindow())				ShowWindow(windowRef);			break;		case iOpen:			doOpenCommand(); 			doAdjustScrollbar(FrontWindow());			break;		case iClose:			doCloseWindow(FrontWindow());			break;		case iSaveAs:			docStrucHdl = (docStructureHandle) (GetWRefCon(FrontWindow()));			textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;			doSaveAsFile(textEditStrucHdl);			break;	}}// ******************************************************************************** doEditMenuvoid	doEditMenu(MenuItemIndex menuItem){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt32							totalSize, contigSize, newSize;	SInt16							selectionLength;	ScrapRef						scrapRef;	Size								sizeOfTextData;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	switch(menuItem)	{		case iUndo:			break;		case iCut:			if(ClearCurrentScrap() == noErr)			{				PurgeSpace(&totalSize,&contigSize);				selectionLength = doGetSelectLength(textEditStrucHdl);				if(selectionLength > contigSize)					doErrorAlert(eNoSpaceCut);				else				{					TECut(textEditStrucHdl);					doAdjustScrollbar(windowRef);					TEToScrap();					if(TEToScrap() != noErr)						ClearCurrentScrap();				}			}			break;		case iCopy:			if(ClearCurrentScrap() == noErr)				TECopy(textEditStrucHdl);			TEToScrap();			if(TEToScrap() != noErr)				ClearCurrentScrap();			break;		case iPaste:			GetCurrentScrap(&scrapRef);;			GetScrapFlavorSize(scrapRef,kScrapFlavorTypeText,&sizeOfTextData);			newSize = (*textEditStrucHdl)->teLength + sizeOfTextData;			if(newSize > kMaxTELength)				doErrorAlert(eNoSpacePaste);			else			{				if(TEFromScrap() == noErr)				{					TEPaste(textEditStrucHdl);					doAdjustScrollbar(windowRef);				}			}			break;		case iClear:			TEDelete(textEditStrucHdl);			doAdjustScrollbar(windowRef);			break;		case iSelectAll:			TESetSelect(0,(*textEditStrucHdl)->teLength,textEditStrucHdl);			break;	}	doDrawDataPanel(windowRef);}// ************************************************************************* doGetSelectLengthSInt16  doGetSelectLength(TEHandle textEditStrucHdl){	SInt16	selectionLength;	selectionLength = (*textEditStrucHdl)->selEnd - (*textEditStrucHdl)->selStart;	return selectionLength;}// ************************************************************************* doAdjustScrollbarvoid  doAdjustScrollbar(WindowRef windowRef){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							numberOfLines, controlMax, controlValue;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	numberOfLines = (*textEditStrucHdl)->nLines;	if(*(*(*textEditStrucHdl)->hText + (*textEditStrucHdl)->teLength - 1) == kReturn)		numberOfLines += 1;	controlMax = numberOfLines - (((*textEditStrucHdl)->viewRect.bottom - 							 (*textEditStrucHdl)->viewRect.top) /							 (*textEditStrucHdl)->lineHeight);	if(controlMax < 0)		controlMax = 0;	SetControlMaximum((*docStrucHdl)->vScrollbarRef,controlMax);	controlValue = ((*textEditStrucHdl)->viewRect.top - (*textEditStrucHdl)->destRect.top) / 									(*textEditStrucHdl)->lineHeight;	if(controlValue < 0)		controlValue = 0;	else if(controlValue > controlMax)		controlValue = controlMax;	SetControlValue((*docStrucHdl)->vScrollbarRef,controlValue);	SetControlViewSize((*docStrucHdl)->vScrollbarRef,(*textEditStrucHdl)->viewRect.bottom - 										 (*textEditStrucHdl)->viewRect.top);	TEScroll(0,((*textEditStrucHdl)->viewRect.top - (*textEditStrucHdl)->destRect.top) - 					 		(GetControlValue((*docStrucHdl)->vScrollbarRef) *							(*textEditStrucHdl)->lineHeight),textEditStrucHdl);}// **************************************************************************** doAdjustCursorvoid  doAdjustCursor(WindowRef windowRef){	GrafPtr		oldPort;	RgnHandle	arrowRegion, iBeamRegion;	Rect			portRect, cursorRect;	Point			mouseXY;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	arrowRegion = NewRgn();	iBeamRegion = NewRgn();		SetRectRgn(arrowRegion,-32768,-32768,32766,32766);	GetWindowPortBounds(windowRef,&portRect);	cursorRect = portRect;	cursorRect.bottom -= 15;	cursorRect.right	-= 15;	LocalToGlobal(&topLeft(cursorRect));	LocalToGlobal(&botRight(cursorRect));		RectRgn(iBeamRegion,&cursorRect);	DiffRgn(arrowRegion,iBeamRegion,arrowRegion);		GetGlobalMouse(&mouseXY);	if(PtInRgn(mouseXY,iBeamRegion))		SetThemeCursor(kThemeIBeamCursor);	else		SetThemeCursor(kThemeArrowCursor);	DisposeRgn(arrowRegion);	DisposeRgn(iBeamRegion);	SetPort(oldPort);}// ***************************************************************************** doCloseWindowvoid  doCloseWindow(WindowRef windowRef){	docStructureHandle	docStrucHdl;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	DisposeControl((*docStrucHdl)->vScrollbarRef);	TEDispose((*docStrucHdl)->textEditStrucHdl);	DisposeHandle((Handle) docStrucHdl);	DisposeWindow(windowRef);	gNumberOfWindows --;}// ****************************************************************************** doSaveAsFilevoid  doSaveAsFile(TEHandle textEditStrucHdl){	OSErr							osError = noErr;	NavDialogOptions	dialogOptions;	NavEventUPP				navEventFunctionUPP;	WindowRef					windowRef;	OSType						fileType;	NavReplyRecord		navReplyStruc;	AEKeyword					theKeyword;	DescType					actualType;	FSSpec						fileSpec;		SInt16						fileRefNum;	Size							actualSize;	SInt32						dataLength;	Handle						editTextHdl;			osError = NavGetDefaultDialogOptions(&dialogOptions);	if(osError == noErr)	{		windowRef = FrontWindow();		fileType = 'TEXT';		navEventFunctionUPP = NewNavEventUPP((NavEventProcPtr) navEventFunction);		osError = NavPutFile(NULL,&navReplyStruc,&dialogOptions,navEventFunctionUPP,fileType,												 'kjBb',NULL);		DisposeNavEventUPP(navEventFunctionUPP);		if(navReplyStruc.validRecord && osError == noErr)		{			if((osError = AEGetNthPtr(&(navReplyStruc.selection),1,typeFSS,&theKeyword,																&actualType,&fileSpec,sizeof(fileSpec),&actualSize)) == noErr)			{				if(!navReplyStruc.replacing)				{					osError = FSpCreate(&fileSpec,'kjBb',fileType,navReplyStruc.keyScript);					if(osError != noErr)					{						NavDisposeReply(&navReplyStruc);					}				}								if(osError == noErr)					osError = FSpOpenDF(&fileSpec,fsRdWrPerm,&fileRefNum);				if(osError == noErr)				{					SetWTitle(windowRef,fileSpec.name);					dataLength = (*textEditStrucHdl)->teLength;					editTextHdl = (*textEditStrucHdl)->hText;					FSWrite(fileRefNum,&dataLength,*editTextHdl);				}				NavCompleteSave(&navReplyStruc,kNavTranslateInPlace);			}			NavDisposeReply(&navReplyStruc);		}	}}// ***************************************************************************** doOpenCommandvoid  doOpenCommand(void){		OSErr							osError	= noErr;	NavDialogOptions	dialogOptions;	NavEventUPP				navEventFunctionUPP;	NavReplyRecord		navReplyStruc;	SInt32						index, count;	AEKeyword					theKeyword;	DescType					actualType;	FSSpec						fileSpec;		Size							actualSize;	FInfo							fileInfo;	osError = NavGetDefaultDialogOptions(&dialogOptions);	if(osError == noErr)	{		navEventFunctionUPP = NewNavEventUPP((NavEventProcPtr) navEventFunction);		osError = NavGetFile(NULL,&navReplyStruc,&dialogOptions,navEventFunctionUPP,NULL,NULL,												 NULL,NULL);		DisposeNavEventUPP(navEventFunctionUPP);		if(osError == noErr && navReplyStruc.validRecord)		{			osError = AECountItems(&(navReplyStruc.selection),&count);			if(osError == noErr)			{				for(index=1;index<=count;index++)				{					osError = AEGetNthPtr(&(navReplyStruc.selection),index,typeFSS,&theKeyword,																&actualType,&fileSpec,sizeof(fileSpec),&actualSize);					{						if((osError = FSpGetFInfo(&fileSpec,&fileInfo)) == noErr)							doOpenFile(fileSpec);					}				}			}					NavDisposeReply(&navReplyStruc);			}	}}// ******************************************************************************** doOpenFilevoid  doOpenFile(FSSpec fileSpec){	WindowRef 					windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							fileRefNum;	SInt32							textLength;	Handle							textBuffer;	if((windowRef = doNewDocWindow()) == NULL)		return;	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	SetWTitle(windowRef,fileSpec.name);	FSpOpenDF(&fileSpec,fsCurPerm,&fileRefNum);	SetFPos(fileRefNum,fsFromStart,0);	GetEOF(fileRefNum,&textLength);	if(textLength > 32767)		textLength = 32767;	textBuffer = NewHandle((Size) textLength);	FSRead(fileRefNum,&textLength,*textBuffer);	MoveHHi(textBuffer);	HLock(textBuffer);	TESetText(*textBuffer,textLength,textEditStrucHdl);	HUnlock(textBuffer);	DisposeHandle(textBuffer);	FSClose(fileRefNum);	(*textEditStrucHdl)->selStart = 0;	(*textEditStrucHdl)->selEnd = 0;	doDrawContent(windowRef);}// *************************************************************************** doDrawDataPanelvoid  doDrawDataPanel(WindowRef windowRef){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	RGBColor						whiteColour = { 0xFFFF, 0xFFFF, 0xFFFF };	RGBColor						blackColour = { 0x0000, 0x0000, 0x0000 };	RGBColor						blueColour = { 0x1818, 0x4B4B, 0x8181 };	ControlRef					controlRef;	Rect								panelRect;	Str255							textString;	SetPortWindowPort(windowRef);	docStrucHdl = (docStructureHandle) (GetWRefCon(windowRef));;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	controlRef = (*docStrucHdl)->vScrollbarRef;	MoveTo(0,282);	LineTo(495,282);	RGBForeColor(&whiteColour);	RGBBackColor(&blueColour);	SetRect(&panelRect,0,283,495,300);	EraseRect(&panelRect);	MoveTo(3,295);	DrawString("\pteLength               nLines          lineHeight");	MoveTo(225,295);	DrawString("\pdestRect.top              controlValue           contrlMax");	SetRect(&panelRect,47,284,88,299);	EraseRect(&panelRect);		SetRect(&panelRect,124,284,149,299);	EraseRect(&panelRect);		SetRect(&panelRect,204,284,222,299);	EraseRect(&panelRect);		SetRect(&panelRect,286,284,323,299);	EraseRect(&panelRect);		SetRect(&panelRect,389,284,416,299);	EraseRect(&panelRect);		SetRect(&panelRect,472,284,495,299);	EraseRect(&panelRect);		NumToString((SInt32) (*textEditStrucHdl)->teLength,textString);	MoveTo(47,295);	DrawString(textString);	NumToString((SInt32) (*textEditStrucHdl)->nLines,textString);	MoveTo(124,295);	DrawString(textString);	NumToString((SInt32) (*textEditStrucHdl)->lineHeight,textString);	MoveTo(204,295);	DrawString(textString);	NumToString((SInt32) (*textEditStrucHdl)->destRect.top,textString);	MoveTo(286,295);	DrawString(textString);	NumToString((SInt32) GetControlValue(controlRef),textString);	MoveTo(389,295);	DrawString(textString);	NumToString((SInt32) GetControlMaximum(controlRef),textString);	MoveTo(472,295);	DrawString(textString);	RGBForeColor(&blackColour);	RGBBackColor(&whiteColour);}// ****************************************************************************** doErrorAlertvoid  doErrorAlert(SInt16 errorCode){	Str255	errorString;	SInt16	itemHit;	GetIndString(errorString,rErrorStrings,errorCode);	if(errorCode < eWindow)	{		StandardAlert(kAlertStopAlert,errorString,NULL,NULL,&itemHit);		ExitToShell();	}	else	{		StandardAlert(kAlertCautionAlert,errorString,NULL,NULL,&itemHit);	}}// ************************************************************************** navEventFunctionvoid  navEventFunction(NavEventCallbackMessage callBackSelector,NavCBRecPtr callBackParms,											 NavCallBackUserData callBackUD){}// *******************************************************************************************