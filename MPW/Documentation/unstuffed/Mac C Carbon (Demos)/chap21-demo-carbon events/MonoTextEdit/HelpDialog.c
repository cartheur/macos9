// *******************************************************************************************// HelpDialog.c// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define eHelpDialog						8#define eHelpDocStructure			9#define eHelpText							10#define eHelpPicture					11#define eHelpControls					12#define rTextIntroduction			128#define rTextCreatingText			129#define rTextModifyHelp				130#define rPictIntroductionBase	128#define rPictCreatingTextBase	129#define kTextInset						4// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии typedefstypedef struct{	Rect			bounds;	PicHandle	pictureHdl;} pictInfoStructure;typedef struct{	TEHandle					textEditStrucHdl;	ControlRef				scrollbarHdl;	SInt16						pictCount;	pictInfoStructure	*pictInfoStructurePtr;}	docStructure, ** docStructureHandle;typedef struct{	RGBColor			backColour;	PixPatHandle	backPixelPattern;	Pattern				backBitPattern;} backColourPattern;// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesGrafPtr									gOldPort;EventHandlerUPP					helpWindowEventHandlerUPP;ControlUserPaneDrawUPP	userPaneDrawFunctionUPP;ControlActionUPP				actionFunctionUPP;SInt16									gTextResourceID;SInt16									gPictResourceBaseID;RgnHandle								gSavedClipRgn	= NULL;// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid			doHelp									(void);OSStatus  helpWindowEventHandler	(EventHandlerCallRef,EventRef,void *);void  		userPaneDrawFunction		(ControlRef,SInt16);Boolean		doGetText								(WindowRef,SInt16,Rect);Boolean		doGetPictureInfo				(WindowRef,SInt16);void			actionFunction					(ControlRef,SInt16);void			doScrollTextAndPicts		(WindowRef);void 			doDrawPictures					(WindowRef,Rect *);void			doCloseHelp							(WindowRef);void			doDisposeDescriptors		(void);void			doSetBackgroundWhite		(void);extern void	doErrorAlert					(SInt16);// ************************************************************************************ doHelpvoid  doHelp(void){	OSStatus						osError;	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	ControlRef					controlRef;	ControlID						controlID;	Rect								windowRect			= { 0,  0,  353,382 };	Rect								pushButtonRect	= { 312,297,332,366 };	Rect								userPaneRect		= { 16, 16, 296,351 };	Rect								scrollBarRect		= { 16, 350,296,366 };	Rect								popupButtonRect	= { 312,12, 332,256 };	Rect								destRect, viewRect;	EventTypeSpec				dialogEvents[] = {{ kEventClassControl, kEventControlClick } };	GetPort(&gOldPort);	// иииииииииииииииииииииииииииииииииииииииииииииииииииии create universal procedure pointers	helpWindowEventHandlerUPP = NewEventHandlerUPP((EventHandlerProcPtr) 	                                               helpWindowEventHandler);	userPaneDrawFunctionUPP = NewControlUserPaneDrawUPP((ControlUserPaneDrawProcPtr) 																											userPaneDrawFunction);	actionFunctionUPP = NewControlActionUPP((ControlActionProcPtr) actionFunction);	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии create modal class window	osError = CreateNewWindow(kMovableModalWindowClass,kWindowStandardHandlerAttribute,														&windowRect,&windowRef);	if(osError == noErr)	{		RepositionWindow(windowRef,FrontWindow(),kWindowAlertPositionOnMainScreen);		SetThemeWindowBackground(windowRef,kThemeBrushDialogBackgroundActive,false);		InstallWindowEventHandler(windowRef,helpWindowEventHandlerUPP,															GetEventTypeCount(dialogEvents),dialogEvents,windowRef,NULL);		if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))		{			doErrorAlert(eHelpDocStructure);			DisposeWindow(windowRef);			doDisposeDescriptors();			return;		}		SetWRefCon(windowRef,(SInt32) docStrucHdl);		SetPortWindowPort(windowRef);		// ииииииииииииииииииииииииии create root, push button, user pane, and scroll bar controls		CreateRootControl(windowRef,&controlRef);		if((osError = CreatePushButtonControl(windowRef,&pushButtonRect,CFSTR("OK"),&controlRef))				== noErr)		{			SetWindowDefaultButton(windowRef,controlRef);			controlID.id = 'done';			SetControlID(controlRef,&controlID);		}		if(osError == noErr)		{			if((osError = CreateUserPaneControl(windowRef,&userPaneRect,0,&controlRef)) == noErr)			{				SetControlData(controlRef,kControlEntireControl,kControlUserPaneDrawProcTag, 											 sizeof(userPaneDrawFunctionUPP),(Ptr) &userPaneDrawFunctionUPP);			}		}		if(osError == noErr)		{			if((osError = CreateScrollBarControl(windowRef,&scrollBarRect,0,0,1,0,true,																					 actionFunctionUPP,&controlRef)) == noErr)			(*docStrucHdl)->scrollbarHdl = controlRef;			controlID.id = 'scro';			SetControlID(controlRef,&controlID);		}		if(osError == noErr)		{			if((osError = CreatePopupButtonControl(windowRef,&popupButtonRect,CFSTR("Title:"),131,																						 false,-1,0,0,&controlRef)) == noErr)			controlID.id = 'popu';			SetControlID(controlRef,&controlID);		}		if(osError != noErr)		{			doErrorAlert(eHelpControls);			DisposeWindow(windowRef);			doDisposeDescriptors();			return;		}	}	else	{		doErrorAlert(eHelpDialog);		doDisposeDescriptors();		return;	}	// ииииииииииииииииииииииииии set destination and view rectangles, create TextEdit structure	InsetRect(&userPaneRect,kTextInset,kTextInset / 2);	destRect = viewRect = userPaneRect;	(*docStrucHdl)->textEditStrucHdl = TEStyleNew(&destRect,&viewRect);	// ииииииииииииииииииии initialise picture information structure field of document structure	(*docStrucHdl)->pictInfoStructurePtr = NULL;	// ииииииииииииииииииииииииииии assign resource IDs of first topic's 'TEXT'/'styl' resources		gTextResourceID			= rTextIntroduction;	gPictResourceBaseID	= rPictIntroductionBase;	// ииииииииииииииииииииииииииииииииииииии load text resources and insert into edit structure	if(!(doGetText(windowRef,gTextResourceID,viewRect)))	{		doCloseHelp(windowRef);		doDisposeDescriptors();		return;	}	// иииииииии search for option-space charas in text and load same number of 'PICT' resources	if(!(doGetPictureInfo(windowRef,gPictResourceBaseID)))	{		doCloseHelp(windowRef);		doDisposeDescriptors();		return;	}	// иииииииииииииииииииииииииииииии create an empty region for saving the old clipping region	gSavedClipRgn = NewRgn();	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииии show window and run modal loop	ShowWindow(windowRef);	RunAppModalLoopForWindow(windowRef);}// ******************************************************************** helpWindowEventHandlerOSStatus  helpWindowEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,																 void *userData){	OSStatus						result = eventNotHandledErr;	WindowRef						windowRef;	UInt32							eventClass;	UInt32 							eventKind;	Point								mouseLocation;	ControlRef					controlRef;	ControlPartCode			controlPartCode;	ControlID						controlID;	MenuItemIndex				menuItem;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	Rect								viewRect;	windowRef  = userData;	eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	if(eventClass == kEventClassControl)	{		if(eventKind == kEventControlClick)		{			GetEventParameter(eventRef,kEventParamMouseLocation,typeQDPoint,NULL,												sizeof(mouseLocation),NULL,&mouseLocation);			GlobalToLocal(&mouseLocation);			controlRef = FindControlUnderMouse(mouseLocation,windowRef,&controlPartCode);			if(controlRef)			{				GetControlID(controlRef,&controlID);				if(controlID.id == 'done')																							// push button				{					if(TrackControl(controlRef,mouseLocation,NULL))					{						QuitAppModalLoopForWindow(windowRef);						doCloseHelp(windowRef);						doDisposeDescriptors();						result = noErr;					}				}				if(controlID.id == 'scro')																							 // scroll bar				{					TrackControl(controlRef,mouseLocation,actionFunctionUPP);					result = noErr;					}				else if(controlID.id == 'popu')																	 // pop-up menu button				{					TrackControl(controlRef,mouseLocation,(ControlActionUPP) -1);					menuItem = GetControlValue(controlRef);					switch(menuItem)					{						case 1:							gTextResourceID 		= rTextIntroduction;							gPictResourceBaseID = rPictIntroductionBase;							break;						case 2:							gTextResourceID 		= rTextCreatingText;							gPictResourceBaseID = rPictCreatingTextBase;							break;						case 3:							gTextResourceID 		= rTextModifyHelp;							break;					}					docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);					textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;					viewRect = (*textEditStrucHdl)->viewRect;					if(!(doGetText(windowRef,gTextResourceID,viewRect)))					{						doCloseHelp(windowRef);						doDisposeDescriptors();						return;					}					if(!(doGetPictureInfo(windowRef,gPictResourceBaseID)))					{						doCloseHelp(windowRef);						doDisposeDescriptors();						return;					}					doDrawPictures(windowRef,&viewRect);					result = noErr;				}			}		}	}	return result;}// ********************************************************************** userPaneDrawFunctionvoid  userPaneDrawFunction(ControlRef controlRef,SInt16 thePart){	Rect								itemRect, viewRect;	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	Boolean 						inState;	windowRef = GetControlOwner(controlRef);	GetControlBounds(controlRef,&itemRect);	InsetRect(&itemRect,1,1);	itemRect.right += 15;	if(IsWindowVisible(windowRef))		inState = IsWindowHilited(windowRef);	DrawThemeListBoxFrame(&itemRect,inState);	doSetBackgroundWhite();	EraseRect(&itemRect);	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	viewRect = (*textEditStrucHdl)->viewRect;	TEUpdate(&viewRect,textEditStrucHdl);	doDrawPictures(windowRef,&viewRect);}// ********************************************************************************* doGetTextBoolean  doGetText(WindowRef windowRef,SInt16 textResourceID,Rect viewRect){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	Handle							helpTextHdl;	StScrpHandle				stylScrpStrucHdl;	SInt16							numberOfLines, heightOfText, heightToScroll;	doSetBackgroundWhite();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	TESetSelect(0,32767,textEditStrucHdl);	TEDelete(textEditStrucHdl);	(*textEditStrucHdl)->destRect = (*textEditStrucHdl)->viewRect;	SetControlValue((*docStrucHdl)->scrollbarHdl,0);	helpTextHdl = GetResource('TEXT',textResourceID);	if(helpTextHdl == NULL)	{		doErrorAlert(eHelpText);		return false;	}	stylScrpStrucHdl = (StScrpHandle) GetResource('styl',textResourceID);	if(stylScrpStrucHdl == NULL)	{		doErrorAlert(eHelpText);		return false;	}	TEStyleInsert(*helpTextHdl,GetHandleSize(helpTextHdl),stylScrpStrucHdl,textEditStrucHdl);	ReleaseResource(helpTextHdl);	ReleaseResource((Handle) stylScrpStrucHdl);	numberOfLines = (*textEditStrucHdl)->nLines;	heightOfText = TEGetHeight((SInt32) numberOfLines,1,textEditStrucHdl);	if(heightOfText > (viewRect.bottom - viewRect.top))	{		heightToScroll = TEGetHeight((SInt32) numberOfLines,1,textEditStrucHdl) -																 (viewRect.bottom - viewRect.top);		SetControlMaximum((*docStrucHdl)->scrollbarHdl,heightToScroll);		ActivateControl((*docStrucHdl)->scrollbarHdl);		SetControlViewSize((*docStrucHdl)->scrollbarHdl,(*textEditStrucHdl)->viewRect.bottom - 										 	 (*textEditStrucHdl)->viewRect.top);	}	else	{		DeactivateControl((*docStrucHdl)->scrollbarHdl);	}	return true;}// ************************************************************************** doGetPictureInfoBoolean  doGetPictureInfo(WindowRef windowRef,SInt16 firstPictID){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	Handle							textHdl;	SInt32							offset, textSize;	SInt16							numberOfPicts, a, lineHeight, fontAscent;	SInt8								optionSpace[1] = "\xCA";	pictInfoStructure		*pictInfoPtr;	Point								picturePoint;	TextStyle						whatStyle;	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->pictInfoStructurePtr != NULL)	{		for(a=0;a<(*docStrucHdl)->pictCount;a++)			ReleaseResource((Handle) (*docStrucHdl)->pictInfoStructurePtr[a].pictureHdl);		DisposePtr((Ptr) (*docStrucHdl)->pictInfoStructurePtr);		(*docStrucHdl)->pictInfoStructurePtr = NULL;	}	(*docStrucHdl)->pictCount = 0;	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	textHdl = (*textEditStrucHdl)->hText;	textSize = GetHandleSize(textHdl);	offset = 0;	numberOfPicts = 0;	HLock(textHdl);	offset = Munger(textHdl,offset,optionSpace,1,NULL,0);	while((offset >= 0) && (offset <= textSize))	{		numberOfPicts++;		offset++;		offset = Munger(textHdl,offset,optionSpace,1,NULL,0);			}		if(numberOfPicts == 0)	{		HUnlock(textHdl);		return true;	}	pictInfoPtr = (pictInfoStructure *) NewPtr(sizeof(pictInfoStructure) * numberOfPicts);	(*docStrucHdl)->pictInfoStructurePtr = pictInfoPtr;	offset = 0L;	for(a=0;a<numberOfPicts;a++)	{		pictInfoPtr[a].pictureHdl = GetPicture(firstPictID + a);		if(pictInfoPtr[a].pictureHdl == NULL)		{			doErrorAlert(eHelpPicture);			return false;		}		offset = Munger(textHdl,offset,optionSpace,1,NULL,0);		picturePoint = TEGetPoint((SInt16)offset,textEditStrucHdl);		TEGetStyle(offset,&whatStyle,&lineHeight,&fontAscent,textEditStrucHdl);		picturePoint.v -= lineHeight;		offset++;		pictInfoPtr[a].bounds = (**pictInfoPtr[a].pictureHdl).picFrame;		OffsetRect(&pictInfoPtr[a].bounds,							 (((*textEditStrucHdl)->destRect.right + (*textEditStrucHdl)->destRect.left) -							 (pictInfoPtr[a].bounds.right + pictInfoPtr[a].bounds.left) ) / 2,							 - pictInfoPtr[a].bounds.top + picturePoint.v);	}	(*docStrucHdl)->pictCount = a;	HUnlock(textHdl);	return true;}// **************************************************************************** actionFunctionvoid  actionFunction(ControlRef scrollbarHdl,SInt16 partCode){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							delta, oldValue, offset, lineHeight, fontAscent;	Point								thePoint;	Rect								viewRect, portRect;	TextStyle						style;	if(partCode)	{		windowRef = GetControlOwner(scrollbarHdl);		docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);		textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;		viewRect = (*textEditStrucHdl)->viewRect;		thePoint.h = viewRect.left + kTextInset;		if(partCode != kControlIndicatorPart)		{			switch(partCode)			{				case kControlUpButtonPart:					thePoint.v = viewRect.top - 4;					offset = TEGetOffset(thePoint,textEditStrucHdl);					thePoint = TEGetPoint(offset,textEditStrucHdl);					TEGetStyle(offset,&style,&lineHeight,&fontAscent,textEditStrucHdl);					delta = thePoint.v - lineHeight - viewRect.top;					break;				case kControlDownButtonPart:					thePoint.v = viewRect.bottom + 2;					offset = TEGetOffset(thePoint,textEditStrucHdl);					thePoint = TEGetPoint(offset,textEditStrucHdl);					delta = thePoint.v - viewRect.bottom;					break;				case kControlPageUpPart:					thePoint.v = viewRect.top + 2;					offset = TEGetOffset(thePoint,textEditStrucHdl);					thePoint = TEGetPoint(offset,textEditStrucHdl);					TEGetStyle(offset,&style,&lineHeight,&fontAscent,textEditStrucHdl);					thePoint.v += lineHeight - fontAscent;					thePoint.v -= viewRect.bottom - viewRect.top;					offset = TEGetOffset(thePoint,textEditStrucHdl);					thePoint = TEGetPoint(offset,textEditStrucHdl);					TEGetStyle(offset,&style,&lineHeight,&fontAscent,textEditStrucHdl);					delta = thePoint.v - viewRect.top;					if(offset == 0)						delta -= lineHeight;					break;				case kControlPageDownPart:					thePoint.v = viewRect.bottom - 2;					offset = TEGetOffset(thePoint,textEditStrucHdl);					thePoint = TEGetPoint(offset,textEditStrucHdl);					TEGetStyle(offset,&style,&lineHeight,&fontAscent,textEditStrucHdl);					thePoint.v -= fontAscent;					thePoint.v += viewRect.bottom - viewRect.top;					offset = TEGetOffset(thePoint,textEditStrucHdl);					thePoint = TEGetPoint(offset,textEditStrucHdl);					TEGetStyle(offset,&style,&lineHeight,&fontAscent,textEditStrucHdl);					delta =  thePoint.v - lineHeight - viewRect.bottom;					if(offset == (**textEditStrucHdl).teLength)						delta += lineHeight;					break;			}			oldValue = GetControlValue(scrollbarHdl);			if(((delta < 0) && (oldValue > 0)) || ((delta > 0) && 				 (oldValue < GetControlMaximum(scrollbarHdl))))			{				GetClip(gSavedClipRgn);				GetWindowPortBounds(windowRef,&portRect);				ClipRect(&portRect);				SetControlValue(scrollbarHdl,oldValue + delta);				SetClip(gSavedClipRgn);			}		}		doScrollTextAndPicts(windowRef);	}}// ********************************************************************** doScrollTextAndPictsvoid  doScrollTextAndPicts(WindowRef windowRef){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							scrollDistance, oldScroll;	Rect								updateRect;	doSetBackgroundWhite();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	oldScroll = (*textEditStrucHdl)->viewRect.top -(*textEditStrucHdl)->destRect.top;	scrollDistance = oldScroll - GetControlValue((*docStrucHdl)->scrollbarHdl);	if(scrollDistance == 0)		return;	TEScroll(0,scrollDistance,textEditStrucHdl);	if((*docStrucHdl)->pictCount == 0)		return;	updateRect = (*textEditStrucHdl)->viewRect;	if(scrollDistance > 0)	{		if(scrollDistance < (updateRect.bottom - updateRect.top))			updateRect.bottom = updateRect.top + scrollDistance;	}	else	{		if( - scrollDistance < (updateRect.bottom - updateRect.top))			updateRect.top = updateRect.bottom + scrollDistance;	}	doDrawPictures(windowRef,&updateRect);}// **************************************************************************** doDrawPicturesvoid  doDrawPictures(WindowRef windowRef,Rect *updateRect){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							pictCount, pictIndex, vOffset;	PicHandle						thePictHdl;	Rect								pictLocRect, dummyRect;	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	vOffset = (*textEditStrucHdl)->destRect.top - 	          (*textEditStrucHdl)->viewRect.top - kTextInset;	pictCount = (*docStrucHdl)->pictCount;	for(pictIndex = 0;pictIndex < pictCount;pictIndex++)	{		pictLocRect = (*docStrucHdl)->pictInfoStructurePtr[pictIndex].bounds;    OffsetRect(&pictLocRect,0,vOffset);		if(!SectRect(&pictLocRect,updateRect,&dummyRect))			continue;		thePictHdl = (*docStrucHdl)->pictInfoStructurePtr[pictIndex].pictureHdl;		LoadResource((Handle) thePictHdl);		HLock((Handle) thePictHdl);		GetClip(gSavedClipRgn);		ClipRect(updateRect);		DrawPicture(thePictHdl,&pictLocRect);		SetClip(gSavedClipRgn);		HUnlock((Handle) thePictHdl);	}}// ******************************************************************************* doCloseHelpvoid  doCloseHelp(WindowRef windowRef){	docStructureHandle	docStrucHdl;	TEHandle						textEditStrucHdl;	SInt16							a;	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	textEditStrucHdl = (*docStrucHdl)->textEditStrucHdl;	if(gSavedClipRgn)		DisposeRgn(gSavedClipRgn);	if((*docStrucHdl)->textEditStrucHdl)		TEDispose((*docStrucHdl)->textEditStrucHdl);	if((*docStrucHdl)->pictInfoStructurePtr)	{		for(a=0;a<(*docStrucHdl)->pictCount;a++)			ReleaseResource((Handle) (*docStrucHdl)->pictInfoStructurePtr[a].pictureHdl);		DisposePtr((Ptr) (*docStrucHdl)->pictInfoStructurePtr);	}	DisposeHandle((Handle) docStrucHdl);	DisposeWindow(windowRef);	SetPort(gOldPort);}// ********************************************************************** doDisposeDescriptorsvoid  doDisposeDescriptors(void){	DisposeEventHandlerUPP(helpWindowEventHandlerUPP);	DisposeControlUserPaneDrawUPP(userPaneDrawFunctionUPP);	DisposeControlActionUPP(actionFunctionUPP);}// ********************************************************************** doSetBackgroundWhitevoid  doSetBackgroundWhite(void){	RGBColor	whiteColour = { 0xFFFF, 0xFFFF, 0xFFFF };	Pattern		whitePattern;	RGBBackColor(&whiteColour);	BackPat(GetQDGlobalsWhite(&whitePattern));}// *******************************************************************************************