// *******************************************************************************************// Scrap.c                                                                 CLASSIC EVENT MODEL// *******************************************************************************************// // This program utilises Carbon Scrap Manager functions to allow the user to://// ╔	Cut, copy, clear, and paste text and pictures from and to two document windows opened by//		the program.//// ╔	Paste text and pictures cut or copied from another application to the two document //		windows.//// ╔	Open and close a Clipboard window, in which the current contents of the scrap are//		displayed.//// The program's preferred scrap flavour type is 'TEXT'.  Thus, if the scrap contains data in// both the 'TEXT' and 'PICT' flavour types, only the 'TEXT' flavour will be used for pastes// to the document windows and and for display in the Clipboard window.//// In order to keep that part of the source code that is not related to the Carbon Scrap // Manager to a minimum, the windows do not display insertion points, nor can the pictures be// dragged within the windows.  The text and pictures are not inserted into a document as // such.  When the Paste item in the Edit menu is chosen://// ╔	The text or picture on the Clipboard is simply drawn in the centre of the active window.//// ╔	A handle to the text or picture is assigned to fields in a document structure associated//		with the window.  (The demonstration program at MonoTextEdit shows how to cut, copy, and//    paste text from and to a TextEdit structure using the scrap.) //// For the same reason, highlighting the selected text or picture in a window is achieved by// simply inverting the image.//// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	An 'MBAR' resource, and 'MENU' resources for Apple, File, and Edit menus (preload, //		non-purgeable).  //// ╔	Three 'WIND' resources (purgeable) (initially visible), two for the program's main//		windows and one for the Clipboard window.  //// ╔	A 'TEXT' resource (non-purgeable) containing text displayed in the left window at //		program	start. //// ╔	A 'PICT' resource (non-purgeable) containing a picture displayed in the right window at//		program start.//// ╔	A 'STR#' resource (purgeable) containing strings to be displayed in the error Alert.//// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar					128#define mAppleApplication	128#define  iAbout						1#define mFile							129#define  iClose						4#define  iQuit						12#define mEdit							130#define  iCut							3#define  iCopy						4#define  iPaste						5#define  iClear						6#define  iClipboard				8#define rWindow						128#define rClipboardWindow	130#define rText							128#define rPicture					128#define rErrorStrings			128#define  eFailMenu				1#define  eFailWindow			2#define  eFailDocStruc		3#define  eFailMemory			4#define  eClearScrap			5#define  ePutScrapFlavor	6#define  eGetScrapSize		7#define  eGetScrapData		8		#define kDocumentType			1#define kClipboardType		2#define MAX_UINT32				0xFFFFFFFF// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии typedefstypedef struct{	PicHandle	pictureHdl;	Handle		textHdl;	Boolean		selectFlag;	SInt16		windowType;} docStructure, **docStructureHandle;// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean		gRunningOnX					= false;Boolean		gDone;WindowRef	gWindowRefs[2];WindowRef	gClipboardWindowRef	= NULL;Boolean		gClipboardShowing		= false;SInt16		gPixelDepth;Boolean		gIsColourDevice			= false;// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid	main									(void);void	doPreliminaries				(void);OSErr	quitAppEventHandler		(AppleEvent *,AppleEvent *,SInt32);void	doEvents							(EventRecord *);void	doUpdate							(EventRecord *);void	doOSEvent							(EventRecord *);void	doAdjustMenus					(void);void	doMenuChoice					(SInt32);void	doErrorAlert					(SInt16);void	doOpenWindows					(void);void	doCloseWindow					(void);void	doInContent						(Point);void	doCutCopyCommand			(Boolean);void	doPasteCommand				(void);void	doClearCommand				(void);void	doClipboardCommand		(void);void	doDrawClipboardWindow	(void);void	doDrawDocumentWindow	(WindowRef);Rect	doSetDestRect					(Rect *,WindowRef);void	doGetDepthAndDevice		(void);// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	Boolean			  gotEvent;	EventRecord	  eventStructure;	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus		menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		doErrorAlert(eFailMenu);	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}		gRunningOnX = true;	}	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open windows	doOpenWindows();	// ииииииииииииииии get pixel depth and whether colour device for function SetThemeTextColor		doGetDepthAndDevice();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии enter eventLoop		gDone = false;	while(!gDone)	{		gotEvent = WaitNextEvent(everyEvent,&eventStructure,MAX_UINT32,NULL);		if(gotEvent)			doEvents(&eventStructure);	}}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	OSErr	osError;	MoreMasterPointers(96);	InitCursor();	FlushEvents(everyEvent,0);	osError = AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,														NewAEEventHandlerUPP((AEEventHandlerProcPtr) quitAppEventHandler),														0L,false);	if(osError != noErr)		ExitToShell();}// **************************************************************************** doQuitAppEventOSErr  quitAppEventHandler(AppleEvent *appEvent,AppleEvent *reply,SInt32 handlerRefcon){	OSErr			osError;	DescType	returnedType;	Size			actualSize;	osError = AEGetAttributePtr(appEvent,keyMissedKeywordAttr,typeWildCard,&returnedType,NULL,0,															&actualSize);	if(osError == errAEDescNotFound)	{		CallInScrapPromises();		gDone = true;		osError = noErr;	} 	else if(osError == noErr)		osError = errAEParamMissed;	return osError;}// ********************************************************************************** doEventsvoid	doEvents(EventRecord *eventStrucPtr){	WindowPartCode	partCode;	WindowRef				windowRef;	switch(eventStrucPtr->what)	{		case kHighLevelEvent:			AEProcessAppleEvent(eventStrucPtr);			break;		case mouseDown:			partCode = FindWindow(eventStrucPtr->where,&windowRef);			switch(partCode)			{				case inMenuBar:					doAdjustMenus();					doMenuChoice(MenuSelect(eventStrucPtr->where));					break;				case inContent:					if(windowRef != FrontWindow())						SelectWindow(windowRef);					else						doInContent(eventStrucPtr->where);					break;				case inDrag:					DragWindow(windowRef,eventStrucPtr->where,NULL);					break;				case inGoAway:					if(TrackGoAway(windowRef,eventStrucPtr->where) == true)						doCloseWindow();					break;			}			break;		case keyDown:			if((eventStrucPtr->modifiers & cmdKey) != 0)			{				doAdjustMenus();				doMenuChoice(MenuEvent(eventStrucPtr));			}			break;		case updateEvt:			doUpdate(eventStrucPtr);			break;		case activateEvt:			windowRef = (WindowRef) eventStrucPtr->message;			if(windowRef == gClipboardWindowRef)				doDrawClipboardWindow();			break;		case osEvt:			doOSEvent(eventStrucPtr);			break;	}}// ********************************************************************************** doUpdatevoid  doUpdate(EventRecord *eventStrucPtr){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	SInt32							windowType;	windowRef = (WindowRef) eventStrucPtr->message;	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	windowType = (*docStrucHdl)->windowType;	BeginUpdate(windowRef);	if(windowType == kDocumentType)	{		if((*docStrucHdl)->pictureHdl != NULL || (*docStrucHdl)->textHdl != NULL)			doDrawDocumentWindow(windowRef);	}	else if(windowType == kClipboardType)		doDrawClipboardWindow();	EndUpdate(windowRef);}// ********************************************************************************* doOSEventvoid	doOSEvent(EventRecord *eventStrucPtr){	switch((eventStrucPtr->message >> 24) & 0x000000FF)	{		case suspendResumeMessage:			if((eventStrucPtr->message & resumeFlag) == 1)			{				SetThemeCursor(kThemeArrowCursor);				if(gClipboardWindowRef && gClipboardShowing)					ShowWindow(gClipboardWindowRef);			}			else			{				if(gClipboardWindowRef && gClipboardShowing)				ShowHide(gClipboardWindowRef,false);			}			break;	}}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef							fileMenuRef, editMenuRef;	docStructureHandle	docStrucHdl;	ScrapRef						scrapRef;	OSStatus						osError;	ScrapFlavorFlags		scrapFlavorFlags;	Boolean							scrapHasText = false, scrapHasPicture = false;	fileMenuRef = GetMenuRef(mFile);	editMenuRef = GetMenuRef(mEdit);	docStrucHdl = (docStructureHandle) GetWRefCon(FrontWindow());	if((*docStrucHdl)->windowType == kClipboardType)		EnableMenuItem(fileMenuRef,iClose);	else		DisableMenuItem(fileMenuRef,iClose);	if(((*docStrucHdl)->pictureHdl || (*docStrucHdl)->textHdl) && ((*docStrucHdl)->selectFlag))	{		EnableMenuItem(editMenuRef,iCut);		EnableMenuItem(editMenuRef,iCopy);		EnableMenuItem(editMenuRef,iClear);	}	else	{		DisableMenuItem(editMenuRef,iCut);		DisableMenuItem(editMenuRef,iCopy);		DisableMenuItem(editMenuRef,iClear);	}	GetCurrentScrap(&scrapRef);	osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&scrapFlavorFlags);	if(osError == noErr)		scrapHasText = true;	osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypePicture,&scrapFlavorFlags);	if(osError == noErr)		scrapHasPicture = true;	if((scrapHasText || scrapHasPicture) && ((*docStrucHdl)->windowType != kClipboardType))		EnableMenuItem(editMenuRef,iPaste);	else		DisableMenuItem(editMenuRef,iPaste);	DrawMenuBar();}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(SInt32 menuChoice){	MenuID				menuID;	MenuItemIndex	menuItem;	menuID = HiWord(menuChoice);	menuItem = LoWord(menuChoice);	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;		case mFile:			if(menuItem == iClose)				doCloseWindow();			else if(menuItem == iQuit)			{				CallInScrapPromises();				gDone = true;			}			break;		case mEdit:			switch(menuItem)			{				case iCut:					doCutCopyCommand(true);					break;				case iCopy:					doCutCopyCommand(false);					break;				case iPaste:					doPasteCommand();					break;				case iClear:					doClearCommand();					break;				case iClipboard:					doClipboardCommand();					break;			}			break;			}	HiliteMenu(0);}// ****************************************************************************** doErrorAlertvoid  doErrorAlert(SInt16 errorCode){	Str255	errorString;	SInt16	itemHit;	GetIndString(errorString,rErrorStrings,errorCode);	StandardAlert(kAlertStopAlert,errorString,NULL,NULL,&itemHit);	ExitToShell();}// ***************************************************************************** doOpenWindowsvoid  doOpenWindows(void){	SInt16							a;	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	Rect								theRect;	for(a=0;a<2;a++)	{		if(!(windowRef = GetNewCWindow(rWindow + a,NULL,(WindowRef) -1)))			doErrorAlert(eFailWindow);		gWindowRefs[a] = windowRef;		if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))			doErrorAlert(eFailDocStruc);		SetWRefCon(windowRef,(SInt32) docStrucHdl);		(*docStrucHdl)->pictureHdl = NULL;		(*docStrucHdl)->textHdl		 = NULL;		(*docStrucHdl)->windowType = kDocumentType;		(*docStrucHdl)->selectFlag = false;			SetPortWindowPort(windowRef);		TextSize(10);		if(gRunningOnX)		{			GetWindowPortBounds(windowRef,&theRect);			InsetRect(&theRect,40,40);			ClipRect(&theRect);		}		if(a == 0)			(*docStrucHdl)->textHdl = (Handle) GetResource('TEXT',rText);		else			(*docStrucHdl)->pictureHdl = GetPicture(rPicture);	}}// ***************************************************************************** doCloseWindowvoid  doCloseWindow(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	MenuRef							editMenuRef;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->windowType == kClipboardType)	{		DisposeWindow(windowRef);		gClipboardWindowRef = NULL;		gClipboardShowing = false;		editMenuRef = GetMenuRef(mEdit);		SetMenuItemText(editMenuRef,iClipboard,"\pShow Clipboard");	}}// ******************************************************************************* doInContentvoid  doInContent(Point mouseXY){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	GrafPtr							oldPort;	Rect								theRect;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->windowType == kClipboardType)		return;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	if((*docStrucHdl)->textHdl != NULL || (*docStrucHdl)->pictureHdl != NULL)	{		if((*docStrucHdl)->textHdl != NULL)		{			GetWindowPortBounds(windowRef,&theRect);			InsetRect(&theRect,40,40);		}		else if((*docStrucHdl)->pictureHdl != NULL) 		{			theRect = doSetDestRect(&(*(*docStrucHdl)->pictureHdl)->picFrame,windowRef);		}		GlobalToLocal(&mouseXY);		if(PtInRect(mouseXY,&theRect) && (*docStrucHdl)->selectFlag == false)		{			(*docStrucHdl)->selectFlag = true;			InvertRect(&theRect);		}		else if(!PtInRect(mouseXY,&theRect) && (*docStrucHdl)->selectFlag == true)		{			(*docStrucHdl)->selectFlag = false;			InvertRect(&theRect);		}	}	SetPort(oldPort);}// ************************************************************************** doCutCopyCommandvoid  doCutCopyCommand(Boolean cutFlag){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;		OSStatus						osError;	ScrapRef						scrapRef;	Size								dataSize;	GrafPtr							oldPort;	Rect								portRect;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->selectFlag == false)		return;	osError = ClearCurrentScrap();	if(osError == noErr)	{		GetCurrentScrap(&scrapRef);		if((*docStrucHdl)->textHdl != NULL)  // ииииииииииииииииииииииииииииииииииииииииииии'TEXT'		{			dataSize = GetHandleSize((Handle) (*docStrucHdl)->textHdl);			HLock((*docStrucHdl)->textHdl);			osError = PutScrapFlavor(scrapRef,kScrapFlavorTypeText,kScrapFlavorMaskNone,															 dataSize,*((*docStrucHdl)->textHdl));			if(osError != noErr)				doErrorAlert(ePutScrapFlavor);		}		else if((*docStrucHdl)->pictureHdl != NULL)  // иииииииииииииииииииииииииииииииииии 'PICT'		{			dataSize = GetHandleSize((Handle) (*docStrucHdl)->pictureHdl);			HLock((Handle) (*docStrucHdl)->pictureHdl);			osError = PutScrapFlavor(scrapRef,kScrapFlavorTypePicture,kScrapFlavorMaskNone,														 	 dataSize,*((Handle) (*docStrucHdl)->pictureHdl));			if(osError != noErr)				doErrorAlert(ePutScrapFlavor);		}		if((*docStrucHdl)->textHdl != NULL)			HUnlock((*docStrucHdl)->textHdl);		if((*docStrucHdl)->pictureHdl != NULL)			HUnlock((Handle) (*docStrucHdl)->pictureHdl);	}	else		doErrorAlert(eClearScrap);	if(cutFlag)	{		GetPort(&oldPort);		SetPortWindowPort(windowRef);		if((*docStrucHdl)->pictureHdl != NULL)		{			DisposeHandle((Handle) (*docStrucHdl)->pictureHdl);			(*docStrucHdl)->pictureHdl = NULL;			(*docStrucHdl)->selectFlag = false;		}		if((*docStrucHdl)->textHdl != NULL)		{			DisposeHandle((*docStrucHdl)->textHdl);			(*docStrucHdl)->textHdl = NULL;			(*docStrucHdl)->selectFlag = false;		}		GetWindowPortBounds(windowRef,&portRect);		EraseRect(&portRect);		SetPort(oldPort);	}	if(gClipboardWindowRef != NULL)		doDrawClipboardWindow();}// **************************************************************************** doPasteCommandvoid  doPasteCommand(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;		GrafPtr							oldPort;	ScrapRef						scrapRef;	OSStatus						osError;	ScrapFlavorFlags		flavorFlags;	Size								sizeOfPictData = 0, sizeOfTextData = 0;	Handle							newTextHdl, newPictHdl;	CFStringRef					stringRef;	Rect								destRect, portRect;		windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	GetPort(&oldPort);	SetPortWindowPort(windowRef);		GetCurrentScrap(&scrapRef);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии 'TEXT'	osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&flavorFlags);	if(osError == noErr)	{		osError = GetScrapFlavorSize(scrapRef,kScrapFlavorTypeText,&sizeOfTextData);		if(osError == noErr && sizeOfTextData > 0)		{			newTextHdl = NewHandle(sizeOfTextData);				osError = MemError();			if(osError == memFullErr)				doErrorAlert(eFailMemory);			HLock(newTextHdl);			osError = GetScrapFlavorData(scrapRef,kScrapFlavorTypeText,&sizeOfTextData,*newTextHdl);			if(osError != noErr)				doErrorAlert(eGetScrapData);			// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии draw text in window			GetWindowPortBounds(windowRef,&portRect);			EraseRect(&portRect);			InsetRect(&portRect,40,40);						if(!gRunningOnX)			{				TETextBox(*newTextHdl,sizeOfTextData,&portRect,teFlushLeft);			}			else			{				stringRef =	CFStringCreateWithBytes(NULL,(UInt8 *) *newTextHdl,sizeOfTextData,																						smSystemScript,false);				DrawThemeTextBox(stringRef,kThemeSmallSystemFont,kThemeStateActive,true,&portRect,												 teFlushLeft,NULL);				if(stringRef != NULL)					CFRelease(stringRef);			}			HUnlock(newTextHdl);			(*docStrucHdl)->selectFlag = false;			// ииииииииииииииииииииииииииии assign handle to new text to window's document structure			if((*docStrucHdl)->textHdl != NULL)				DisposeHandle((*docStrucHdl)->textHdl);			(*docStrucHdl)->textHdl = newTextHdl;			if((*docStrucHdl)->pictureHdl != NULL)				DisposeHandle((Handle) (*docStrucHdl)->pictureHdl);			(*docStrucHdl)->pictureHdl = NULL;		}		else			doErrorAlert(eGetScrapSize);	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии ' PICT'	else 	{		(osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypePicture,&flavorFlags));		if(osError == noErr)		{			osError = GetScrapFlavorSize(scrapRef,kScrapFlavorTypePicture,&sizeOfPictData);			if(osError == noErr && sizeOfPictData > 0)			{				newPictHdl = NewHandle(sizeOfPictData);					osError = MemError();				if(osError == memFullErr)					doErrorAlert(eFailMemory);				HLock(newPictHdl);				osError = GetScrapFlavorData(scrapRef,kScrapFlavorTypePicture,&sizeOfPictData,																	 *newPictHdl);				if(osError != noErr)					doErrorAlert(eGetScrapData);				// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии draw picture in window				GetWindowPortBounds(windowRef,&portRect);				EraseRect(&portRect);				(*docStrucHdl)->selectFlag = false;				destRect = doSetDestRect(&(*(PicHandle) newPictHdl)->picFrame,windowRef);				DrawPicture((PicHandle) newPictHdl,&destRect);				HUnlock(newPictHdl);				(*docStrucHdl)->selectFlag = false;				// иииииииииииииииииииииии assign handle to new picture to window's document structure				if((*docStrucHdl)->pictureHdl != NULL)					DisposeHandle((Handle) (*docStrucHdl)->pictureHdl);				(*docStrucHdl)->pictureHdl = (PicHandle) newPictHdl;				if((*docStrucHdl)->textHdl != NULL)					DisposeHandle((Handle) (*docStrucHdl)->textHdl);				(*docStrucHdl)->textHdl = NULL;			}			else				doErrorAlert(eGetScrapSize);		}	}	SetPort(oldPort);}// **************************************************************************** doClearCommandvoid  doClearCommand(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;		GrafPtr							oldPort;	Rect								portRect;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	GetPort(&oldPort);	SetPortWindowPort(windowRef);	if((*docStrucHdl)->textHdl != NULL)	{		DisposeHandle((*docStrucHdl)->textHdl);		(*docStrucHdl)->textHdl = NULL;	}	if((*docStrucHdl)->pictureHdl != NULL)	{		DisposeHandle((Handle) (*docStrucHdl)->pictureHdl);		(*docStrucHdl)->pictureHdl = NULL;	}		(*docStrucHdl)->selectFlag = false;	GetWindowPortBounds(windowRef,&portRect);	EraseRect(&portRect);	SetPort(oldPort);}// ************************************************************************ doClipboardCommandvoid  doClipboardCommand(void){	MenuRef							editMenuRef;	docStructureHandle	docStrucHdl;		editMenuRef = GetMenuRef(mEdit);	if(gClipboardWindowRef == NULL)	{		if(!(gClipboardWindowRef = GetNewCWindow(rClipboardWindow,NULL,(WindowRef)-1)))			doErrorAlert(eFailWindow);		if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))			doErrorAlert(eFailDocStruc);		SetWRefCon(gClipboardWindowRef,(SInt32) docStrucHdl);		(*docStrucHdl)->windowType = kClipboardType;		SetMenuItemText(editMenuRef,iClipboard,"\pHide Clipboard");					gClipboardShowing = true;	}	else	{		if(gClipboardShowing)		{			HideWindow(gClipboardWindowRef);			gClipboardShowing = false;			SetMenuItemText(editMenuRef,iClipboard,"\pShow Clipboard");		}		else		{			ShowWindow(gClipboardWindowRef);			gClipboardShowing = true;			SetMenuItemText(editMenuRef,iClipboard,"\pHide Clipboard");						}	}}// ********************************************************************* doDrawClipboardWindowvoid  doDrawClipboardWindow(void){	GrafPtr						oldPort;	Rect							theRect, textBoxRect;	ScrapRef					scrapRef;	OSStatus					osError;	ScrapFlavorFlags	flavorFlags;	CFStringRef				stringRef;	Handle						tempHdl;	Size							sizeOfPictData = 0, sizeOfTextData = 0;	RGBColor					blackColour = { 0x0000, 0x0000, 0x0000 };		GetPort(&oldPort);	SetPortWindowPort(gClipboardWindowRef);		GetWindowPortBounds(gClipboardWindowRef,&theRect);	EraseRect(&theRect);	SetRect(&theRect,-1,-1,597,24);	DrawThemeWindowHeader(&theRect,gClipboardWindowRef == FrontWindow());	if(gClipboardWindowRef == FrontWindow())		TextMode(srcOr);	else	  TextMode(grayishTextOr);	SetRect(&textBoxRect,10,5,120,20);	DrawThemeTextBox(CFSTR("Clipboard Contents:"),kThemeSmallSystemFont,0,true,&textBoxRect,									 teJustLeft,NULL);	GetCurrentScrap(&scrapRef);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии 'TEXT'	osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&flavorFlags);	if(osError == noErr)	{		osError = GetScrapFlavorSize(scrapRef,kScrapFlavorTypeText,&sizeOfTextData);		if(osError == noErr && sizeOfTextData > 0)		{			SetRect(&textBoxRect,120,5,597,20);			DrawThemeTextBox(CFSTR("Text"),kThemeSmallSystemFont,0,true,&textBoxRect,teJustLeft,											 NULL);			tempHdl = NewHandle(sizeOfTextData);				osError = MemError();			if(osError == memFullErr)				doErrorAlert(eFailMemory);			HLock(tempHdl);			osError = GetScrapFlavorData(scrapRef,kScrapFlavorTypeText,&sizeOfTextData,*tempHdl);			if(osError != noErr)				doErrorAlert(eGetScrapData);			// иииииииииииииииииииииииииииииииииииииииииииииииииииииии draw text in clipboard window			GetWindowPortBounds(gClipboardWindowRef,&theRect);			theRect.top += 24;			InsetRect(&theRect,2,2);			if(sizeOfTextData >= 965)				sizeOfTextData = 965;			stringRef =	CFStringCreateWithBytes(NULL,(UInt8 *) *tempHdl,sizeOfTextData,																					CFStringGetSystemEncoding(),true);					DrawThemeTextBox(stringRef,kThemeSmallSystemFont,0,true,&theRect,teFlushLeft,NULL);			if(stringRef != NULL)				CFRelease(stringRef);			HUnlock(tempHdl);			DisposeHandle(tempHdl);		}		else			doErrorAlert(eGetScrapSize);	}	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии 'PICT'	else 	{		osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypePicture,&flavorFlags);		if(osError == noErr)		{			osError = GetScrapFlavorSize(scrapRef,kScrapFlavorTypePicture,&sizeOfPictData);			if(osError == noErr && sizeOfPictData > 0)			{				SetRect(&textBoxRect,120,5,597,20);				DrawThemeTextBox(CFSTR("Picture"),kThemeSmallSystemFont,0,true,&textBoxRect,												 teJustLeft,NULL);				tempHdl = NewHandle(sizeOfPictData);				osError = MemError();				if(osError == memFullErr)					doErrorAlert(eFailMemory);				HLock(tempHdl);				osError = GetScrapFlavorData(scrapRef,kScrapFlavorTypePicture,&sizeOfPictData,																		 *tempHdl);				if(osError != noErr)					doErrorAlert(eGetScrapData);				// ииииииииииииииииииииииииииииииииииииииииииииииииии draw picture in clipboard window				theRect = (*(PicHandle) tempHdl)->picFrame;				OffsetRect(&theRect,-((*(PicHandle) tempHdl)->picFrame.left - 2),													  -((*(PicHandle) tempHdl)->picFrame.top - 26));				DrawPicture((PicHandle) tempHdl,&theRect);				HUnlock(tempHdl);				DisposeHandle(tempHdl);			}			else				doErrorAlert(eGetScrapSize);		}	}	TextMode(srcOr);	SetPort(oldPort);}// ********************************************************************** doDrawDocumentWindowvoid  doDrawDocumentWindow(WindowRef windowRef){	GrafPtr							oldPort;	docStructureHandle	docStrucHdl;	Rect  							destRect;	CFStringRef					stringRef;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->textHdl != NULL)	{		GetWindowPortBounds(windowRef,&destRect);		InsetRect(&destRect,40,40);		stringRef =	CFStringCreateWithBytes(NULL,(UInt8 *) *(*docStrucHdl)->textHdl,																				GetHandleSize((*docStrucHdl)->textHdl),																				smSystemScript,false);		DrawThemeTextBox(stringRef,kThemeSmallSystemFont,0,true,&destRect,teFlushLeft,NULL);		if(stringRef != NULL)			CFRelease(stringRef);		if((*docStrucHdl)->selectFlag)			InvertRect(&destRect);	}	else if((*docStrucHdl)->pictureHdl != NULL)	{		destRect = doSetDestRect(&(*(*docStrucHdl)->pictureHdl)->picFrame,windowRef);		DrawPicture((*docStrucHdl)->pictureHdl,&destRect);		if((*docStrucHdl)->selectFlag)			InvertRect(&destRect);	} 	SetPort(oldPort);}// ***************************************************************************** doSetDestRectRect  doSetDestRect(Rect *picFrame,WindowRef windowRef){	Rect		destRect, portRect;	SInt16	diffX, diffY;	destRect = *picFrame;	GetWindowPortBounds(windowRef,&portRect);		OffsetRect(&destRect,-(*picFrame).left,-(*picFrame).top);	diffX = (portRect.right - portRect.left) - ((*picFrame).right - (*picFrame).left);	diffY = (portRect.bottom - portRect.top) - ((*picFrame).bottom - (*picFrame).top);	OffsetRect(&destRect,diffX / 2,diffY / 2);		return destRect;}// *********************************************************************** doGetDepthAndDevicevoid doGetDepthAndDevice(void){	GDHandle	deviceHdl;	deviceHdl = GetMainDevice();	gPixelDepth = (*(*deviceHdl)->gdPMap)->pixelSize;	if(((1 << gdDevType) & (*deviceHdl)->gdFlags) != 0)		gIsColourDevice = true;}// *******************************************************************************************