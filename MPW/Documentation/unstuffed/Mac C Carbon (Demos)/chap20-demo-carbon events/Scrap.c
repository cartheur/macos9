// *******************************************************************************************// Scrap.c                                                                  CARBON EVENT MODEL// *******************************************************************************************// // This program utilises Carbon Scrap Manager functions to allow the user to://// ╔	Cut, copy, clear, and paste text and pictures from and to two document windows opened by//		the program.//// ╔	Paste text and pictures cut or copied from another application to the two document //		windows.//// ╔	Open and close a Clipboard window, in which the current contents of the scrap are//		displayed.//// The program's preferred scrap flavour type is 'TEXT'.  Thus, if the scrap contains data in// both the 'TEXT' and 'PICT' flavour types, only the 'TEXT' flavour will be used for pastes// to the document windows and display in the Clipboard window.//// In order to keep that part of the source code that is not related to the Carbon Scrap // Manager to a minimum, the windows do not display insertion points, nor can the pictures be// dragged within the windows.  The text and pictures are not inserted into a document as // such.  Rather, when the Paste item in the Edit menu is chosen://// ╔	The text or picture on the Clipboard is simply drawn in the centre of the active window.//// ╔	A handle to the text or picture is assigned to fields in a document structure associated//		with the window.  (The demonstration program MonoTextEdit (Chapter 21) shows how to cut,//		copy, and paste text from and to a TextEdit structure using the scrap.) //// For the same reason, highlighting the selected text or picture in a window is simplified by// simply inverting the image.//// The program utilises the following resources://// ╔	A 'plst' resource.//// ╔	An 'MBAR' resource, and 'MENU' resources for Apple, File, and Edit menus (preload, //		non-purgeable).  //// ╔	A 'TEXT' resource (non-purgeable) containing text displayed in the left window at //		program	start. //// ╔	A 'PICT' resource (non-purgeable) containing a picture displayed in the right window at//		program start.//// ╔	A 'STR#' resource (purgeable) containing strings to be displayed in the error Alert.//// ╔	A 'SIZE' resource with the acceptSuspendResumeEvents, canBackground, //		doesActivateOnFGSwitch, and isHighLevelEventAware flags set.//// *******************************************************************************************// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии includes#include <Carbon.h>// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии defines#define rMenubar					128#define mAppleApplication	128#define  iAbout						1#define mFile							129#define  iClose						4#define  iQuit						12#define mEdit							130#define  iCut							3#define  iCopy						4#define  iPaste						5#define  iClear						6#define  iClipboard				8#define rText							128#define rPicture					128#define rErrorStrings			128#define  eFailMenu				1#define  eFailWindow			2#define  eFailDocStruc		3#define  eFailMemory			4#define  eClearScrap			5#define  ePutScrapFlavor	6#define  eGetScrapSize		7#define  eGetScrapData		8#define kDocumentType			1#define kClipboardType		2#define MAX_UINT32				0xFFFFFFFF// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии typedefstypedef struct{	PicHandle	pictureHdl;	Handle		textHdl;	Boolean		selectFlag;	SInt16		windowType;} docStructure, **docStructureHandle;// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии global variablesBoolean		gRunningOnX					= false;WindowRef	gClipboardWindowRef	= NULL;Boolean		gClipboardShowing		= false;// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии function prototypesvoid						main										(void);void						doPreliminaries					(void);OSStatus  			appEventHandler					(EventHandlerCallRef,EventRef,void *);OSStatus  			docWindowEventHandler		(EventHandlerCallRef,EventRef,void *);OSStatus  			clipWindowEventHandler	(EventHandlerCallRef,EventRef,void *);void						doAdjustMenus						(void);void						doMenuChoice						(MenuID,MenuItemIndex);void						doErrorAlert						(SInt16);void						doOpenDocumentWindows		(void);EventHandlerUPP	doGetHandlerUPP					(void);void						doCloseWindow						(void);void						doInContent							(Point);void						doCutCopyCommand				(Boolean);void						doPasteCommand					(void);void						doClearCommand					(void);void						doClipboardCommand			(void);void						doDrawClipboardWindow		(void);void						doDrawDocumentWindow		(WindowRef);Rect						doSetDestRect						(Rect *,WindowRef);// ************************************************************************************** mainvoid  main(void){	MenuBarHandle	menubarHdl;	SInt32				response;	MenuRef				menuRef;	EventTypeSpec	applicationEvents[] =	{ { kEventClassApplication, kEventAppActivated    },																				{ kEventClassApplication, kEventAppDeactivated 	},																				{ kEventClassCommand,     kEventProcessCommand  },																				{ kEventClassMenu,        kEventMenuEnableItems } };	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии do preliminaries	doPreliminaries();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии set up menu bar and menus	menubarHdl = GetNewMBar(rMenubar);	if(menubarHdl == NULL)		doErrorAlert(eFailMenu);	SetMenuBar(menubarHdl);	DrawMenuBar();	Gestalt(gestaltMenuMgrAttr,&response);	if(response & gestaltMenuMgrAquaLayoutMask)	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)		{			DeleteMenuItem(menuRef,iQuit);			DeleteMenuItem(menuRef,iQuit - 1);			DisableMenuItem(menuRef,0);		}		gRunningOnX = true;	}	else	{		menuRef = GetMenuRef(mFile);		if(menuRef != NULL)			SetMenuItemCommandID(menuRef,iQuit,kHICommandQuit);	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии open document windows	doOpenDocumentWindows();	// иииииииииииииииииииииииииииииииииииииииииииииииииииииии install application event handler	InstallApplicationEventHandler(NewEventHandlerUPP((EventHandlerProcPtr) appEventHandler),																 GetEventTypeCount(applicationEvents),applicationEvents,																 0,NULL);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии run application event loop	RunApplicationEventLoop();}// *************************************************************************** doPreliminariesvoid  doPreliminaries(void){	MoreMasterPointers(96);	InitCursor();}// *************************************************************************** appEventHandlerOSStatus  appEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,													void * userData){	OSStatus			result = eventNotHandledErr;	UInt32				eventClass;	UInt32				eventKind;	HICommand			hiCommand;	MenuID				menuID;	MenuItemIndex	menuItem;	eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	switch(eventClass)	{		case kEventClassApplication:			if(eventKind == kEventAppActivated)			{				SetThemeCursor(kThemeArrowCursor);				if(gClipboardWindowRef && gClipboardShowing)					ShowWindow(gClipboardWindowRef);			}			else if(eventKind == kEventAppDeactivated)			{				if(gClipboardWindowRef && gClipboardShowing)					ShowHide(gClipboardWindowRef,false);			}		break;		case kEventClassCommand:			if(eventKind == kEventProcessCommand)			{				GetEventParameter(eventRef,kEventParamDirectObject,typeHICommand,NULL,													sizeof(HICommand),NULL,&hiCommand);				menuID = GetMenuID(hiCommand.menu.menuRef);				menuItem = hiCommand.menu.menuItemIndex;				if((hiCommand.commandID != kHICommandQuit) && 					 (menuID >= mAppleApplication && menuID <= mEdit))				{					doMenuChoice(menuID,menuItem);					result = noErr;				}			}			break;					case kEventClassMenu:			if(eventKind == kEventMenuEnableItems)				doAdjustMenus();			result = noErr;			break;	}	return result;}// ********************************************************************* docWindowEventHandlerOSStatus  docWindowEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,																void * userData){	OSStatus						result = eventNotHandledErr;	UInt32							eventClass;	UInt32							eventKind;	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	Point								mouseLocation;		eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	switch(eventClass)	{		case kEventClassWindow:			GetEventParameter(eventRef,kEventParamDirectObject,typeWindowRef,NULL,sizeof(windowRef),										NULL,&windowRef);			switch(eventKind)			{				case kEventWindowDrawContent:					docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);					if((*docStrucHdl)->pictureHdl != NULL || (*docStrucHdl)->textHdl != NULL)						doDrawDocumentWindow(windowRef);					result = noErr;					break;								case kEventWindowClickContentRgn:					GetEventParameter(eventRef,kEventParamMouseLocation,typeQDPoint,NULL,														sizeof(mouseLocation),NULL,&mouseLocation);					SetPortWindowPort(windowRef);					GlobalToLocal(&mouseLocation);					doInContent(mouseLocation);					result = noErr;					break;			}			break;	}	return result;}// ******************************************************************** clipWindowEventHandlerOSStatus  clipWindowEventHandler(EventHandlerCallRef eventHandlerCallRef,EventRef eventRef,																 void * userData){	OSStatus	result = eventNotHandledErr;	UInt32		eventClass;	UInt32		eventKind;	MenuRef		editMenuRef;		eventClass = GetEventClass(eventRef);	eventKind  = GetEventKind(eventRef);	if(eventClass == kEventClassWindow)	{		switch(eventKind)		{			case kEventWindowActivated:			case kEventWindowDeactivated:			case kEventWindowDrawContent:				doDrawClipboardWindow();				result = noErr;				break;			case kEventWindowClose:				DisposeWindow(gClipboardWindowRef);				gClipboardWindowRef = NULL;				gClipboardShowing = false;				editMenuRef = GetMenuRef(mEdit);				SetMenuItemText(editMenuRef,iClipboard,"\pShow Clipboard");				break;		}	}			return result;}// ***************************************************************************** doAdjustMenusvoid  doAdjustMenus(void){	MenuRef							fileMenuRef, editMenuRef;	docStructureHandle	docStrucHdl;	ScrapRef						scrapRef;	OSStatus						osError;	ScrapFlavorFlags		scrapFlavorFlags;	Boolean							scrapHasText = false, scrapHasPicture = false;	fileMenuRef = GetMenuRef(mFile);	editMenuRef = GetMenuRef(mEdit);	docStrucHdl = (docStructureHandle) GetWRefCon(FrontWindow());	if((*docStrucHdl)->windowType == kClipboardType)		EnableMenuItem(fileMenuRef,iClose);	else	{		DisableMenuItem(fileMenuRef,iClose);		DisableMenuItem(editMenuRef,iCut);		DisableMenuItem(editMenuRef,iCopy);		DisableMenuItem(editMenuRef,iClear);	}	if(((*docStrucHdl)->pictureHdl || (*docStrucHdl)->textHdl) && ((*docStrucHdl)->selectFlag))	{		EnableMenuItem(editMenuRef,iCut);		EnableMenuItem(editMenuRef,iCopy);		EnableMenuItem(editMenuRef,iClear);	}	else	{		DisableMenuItem(editMenuRef,iCut);		DisableMenuItem(editMenuRef,iCopy);		DisableMenuItem(editMenuRef,iClear);	}	GetCurrentScrap(&scrapRef);	osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&scrapFlavorFlags);	if(osError == noErr)		scrapHasText = true;	osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypePicture,&scrapFlavorFlags);	if(osError == noErr)		scrapHasPicture = true;	if((scrapHasText || scrapHasPicture) && ((*docStrucHdl)->windowType != kClipboardType))		EnableMenuItem(editMenuRef,iPaste);	else		DisableMenuItem(editMenuRef,iPaste);	DrawMenuBar();}// ****************************************************************************** doMenuChoicevoid  doMenuChoice(MenuID menuID,MenuItemIndex menuItem){	if(menuID == 0)		return;	switch(menuID)	{		case mAppleApplication:			if(menuItem == iAbout)				SysBeep(10);			break;		case mFile:			if(menuItem == iClose)				doCloseWindow();			break;		case mEdit:			switch(menuItem)			{				case iCut:					doCutCopyCommand(true);					break;				case iCopy:					doCutCopyCommand(false);					break;				case iPaste:					doPasteCommand();					break;				case iClear:					doClearCommand();					break;				case iClipboard:					doClipboardCommand();					break;			}			break;			}}// ****************************************************************************** doErrorAlertvoid  doErrorAlert(SInt16 errorCode){	Str255	errorString;	SInt16	itemHit;	GetIndString(errorString,rErrorStrings,errorCode);	StandardAlert(kAlertStopAlert,errorString,NULL,NULL,&itemHit);	ExitToShell();}// ********************************************************************* doOpenDocumentWindowsvoid  doOpenDocumentWindows(void){	SInt16							a;	OSStatus						osError;	WindowRef						windowRef;	Rect								contentRect	= { 43,7,223,297 }, theRect;	Str255							title1			= "\pDocument A";	Str255					    title2			= "\pDocument B";	docStructureHandle	docStrucHdl;	EventTypeSpec				windowEvents[] = { { kEventClassWindow,	kEventWindowDrawContent     },																				 { kEventClassWindow,	kEventWindowClickContentRgn } };	for(a=0;a<2;a++)	{		osError = CreateNewWindow(kDocumentWindowClass,kWindowStandardHandlerAttribute,															&contentRect,&windowRef);		if(osError != noErr)			doErrorAlert(eFailWindow);					if(a == 0)		{			SetWTitle(windowRef,"\pDocument A");			OffsetRect(&contentRect,305,0);		}		else			SetWTitle(windowRef,"\pDocument B");		if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))			doErrorAlert(eFailDocStruc);		SetWRefCon(windowRef,(SInt32) docStrucHdl);		(*docStrucHdl)->pictureHdl = NULL;		(*docStrucHdl)->textHdl		 = NULL;		(*docStrucHdl)->windowType = kDocumentType;		(*docStrucHdl)->selectFlag = false;			SetPortWindowPort(windowRef);		if(gRunningOnX)		{			GetWindowPortBounds(windowRef,&theRect);			InsetRect(&theRect,40,40);			ClipRect(&theRect);		}		else			UseThemeFont(kThemeSmallSystemFont,smSystemScript);				if(a == 0)			(*docStrucHdl)->textHdl = (Handle) GetResource('TEXT',rText);		else			(*docStrucHdl)->pictureHdl = GetPicture(rPicture);		InstallWindowEventHandler(windowRef,doGetHandlerUPP(),GetEventTypeCount(windowEvents),															windowEvents,0,NULL);		ShowWindow(windowRef);	}}// *************************************************************************** doGetHandlerUPPEventHandlerUPP  doGetHandlerUPP(void){	static EventHandlerUPP	windowEventHandlerUPP;	if(windowEventHandlerUPP == NULL)		windowEventHandlerUPP = NewEventHandlerUPP((EventHandlerProcPtr) docWindowEventHandler);	return windowEventHandlerUPP;}// ***************************************************************************** doCloseWindowvoid  doCloseWindow(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	MenuRef							editMenuRef;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->windowType == kClipboardType)	{		DisposeWindow(windowRef);		gClipboardWindowRef = NULL;		gClipboardShowing = false;		editMenuRef = GetMenuRef(mEdit);		SetMenuItemText(editMenuRef,iClipboard,"\pShow Clipboard");	}}// ******************************************************************************* doInContentvoid  doInContent(Point mouseLocation){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;	GrafPtr							oldPort;	Rect								theRect;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->windowType == kClipboardType)		return;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	if((*docStrucHdl)->textHdl != NULL || (*docStrucHdl)->pictureHdl != NULL)	{		if((*docStrucHdl)->textHdl != NULL)		{			GetWindowPortBounds(windowRef,&theRect);			InsetRect(&theRect,40,40);		}		else if((*docStrucHdl)->pictureHdl != NULL) 		{			theRect = doSetDestRect(&(*(*docStrucHdl)->pictureHdl)->picFrame,windowRef);		}		if(PtInRect(mouseLocation,&theRect) && (*docStrucHdl)->selectFlag == false)		{			(*docStrucHdl)->selectFlag = true;			InvertRect(&theRect);		}		else if(!PtInRect(mouseLocation,&theRect) && (*docStrucHdl)->selectFlag == true)		{			(*docStrucHdl)->selectFlag = false;			InvertRect(&theRect);		}	}	SetPort(oldPort);}// ************************************************************************** doCutCopyCommandvoid  doCutCopyCommand(Boolean cutFlag){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;		OSStatus						osError;	ScrapRef						scrapRef;	Size								dataSize;	GrafPtr							oldPort;	Rect								portRect;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->selectFlag == false)		return;	osError = ClearCurrentScrap();	if(osError == noErr)	{		GetCurrentScrap(&scrapRef);		if((*docStrucHdl)->textHdl != NULL)  // ииииииииииииииииииииииииииииииииииииииииииии'TEXT'		{			dataSize = GetHandleSize((Handle) (*docStrucHdl)->textHdl);			HLock((*docStrucHdl)->textHdl);			osError = PutScrapFlavor(scrapRef,kScrapFlavorTypeText,kScrapFlavorMaskNone,															 dataSize,*((*docStrucHdl)->textHdl));			if(osError != noErr)				doErrorAlert(ePutScrapFlavor);		}		else if((*docStrucHdl)->pictureHdl != NULL)  // иииииииииииииииииииииииииииииииииии 'PICT'		{			dataSize = GetHandleSize((Handle) (*docStrucHdl)->pictureHdl);			HLock((Handle) (*docStrucHdl)->pictureHdl);			osError = PutScrapFlavor(scrapRef,kScrapFlavorTypePicture,kScrapFlavorMaskNone,														 	 dataSize,*((Handle) (*docStrucHdl)->pictureHdl));			if(osError != noErr)				doErrorAlert(ePutScrapFlavor);		}		if((*docStrucHdl)->textHdl != NULL)			HUnlock((*docStrucHdl)->textHdl);		if((*docStrucHdl)->pictureHdl != NULL)			HUnlock((Handle) (*docStrucHdl)->pictureHdl);	}	else		doErrorAlert(eClearScrap);	if(cutFlag)	{		GetPort(&oldPort);		SetPortWindowPort(windowRef);		if((*docStrucHdl)->pictureHdl != NULL)		{			DisposeHandle((Handle) (*docStrucHdl)->pictureHdl);			(*docStrucHdl)->pictureHdl = NULL;			(*docStrucHdl)->selectFlag = false;		}		if((*docStrucHdl)->textHdl != NULL)		{			DisposeHandle((*docStrucHdl)->textHdl);			(*docStrucHdl)->textHdl = NULL;			(*docStrucHdl)->selectFlag = false;		}		GetWindowPortBounds(windowRef,&portRect);		EraseRect(&portRect);		SetPort(oldPort);	}	if(gClipboardWindowRef != NULL)		doDrawClipboardWindow();}// **************************************************************************** doPasteCommandvoid  doPasteCommand(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;		GrafPtr							oldPort;	ScrapRef						scrapRef;	OSStatus						osError;	ScrapFlavorFlags		flavorFlags;	Size								sizeOfPictData = 0, sizeOfTextData = 0;	Handle							newTextHdl, newPictHdl;	CFStringRef					stringRef;	Rect								destRect, portRect;			windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	GetPort(&oldPort);	SetPortWindowPort(windowRef);		GetCurrentScrap(&scrapRef);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии 'TEXT'	osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&flavorFlags);	if(osError == noErr)	{		osError = GetScrapFlavorSize(scrapRef,kScrapFlavorTypeText,&sizeOfTextData);		if(osError == noErr && sizeOfTextData > 0)		{			newTextHdl = NewHandle(sizeOfTextData);				osError = MemError();			if(osError == memFullErr)				doErrorAlert(eFailMemory);			HLock(newTextHdl);			osError = GetScrapFlavorData(scrapRef,kScrapFlavorTypeText,&sizeOfTextData,*newTextHdl);			if(osError != noErr)				doErrorAlert(eGetScrapData);					// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии draw text in window			GetWindowPortBounds(windowRef,&portRect);			EraseRect(&portRect);			InsetRect(&portRect,40,40);						if(!gRunningOnX)			{				TETextBox(*newTextHdl,sizeOfTextData,&portRect,teFlushLeft);			}			else			{				stringRef =	CFStringCreateWithBytes(NULL,(UInt8 *) *newTextHdl,sizeOfTextData,																						smSystemScript,false);				DrawThemeTextBox(stringRef,kThemeSmallSystemFont,kThemeStateActive,true,&portRect,												 teFlushLeft,NULL);				if(stringRef != NULL)												 					CFRelease(stringRef);			}			HUnlock(newTextHdl);			(*docStrucHdl)->selectFlag = false;			// ииииииииииииииииииииииииииии assign handle to new text to window's document structure			if((*docStrucHdl)->textHdl != NULL)				DisposeHandle((*docStrucHdl)->textHdl);			(*docStrucHdl)->textHdl = newTextHdl;			if((*docStrucHdl)->pictureHdl != NULL)				DisposeHandle((Handle) (*docStrucHdl)->pictureHdl);			(*docStrucHdl)->pictureHdl = NULL;		}		else			doErrorAlert(eGetScrapSize);	}	// иииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии ' PICT'	else 	{		(osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypePicture,&flavorFlags));		if(osError == noErr)		{			osError = GetScrapFlavorSize(scrapRef,kScrapFlavorTypePicture,&sizeOfPictData);			if(osError == noErr && sizeOfPictData > 0)			{				newPictHdl = NewHandle(sizeOfPictData);					osError = MemError();				if(osError == memFullErr)					doErrorAlert(eFailMemory);				HLock(newPictHdl);				osError = GetScrapFlavorData(scrapRef,kScrapFlavorTypePicture,&sizeOfPictData,																	 *newPictHdl);				if(osError != noErr)					doErrorAlert(eGetScrapData);				// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии draw picture in window				GetWindowPortBounds(windowRef,&portRect);				EraseRect(&portRect);				(*docStrucHdl)->selectFlag = false;				destRect = doSetDestRect(&(*(PicHandle) newPictHdl)->picFrame,windowRef);				DrawPicture((PicHandle) newPictHdl,&destRect);				HUnlock(newPictHdl);				(*docStrucHdl)->selectFlag = false;				// иииииииииииииииииииииии assign handle to new picture to window's document structure				if((*docStrucHdl)->pictureHdl != NULL)					DisposeHandle((Handle) (*docStrucHdl)->pictureHdl);				(*docStrucHdl)->pictureHdl = (PicHandle) newPictHdl;					if((*docStrucHdl)->textHdl != NULL)					DisposeHandle((Handle) (*docStrucHdl)->textHdl);				(*docStrucHdl)->textHdl = NULL;			}			else				doErrorAlert(eGetScrapSize);		}	}	SetPort(oldPort);}// **************************************************************************** doClearCommandvoid  doClearCommand(void){	WindowRef						windowRef;	docStructureHandle	docStrucHdl;		GrafPtr							oldPort;	Rect								portRect;	windowRef = FrontWindow();	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	GetPort(&oldPort);	SetPortWindowPort(windowRef);	if((*docStrucHdl)->textHdl != NULL)	{		DisposeHandle((*docStrucHdl)->textHdl);		(*docStrucHdl)->textHdl = NULL;	}	if((*docStrucHdl)->pictureHdl != NULL)	{		DisposeHandle((Handle) (*docStrucHdl)->pictureHdl);		(*docStrucHdl)->pictureHdl = NULL;	}		(*docStrucHdl)->selectFlag = false;	GetWindowPortBounds(windowRef,&portRect);	EraseRect(&portRect);	SetPort(oldPort);}// ************************************************************************ doClipboardCommandvoid  doClipboardCommand(void){	MenuRef							editMenuRef;	OSStatus						osError;	Rect								contentRect = { 254,7,384,603 };	docStructureHandle	docStrucHdl;		EventTypeSpec				windowEvents[] = { { kEventClassWindow,	kEventWindowActivated   },																				 { kEventClassWindow,	kEventWindowDeactivated },																				 { kEventClassWindow, kEventWindowDrawContent },																				 { kEventClassWindow, kEventWindowClose       } };	editMenuRef = GetMenuRef(mEdit);	if(gClipboardWindowRef == NULL)	{		osError = CreateNewWindow(kDocumentWindowClass,kWindowStandardHandlerAttribute |															kWindowCloseBoxAttribute,&contentRect,&gClipboardWindowRef);		if(osError != noErr)			doErrorAlert(eFailWindow);					SetWTitle(gClipboardWindowRef,"\pClipboard");		SetPortWindowPort(gClipboardWindowRef);			if(!(docStrucHdl = (docStructureHandle) NewHandle(sizeof(docStructure))))			doErrorAlert(eFailDocStruc);		SetWRefCon(gClipboardWindowRef,(SInt32) docStrucHdl);		(*docStrucHdl)->windowType = kClipboardType;		SetMenuItemText(editMenuRef,iClipboard,"\pHide Clipboard");		InstallWindowEventHandler(gClipboardWindowRef,														NewEventHandlerUPP((EventHandlerProcPtr) clipWindowEventHandler),														GetEventTypeCount(windowEvents),windowEvents,0,NULL);		ShowWindow(gClipboardWindowRef);		gClipboardShowing = true;	}	else	{		if(gClipboardShowing)		{			HideWindow(gClipboardWindowRef);			gClipboardShowing = false;			SetMenuItemText(editMenuRef,iClipboard,"\pShow Clipboard");		}		else		{			ShowWindow(gClipboardWindowRef);			gClipboardShowing = true;			SetMenuItemText(editMenuRef,iClipboard,"\pHide Clipboard");						}	}}// ********************************************************************* doDrawClipboardWindowvoid  doDrawClipboardWindow(void){	GrafPtr						oldPort;	Rect							theRect, textBoxRect;	ScrapRef					scrapRef;	OSStatus					osError;	ScrapFlavorFlags	flavorFlags;	CFStringRef				stringRef;	Handle						tempHdl;	Size							sizeOfPictData = 0, sizeOfTextData = 0;	RGBColor					blackColour = { 0x0000, 0x0000, 0x0000 };		GetPort(&oldPort);	SetPortWindowPort(gClipboardWindowRef);		GetWindowPortBounds(gClipboardWindowRef,&theRect);	EraseRect(&theRect);	SetRect(&theRect,-1,-1,597,24);	DrawThemeWindowHeader(&theRect,gClipboardWindowRef == FrontWindow());	if(gClipboardWindowRef == FrontWindow())		TextMode(srcOr);	else	  TextMode(grayishTextOr);	SetRect(&textBoxRect,10,5,120,20);	DrawThemeTextBox(CFSTR("Clipboard Contents:"),kThemeSmallSystemFont,0,true,&textBoxRect,									 teJustLeft,NULL);		GetCurrentScrap(&scrapRef);	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии 'TEXT'	osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypeText,&flavorFlags);	if(osError == noErr)	{		osError = GetScrapFlavorSize(scrapRef,kScrapFlavorTypeText,&sizeOfTextData);		if(osError == noErr && sizeOfTextData > 0)		{			SetRect(&textBoxRect,120,5,597,20);			DrawThemeTextBox(CFSTR("Text"),kThemeSmallSystemFont,0,true,&textBoxRect,teJustLeft,											 NULL); 			tempHdl = NewHandle(sizeOfTextData);				osError = MemError();			if(osError == memFullErr)				doErrorAlert(eFailMemory);			HLock(tempHdl);			osError = GetScrapFlavorData(scrapRef,kScrapFlavorTypeText,&sizeOfTextData,*tempHdl);			if(osError != noErr)				doErrorAlert(eGetScrapData);			// иииииииииииииииииииииииииииииииииииииииииииииииииииииии draw text in clipboard window			GetWindowPortBounds(gClipboardWindowRef,&theRect);			theRect.top += 22;			InsetRect(&theRect,2,2);			if(sizeOfTextData >= 965)				sizeOfTextData = 965;			stringRef =	CFStringCreateWithBytes(NULL,(UInt8 *) *tempHdl,sizeOfTextData,																					CFStringGetSystemEncoding(),true);					DrawThemeTextBox(stringRef,kThemeSmallSystemFont,0,true,&theRect,teFlushLeft,NULL);			if(stringRef != NULL)				CFRelease(stringRef);			HUnlock(tempHdl);			DisposeHandle(tempHdl);		}		else			doErrorAlert(eGetScrapSize);	}	// ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии 'PICT'	else 	{		osError = GetScrapFlavorFlags(scrapRef,kScrapFlavorTypePicture,&flavorFlags);		if(osError == noErr)		{			osError = GetScrapFlavorSize(scrapRef,kScrapFlavorTypePicture,&sizeOfPictData);			if(osError == noErr && sizeOfPictData > 0)			{				SetRect(&textBoxRect,120,5,597,20);				DrawThemeTextBox(CFSTR("Picture"),kThemeSmallSystemFont,0,true,&textBoxRect,												 teJustLeft,NULL);				tempHdl = NewHandle(sizeOfPictData);				osError = MemError();				if(osError == memFullErr)					doErrorAlert(eFailMemory);				HLock(tempHdl);				osError = GetScrapFlavorData(scrapRef,kScrapFlavorTypePicture,&sizeOfPictData,																		 *tempHdl);				if(osError != noErr)					doErrorAlert(eGetScrapData);				// ииииииииииииииииииииииииииииииииииииииииииииииииии draw picture in clipboard window				theRect = (*(PicHandle) tempHdl)->picFrame;				OffsetRect(&theRect,-((*(PicHandle) tempHdl)->picFrame.left - 2),													  -((*(PicHandle) tempHdl)->picFrame.top - 26));				DrawPicture((PicHandle) tempHdl,&theRect);				HUnlock(tempHdl);				DisposeHandle(tempHdl);			}			else				doErrorAlert(eGetScrapSize);		}	}	TextMode(srcOr);	SetPort(oldPort);}// ********************************************************************** doDrawDocumentWindowvoid  doDrawDocumentWindow(WindowRef windowRef){	GrafPtr							oldPort;	docStructureHandle	docStrucHdl;	Rect  							destRect;	CFStringRef					stringRef;	GetPort(&oldPort);	SetPortWindowPort(windowRef);	docStrucHdl = (docStructureHandle) GetWRefCon(windowRef);	if((*docStrucHdl)->textHdl != NULL)	{		GetWindowPortBounds(windowRef,&destRect);		EraseRect(&destRect);		InsetRect(&destRect,40,40);		stringRef =	CFStringCreateWithBytes(NULL,(UInt8 *) *(*docStrucHdl)->textHdl,																				GetHandleSize((*docStrucHdl)->textHdl),																				smSystemScript,false);		DrawThemeTextBox(stringRef,kThemeSmallSystemFont,0,true,&destRect,teFlushLeft,NULL);		if(stringRef != NULL)			CFRelease(stringRef);		if((*docStrucHdl)->selectFlag)			InvertRect(&destRect);	}	else if((*docStrucHdl)->pictureHdl != NULL)	{		destRect = doSetDestRect(&(*(*docStrucHdl)->pictureHdl)->picFrame,windowRef);		DrawPicture((*docStrucHdl)->pictureHdl,&destRect);		if((*docStrucHdl)->selectFlag)			InvertRect(&destRect);	} 	SetPort(oldPort);}// ***************************************************************************** doSetDestRectRect  doSetDestRect(Rect *picFrame,WindowRef windowRef){	Rect		destRect, portRect;	SInt16	diffX, diffY;	destRect = *picFrame;	GetWindowPortBounds(windowRef,&portRect);		OffsetRect(&destRect,-(*picFrame).left,-(*picFrame).top);	diffX = (portRect.right - portRect.left) - ((*picFrame).right - (*picFrame).left);	diffY = (portRect.bottom - portRect.top) - ((*picFrame).bottom - (*picFrame).top);	OffsetRect(&destRect,diffX / 2,diffY / 2);	return destRect;}// *******************************************************************************************